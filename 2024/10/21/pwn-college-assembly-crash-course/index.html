<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="pwncollege的汇编模块">
<meta property="og:type" content="article">
<meta property="og:title" content="assembly-crash-course">
<meta property="og:url" content="http://example.com/2024/10/21/pwn-college-assembly-crash-course/index.html">
<meta property="og:site_name" content="lianwu&#39;s blog">
<meta property="og:description" content="pwncollege的汇编模块">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-21T13:19:06.000Z">
<meta property="article:modified_time" content="2024-10-21T12:10:48.431Z">
<meta property="article:author" content="lianwu">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="pwn-college">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/10/21/pwn-college-assembly-crash-course/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/10/21/pwn-college-assembly-crash-course/","path":"2024/10/21/pwn-college-assembly-crash-course/","title":"assembly-crash-course"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>assembly-crash-course | lianwu's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">lianwu's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#level1"><span class="nav-number">1.</span> <span class="nav-text">level1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level2"><span class="nav-number">2.</span> <span class="nav-text">level2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level3"><span class="nav-number">3.</span> <span class="nav-text">level3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level4"><span class="nav-number">4.</span> <span class="nav-text">level4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level5"><span class="nav-number">5.</span> <span class="nav-text">level5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level6"><span class="nav-number">6.</span> <span class="nav-text">level6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level7"><span class="nav-number">7.</span> <span class="nav-text">level7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level8"><span class="nav-number">8.</span> <span class="nav-text">level8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level9"><span class="nav-number">9.</span> <span class="nav-text">level9</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level10"><span class="nav-number">10.</span> <span class="nav-text">level10</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level11"><span class="nav-number">11.</span> <span class="nav-text">level11</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level12"><span class="nav-number">12.</span> <span class="nav-text">level12</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level13"><span class="nav-number">13.</span> <span class="nav-text">level13</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level14"><span class="nav-number">14.</span> <span class="nav-text">level14</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level15"><span class="nav-number">15.</span> <span class="nav-text">level15</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level16"><span class="nav-number">16.</span> <span class="nav-text">level16</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level17"><span class="nav-number">17.</span> <span class="nav-text">level17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level18"><span class="nav-number">18.</span> <span class="nav-text">level18</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level19"><span class="nav-number">19.</span> <span class="nav-text">level19</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level20"><span class="nav-number">20.</span> <span class="nav-text">level20</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level21"><span class="nav-number">21.</span> <span class="nav-text">level21</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level22"><span class="nav-number">22.</span> <span class="nav-text">level22</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level23"><span class="nav-number">23.</span> <span class="nav-text">level23</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level24"><span class="nav-number">24.</span> <span class="nav-text">level24</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level25"><span class="nav-number">25.</span> <span class="nav-text">level25</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level26"><span class="nav-number">26.</span> <span class="nav-text">level26</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level27"><span class="nav-number">27.</span> <span class="nav-text">level27</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level28"><span class="nav-number">28.</span> <span class="nav-text">level28</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level29"><span class="nav-number">29.</span> <span class="nav-text">level29</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#level30"><span class="nav-number">30.</span> <span class="nav-text">level30</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lianwu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">lianwu</p>
  <div class="site-description" itemprop="description">Betting the rest of your life on pwn.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/pwn-college-assembly-crash-course/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="lianwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lianwu's blog">
      <meta itemprop="description" content="Betting the rest of your life on pwn.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="assembly-crash-course | lianwu's blog">
      <meta itemprop="description" content="pwncollege的汇编模块">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          assembly-crash-course
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-21 21:19:06 / 修改时间：20:10:48" itemprop="dateCreated datePublished" datetime="2024-10-21T21:19:06+08:00">2024-10-21</time>
    </span>

  
</div>

            <div class="post-description">pwncollege的汇编模块</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Welcome to ASMLevel1</span><br><span class="line">==================================================</span><br><span class="line"></span><br><span class="line">To interact with any level you will send raw bytes over stdin to this program.</span><br><span class="line">To efficiently solve these problems, first run it to see the challenge instructions.</span><br><span class="line">Then craft, assemble, and pipe your bytes to this program.</span><br><span class="line"></span><br><span class="line">For instance, if you write your assembly code in the file asm.S, you can assemble that to an object file:</span><br><span class="line">  as -o asm.o asm.S</span><br><span class="line"></span><br><span class="line">Note that if you want to use Intel syntax for x86 (which, of course, you do), you&#x27;ll need to add the following to the start of asm.S:</span><br><span class="line">  .intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">Then, you can copy the .text section (your code) to the file asm.bin:</span><br><span class="line">  objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line"></span><br><span class="line">And finally, send that to the challenge:</span><br><span class="line">  cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">You can even run this as one command:</span><br><span class="line">  as -o asm.o asm.S &amp;&amp; objcopy -O binary --only-section=.text ./asm.o ./asm.bin &amp;&amp; cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br></pre></td></tr></table></figure>



<p>关卡要求修改特定寄存器的值并提示可以使用objcopy工具将text段复制到文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#asm.S</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, 0x1337</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">as -o asm.o asm.S</span><br><span class="line">objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line">cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Welcome to ASMLevel1</span><br><span class="line">==================================================</span><br><span class="line"></span><br><span class="line">To interact with any level you will send raw bytes over stdin to this program.</span><br><span class="line">To efficiently solve these problems, first run it to see the challenge instructions.</span><br><span class="line">Then craft, assemble, and pipe your bytes to this program.</span><br><span class="line"></span><br><span class="line">For instance, if you write your assembly code in the file asm.S, you can assemble that to an object file:</span><br><span class="line">  as -o asm.o asm.S</span><br><span class="line"></span><br><span class="line">Note that if you want to use Intel syntax for x86 (which, of course, you do), you&#x27;ll need to add the following to the start of asm.S:</span><br><span class="line">  .intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">Then, you can copy the .text section (your code) to the file asm.bin:</span><br><span class="line">  objcopy -O binary --only-section=.text asm.o asm.bin</span><br><span class="line"></span><br><span class="line">And finally, send that to the challenge:</span><br><span class="line">  cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">You can even run this as one command:</span><br><span class="line">  as -o asm.o asm.S &amp;&amp; objcopy -O binary --only-section=.text ./asm.o ./asm.bin &amp;&amp; cat ./asm.bin | /challenge/run</span><br><span class="line"></span><br><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level you will work with registers! Please set the following:</span><br><span class="line">  rdi = 0x1337</span><br><span class="line"></span><br><span class="line">Please give me your assembly in bytes (up to 0x1000 bytes): </span><br><span class="line">Executing your code...</span><br><span class="line">---------------- CODE ----------------</span><br><span class="line">0x400000:       mov     rdi, 0x1337</span><br><span class="line">--------------------------------------</span><br><span class="line">pwn.college&#123;AJWwZ7nrzaB0HKKeQpKdrgeX250.0FN5EDLwgDMzEzW&#125;</span><br></pre></td></tr></table></figure>

<h1 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level you will work with multiple registers. Please set the following:</span><br><span class="line">  rax = 0x1337</span><br><span class="line">  r12 = 0xCAFED00D1337BEEF</span><br><span class="line">  rsp = 0x31337</span><br></pre></td></tr></table></figure>

<p>直接mov就行了</p>
<h1 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Many instructions exist in x86 that allow you to do all the normal</span><br><span class="line">math operations on registers and memory.</span><br><span class="line"></span><br><span class="line">For shorthand, when we say A += B, it really means A = A + B.</span><br><span class="line"></span><br><span class="line">Here are some useful instructions:</span><br><span class="line">  add reg1, reg2       &lt;=&gt;     reg1 += reg2</span><br><span class="line">  sub reg1, reg2       &lt;=&gt;     reg1 -= reg2</span><br><span class="line">  imul reg1, reg2      &lt;=&gt;     reg1 *= reg2</span><br><span class="line"></span><br><span class="line">div is more complicated and we will discuss it later.</span><br><span class="line">Note: all &#x27;regX&#x27; can be replaced by a constant or memory location</span><br><span class="line"></span><br><span class="line">Do the following:</span><br><span class="line">  add 0x331337 to rdi</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x266</span><br></pre></td></tr></table></figure>

<p>关卡要求使用add改变rdi值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    add rdi, 0x331337</span><br></pre></td></tr></table></figure>

<p>如上代码即可</p>
<h1 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using your new knowledge, please compute the following:</span><br><span class="line">  f(x) = mx + b, where:</span><br><span class="line">    m = rdi</span><br><span class="line">    x = rsi</span><br><span class="line">    b = rdx</span><br><span class="line"></span><br><span class="line">Place the result into rax.</span><br><span class="line"></span><br><span class="line">Note: there is an important difference between mul (unsigned</span><br><span class="line">multiply) and imul (signed multiply) in terms of which</span><br><span class="line">registers are used. Look at the documentation on these</span><br><span class="line">instructions to see the difference.</span><br><span class="line"></span><br><span class="line">In this case, you will want to use imul.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2470</span><br><span class="line">  rsi = 0x16fb</span><br><span class="line">  rdx = 0x26ed</span><br></pre></td></tr></table></figure>

<p>本关卡要求计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(x) = mx + b</span><br><span class="line">其中</span><br><span class="line">  m = rdi</span><br><span class="line">  x = rsi</span><br><span class="line">  b = rdi</span><br><span class="line">并将结果存入rax中</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    imul rax, rsi ;</span><br><span class="line">    add rax, rdx ;</span><br></pre></td></tr></table></figure>

<p>即可</p>
<h1 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Division in x86 is more special than in normal math. Math in here is</span><br><span class="line">called integer math. This means every value is a whole number.</span><br><span class="line"></span><br><span class="line">As an example: 10 / 3 = 3 in integer math.</span><br><span class="line"></span><br><span class="line">Why?</span><br><span class="line"></span><br><span class="line">Because 3.33 is rounded down to an integer.</span><br><span class="line"></span><br><span class="line">The relevant instructions for this level are:</span><br><span class="line">  mov rax, reg1; div reg2</span><br><span class="line"></span><br><span class="line">Note: div is a special instruction that can divide</span><br><span class="line">a 128-bit dividend by a 64-bit divisor, while</span><br><span class="line">storing both the quotient and the remainder, using only one register as an operand.</span><br><span class="line"></span><br><span class="line">How does this complex div instruction work and operate on a</span><br><span class="line">128-bit dividend (which is twice as large as a register)?</span><br><span class="line"></span><br><span class="line">For the instruction: div reg, the following happens:</span><br><span class="line">  rax = rdx:rax / reg</span><br><span class="line">  rdx = remainder</span><br><span class="line"></span><br><span class="line">rdx:rax means that rdx will be the upper 64-bits of</span><br><span class="line">the 128-bit dividend and rax will be the lower 64-bits of the</span><br><span class="line">128-bit dividend.</span><br><span class="line"></span><br><span class="line">You must be careful about what is in rdx and rax before you call div.</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  speed = distance / time, where:</span><br><span class="line">    distance = rdi</span><br><span class="line">    time = rsi</span><br><span class="line">    speed = rax</span><br><span class="line"></span><br><span class="line">Note that distance will be at most a 64-bit value, so rdx should be 0 when dividing.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2069</span><br><span class="line">  rsi = 0x44</span><br></pre></td></tr></table></figure>

<p>关卡要求计算速度，速度&#x3D;距离&#x2F;时间</p>
<p>使用div指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    mov rdx, 0 ;</span><br><span class="line">    div rsi ;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Modulo in assembly is another interesting concept!</span><br><span class="line"></span><br><span class="line">x86 allows you to get the remainder after a div operation.</span><br><span class="line"></span><br><span class="line">For instance: 10 / 3 -&gt; remainder = 1</span><br><span class="line"></span><br><span class="line">The remainder is the same as modulo, which is also called the &quot;mod&quot; operator.</span><br><span class="line"></span><br><span class="line">In most programming languages we refer to mod with the symbol &#x27;%&#x27;.</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  rdi % rsi</span><br><span class="line"></span><br><span class="line">Place the value in rax.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2eaa4872</span><br><span class="line">  rsi = 0x3</span><br></pre></td></tr></table></figure>

<p>关卡要求计算模，在x86-64中可使用idiv来计算模</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, rdi ;</span><br><span class="line">    idiv rsi;</span><br><span class="line">    mov rax,rdx;</span><br></pre></td></tr></table></figure>

<p>最终余数存储在rdx中</p>
<h1 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Another cool concept in x86 is the ability to independently access to lower register bytes.</span><br><span class="line"></span><br><span class="line">Each register in x86_64 is 64 bits in size, and in the previous levels we have accessed</span><br><span class="line">the full register using rax, rdi or rsi.</span><br><span class="line"></span><br><span class="line">We can also access the lower bytes of each register using different register names.</span><br><span class="line"></span><br><span class="line">For example the lower 32 bits of rax can be accessed using eax, the lower 16 bits using ax,</span><br><span class="line">the lower 8 bits using al.</span><br><span class="line"></span><br><span class="line">MSB                                    LSB</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                   rax                  |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">                     |        eax        |</span><br><span class="line">                     +---------+---------+</span><br><span class="line">                               |   ax    |</span><br><span class="line">                               +----+----+</span><br><span class="line">                               | ah | al |</span><br><span class="line">                               +----+----+</span><br><span class="line"></span><br><span class="line">Lower register bytes access is applicable to almost all registers.</span><br><span class="line"></span><br><span class="line">Using only one move instruction, please set the upper 8 bits of the ax register to 0x42.</span><br></pre></td></tr></table></figure>

<p>关卡要求仅使用一个mov使ax的高8位变为0x42，已经给出提示，rax，eax，ax，al，以及ah对应ax的高8位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0x42;</span><br></pre></td></tr></table></figure>



<h1 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">It turns out that using the div operator to compute the modulo operation is slow!</span><br><span class="line"></span><br><span class="line">We can use a math trick to optimize the modulo operator (%). Compilers use this trick a lot.</span><br><span class="line"></span><br><span class="line">If we have &quot;x % y&quot;, and y is a power of 2, such as 2^n, the result will be the lower n bits of x.</span><br><span class="line"></span><br><span class="line">Therefore, we can use the lower register byte access to efficiently implement modulo!</span><br><span class="line"></span><br><span class="line">Using only the following instruction(s):</span><br><span class="line">  mov</span><br><span class="line"></span><br><span class="line">Please compute the following:</span><br><span class="line">  rax = rdi % 256</span><br><span class="line">  rbx = rsi % 65536</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x3ae0</span><br><span class="line">  rsi = 0x8bd5220f</span><br></pre></td></tr></table></figure>

<p>关卡给出关于<code> x%y 且 y为2^n</code>的计算方法</p>
<p>即rdi的低8位和rsi的低16位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov al, dil;</span><br><span class="line">    mov bx, si;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>al,dil为寄存器低8位，bx，si为低16位</p>
<h1 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with registers. You will be asked to modify</span><br><span class="line">or read from registers.</span><br><span class="line"></span><br><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shifting bits around in assembly is another interesting concept!</span><br><span class="line"></span><br><span class="line">x86 allows you to &#x27;shift&#x27; bits around in a register.</span><br><span class="line"></span><br><span class="line">Take, for instance, al, the lowest 8 bits of rax.</span><br><span class="line"></span><br><span class="line">The value in al (in bits) is:</span><br><span class="line">  rax = 10001010</span><br><span class="line"></span><br><span class="line">If we shift once to the left using the shl instruction:</span><br><span class="line">  shl al, 1</span><br><span class="line"></span><br><span class="line">The new value is:</span><br><span class="line">  al = 00010100</span><br><span class="line"></span><br><span class="line">Everything shifted to the left and the highest bit fell off</span><br><span class="line">while a new 0 was added to the right side.</span><br><span class="line"></span><br><span class="line">You can use this to do special things to the bits you care about.</span><br><span class="line"></span><br><span class="line">Shifting has the nice side affect of doing quick multiplication (by 2)</span><br><span class="line">or division (by 2), and can also be used to compute modulo.</span><br><span class="line"></span><br><span class="line">Here are the important instructions:</span><br><span class="line">  shl reg1, reg2       &lt;=&gt;     Shift reg1 left by the amount in reg2</span><br><span class="line">  shr reg1, reg2       &lt;=&gt;     Shift reg1 right by the amount in reg2</span><br><span class="line">  Note: &#x27;reg2&#x27; can be replaced by a constant or memory location</span><br><span class="line"></span><br><span class="line">Using only the following instructions:</span><br><span class="line">  mov, shr, shl</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the 5th least significant byte of rdi.</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">  rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</span><br><span class="line">  Set rax to the value of B4</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x5fd037c216a02397</span><br></pre></td></tr></table></figure>

<p>关卡要求将rax设置位rdi的第五个最低有效字节，使用位移动指令</p>
<p>直接将rdi第5个最低有效字节挪到最低8位，再使用mov即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    shr rdi,32 ;</span><br><span class="line">    mov al, dil;</span><br></pre></td></tr></table></figure>



<h1 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bitwise logic in assembly is yet another interesting concept!</span><br><span class="line">x86 allows you to perform logic operations bit by bit on registers.</span><br><span class="line"></span><br><span class="line">For the sake of this example say registers only store 8 bits.</span><br><span class="line"></span><br><span class="line">The values in rax and rbx are:</span><br><span class="line">  rax = 10101010</span><br><span class="line">  rbx = 00110011</span><br><span class="line"></span><br><span class="line">If we were to perform a bitwise AND of rax and rbx using the</span><br><span class="line">&quot;and rax, rbx&quot; instruction, the result would be calculated by</span><br><span class="line">ANDing each bit pair 1 by 1 hence why it&#x27;s called a bitwise</span><br><span class="line">logic.</span><br><span class="line"></span><br><span class="line">So from left to right:</span><br><span class="line">  1 AND 0 = 0</span><br><span class="line">  0 AND 0 = 0</span><br><span class="line">  1 AND 1 = 1</span><br><span class="line">  0 AND 1 = 0</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Finally we combine the results together to get:</span><br><span class="line">  rax = 00100010</span><br><span class="line"></span><br><span class="line">Here are some truth tables for reference:</span><br><span class="line">      AND          OR           XOR</span><br><span class="line">   A | B | X    A | B | X    A | B | X</span><br><span class="line">  ---+---+---  ---+---+---  ---+---+---</span><br><span class="line">   0 | 0 | 0    0 | 0 | 0    0 | 0 | 0</span><br><span class="line">   0 | 1 | 0    0 | 1 | 1    0 | 1 | 1</span><br><span class="line">   1 | 0 | 0    1 | 0 | 1    1 | 0 | 1</span><br><span class="line">   1 | 1 | 1    1 | 1 | 1    1 | 1 | 0</span><br><span class="line"></span><br><span class="line">Without using the following instructions:</span><br><span class="line">  mov, xchg</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  rax = rdi AND rsi</span><br><span class="line"></span><br><span class="line">i.e. Set rax to the value of (rdi AND rsi)</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x6909f54276a98049</span><br><span class="line">  rsi = 0x8890371dbbabe438</span><br></pre></td></tr></table></figure>

<p>首先对rax清零，再将rdi and rsi的结果放在rdi中，最后进行或操作即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    and rdi,rsi</span><br><span class="line">    or rax, rdi</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h1 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with bit logic and operations. This will involve heavy use of</span><br><span class="line">directly interacting with bits stored in a register or memory location. You will also likely</span><br><span class="line">need to make use of the logic instructions in x86: and, or, not, xor.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Using only the following instructions:</span><br><span class="line">  and, or, xor</span><br><span class="line"></span><br><span class="line">Implement the following logic:</span><br><span class="line">  if x is even then</span><br><span class="line">    y = 1</span><br><span class="line">  else</span><br><span class="line">    y = 0</span><br><span class="line"></span><br><span class="line">where:</span><br><span class="line">  x = rdi</span><br><span class="line">  y = rax</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x1358ee67</span><br></pre></td></tr></table></figure>

<p>关卡要求使用and、or、xor三个指令，进行逻辑判断，当x为偶数时，y&#x3D;1，反之y&#x3D;0，x为rdi，y为rax</p>
<p>先对rax清零，再将rdi的值给rax，最后对rax判断奇偶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    xor rax,rdi</span><br><span class="line">    and rax, 1</span><br><span class="line">    xor rax,1</span><br></pre></td></tr></table></figure>

<h1 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h1><p>没什么好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,0x404000</span><br><span class="line">mov [rdi],rax</span><br></pre></td></tr></table></figure>

<p>加个中转用的寄存器就行了</p>
<h1 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">We will now set some values in memory dynamically before each run. On each run</span><br><span class="line">the values will change. This means you will need to do some type of formulaic</span><br><span class="line">operation with registers. We will tell you which registers are set beforehand</span><br><span class="line">and where you should put the result. In most cases, its rax.</span><br><span class="line"></span><br><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Place the value stored at 0x404000 into rax</span><br><span class="line">  Increment the value stored at the address 0x404000 by 0x1337</span><br><span class="line"></span><br><span class="line">Make sure the value in rax is the original value stored at 0x404000 and make sure</span><br><span class="line">that [0x404000] now has the incremented value.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0x1dd994</span><br></pre></td></tr></table></figure>

<p>关卡要求将特定地址的值赋给寄存器，修改特定地址的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax, [0x404000]   ; </span><br><span class="line">    add rax, 0x1337       ; </span><br><span class="line">    mov [0x404000], rax   ;</span><br><span class="line">    sub rax, 0x1337       ;</span><br></pre></td></tr></table></figure>

<h1 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Recall that registers in x86_64 are 64 bits wide, meaning they can store 64 bits.</span><br><span class="line"></span><br><span class="line">Similarly, each memory location can be treated as a 64 bit value.</span><br><span class="line"></span><br><span class="line">We refer to something that is 64 bits (8 bytes) as a quad word.</span><br><span class="line"></span><br><span class="line">Here is the breakdown of the names of memory sizes:</span><br><span class="line">  Quad Word   = 8 Bytes = 64 bits</span><br><span class="line">  Double Word = 4 bytes = 32 bits</span><br><span class="line">  Word        = 2 bytes = 16 bits</span><br><span class="line">  Byte        = 1 byte  = 8 bits</span><br><span class="line"></span><br><span class="line">In x86_64, you can access each of these sizes when dereferencing an address, just like using</span><br><span class="line">bigger or smaller register accesses:</span><br><span class="line">  mov al, [address]        &lt;=&gt;        moves the least significant byte from address to rax</span><br><span class="line">  mov ax, [address]        &lt;=&gt;        moves the least significant word from address to rax</span><br><span class="line">  mov eax, [address]       &lt;=&gt;        moves the least significant double word from address to rax</span><br><span class="line">  mov rax, [address]       &lt;=&gt;        moves the full quad word from address to rax</span><br><span class="line"></span><br><span class="line">Remember that moving into al does not fully clear the upper bytes.</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the byte at 0x404000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0xff01c</span><br></pre></td></tr></table></figure>

<p>设置单字节数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Recall the following:</span><br><span class="line">  The breakdown of the names of memory sizes:</span><br><span class="line">    Quad Word   = 8 Bytes = 64 bits</span><br><span class="line">    Double Word = 4 bytes = 32 bits</span><br><span class="line">    Word        = 2 bytes = 16 bits</span><br><span class="line">    Byte        = 1 byte  = 8 bits</span><br><span class="line"></span><br><span class="line">In x86_64, you can access each of these sizes when dereferencing an address, just like using</span><br><span class="line">bigger or smaller register accesses:</span><br><span class="line">  mov al, [address]        &lt;=&gt;        moves the least significant byte from address to rax</span><br><span class="line">  mov ax, [address]        &lt;=&gt;        moves the least significant word from address to rax</span><br><span class="line">  mov eax, [address]       &lt;=&gt;        moves the least significant double word from address to rax</span><br><span class="line">  mov rax, [address]       &lt;=&gt;        moves the full quad word from address to rax</span><br><span class="line"></span><br><span class="line">Please perform the following:</span><br><span class="line">  Set rax to the byte at 0x404000</span><br><span class="line">  Set rbx to the word at 0x404000</span><br><span class="line">  Set rcx to the double word at 0x404000</span><br><span class="line">  Set rdx to the quad word at 0x404000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404000] = 0x872b88618a05e240</span><br></pre></td></tr></table></figure>

<p>关卡要求将不同寄存器设置为特定地址的字节，字，双字，四字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">四字 = 8 字节 = 64 位</span><br><span class="line">双字 = 4 字节 = 32 位</span><br><span class="line">字 = 2 字节 = 16 位</span><br><span class="line">字节 = 1 字节 = 8 位</span><br><span class="line">mov al，[地址] &lt;=&gt; 将最低有效字节从地址移动到 rax</span><br><span class="line">mov ax，[地址] &lt;=&gt; 将最低有效字从地址移动到 rax</span><br><span class="line">mov eax，[地址] &lt;=&gt; 将最低有效双字从地址移动到 rax</span><br><span class="line">mov rax，[地址] &lt;=&gt; 将完整的四字从地址移动到 rax</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov al,[0x404000]</span><br><span class="line">    mov bx,[0x404000]</span><br><span class="line">    mov ecx,[0x404000]</span><br><span class="line">    mov rdx,[0x404000]</span><br></pre></td></tr></table></figure>



<h1 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It is worth noting, as you may have noticed, that values are stored in reverse order of how we</span><br><span class="line">represent them.</span><br><span class="line"></span><br><span class="line">As an example, say:</span><br><span class="line">  [0x1330] = 0x00000000deadc0de</span><br><span class="line"></span><br><span class="line">If you examined how it actually looked in memory, you would see:</span><br><span class="line">  [0x1330] = 0xde</span><br><span class="line">  [0x1331] = 0xc0</span><br><span class="line">  [0x1332] = 0xad</span><br><span class="line">  [0x1333] = 0xde</span><br><span class="line">  [0x1334] = 0x00</span><br><span class="line">  [0x1335] = 0x00</span><br><span class="line">  [0x1336] = 0x00</span><br><span class="line">  [0x1337] = 0x00</span><br><span class="line"></span><br><span class="line">This format of storing things in &#x27;reverse&#x27; is intentional in x86, and its called &quot;Little Endian&quot;.</span><br><span class="line"></span><br><span class="line">For this challenge we will give you two addresses created dynamically each run.</span><br><span class="line"></span><br><span class="line">The first address will be placed in rdi.</span><br><span class="line">The second will be placed in rsi.</span><br><span class="line"></span><br><span class="line">Using the earlier mentioned info, perform the following:</span><br><span class="line">  Set [rdi] = 0xdeadbeef00001337</span><br><span class="line">  Set [rsi] = 0xc0ffee0000</span><br><span class="line"></span><br><span class="line">Hint: it may require some tricks to assign a big constant to a dereferenced register.</span><br><span class="line">Try setting a register to the constant value then assigning that register to the dereferenced register.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x404330] = 0xffffffffffffffff</span><br><span class="line">  [0x4048d0] = 0xffffffffffffffff</span><br><span class="line">  rdi = 0x404330</span><br><span class="line">  rsi = 0x4048d0</span><br></pre></td></tr></table></figure>

<p>关卡有提到，值的存储顺序与我们表示它们的顺序相反，即小端序，关卡要求将两个存放在寄存器中的地址的值设置为特定大常数</p>
<p>使用未使用的寄存器rax来当作中间寄存器，0xc0ffee0000占40位，需要用[rsi+4]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor rax,rax</span><br><span class="line">    mov rax,0xdeadbeef00001337</span><br><span class="line">    mov [rdi],rax</span><br><span class="line">    xor rax,rax</span><br><span class="line">    mov [rsi],rax</span><br><span class="line">    mov rax,0xc0ffee0000</span><br><span class="line">    mov [rsi],eax</span><br><span class="line">    shr rax,32</span><br><span class="line">    mov byte ptr [rsi+4],al</span><br></pre></td></tr></table></figure>



<h1 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with memory. This will require you to read or write</span><br><span class="line">to things stored linearly in memory. If you are confused, go look at the linear</span><br><span class="line">addressing module in &#x27;ike. You may also be asked to dereference things, possibly multiple</span><br><span class="line">times, to things we dynamically put in memory for your use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Recall that memory is stored linearly.</span><br><span class="line"></span><br><span class="line">What does that mean?</span><br><span class="line"></span><br><span class="line">Say we access the quad word at 0x1337:</span><br><span class="line">  [0x1337] = 0x00000000deadbeef</span><br><span class="line"></span><br><span class="line">The real way memory is layed out is byte by byte, little endian:</span><br><span class="line">  [0x1337] = 0xef</span><br><span class="line">  [0x1337 + 1] = 0xbe</span><br><span class="line">  [0x1337 + 2] = 0xad</span><br><span class="line">  ...</span><br><span class="line">  [0x1337 + 7] = 0x00</span><br><span class="line"></span><br><span class="line">What does this do for us?</span><br><span class="line"></span><br><span class="line">Well, it means that we can access things next to each other using offsets,</span><br><span class="line">similar to what was shown above.</span><br><span class="line"></span><br><span class="line">Say you want the 5th *byte* from an address, you can access it like:</span><br><span class="line">  mov al, [address+4]</span><br><span class="line"></span><br><span class="line">Remember, offsets start at 0.</span><br><span class="line"></span><br><span class="line">Perform the following:</span><br><span class="line">  Load two consecutive quad words from the address stored in rdi</span><br><span class="line">  Calculate the sum of the previous steps quad words.</span><br><span class="line">  Store the sum at the address in rsi</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x4041c8] = 0x65a6c</span><br><span class="line">  [0x4041d0] = 0xe45f3</span><br><span class="line">  rdi = 0x4041c8</span><br><span class="line">  rsi = 0x404790</span><br></pre></td></tr></table></figure>

<p>关卡要求计算从rdi开始加载两个连续的四字，计算其总和并存储在rsi的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rax,[rdi]</span><br><span class="line">    mov rbx,[rdi+8]</span><br><span class="line">    add rax,rbx</span><br><span class="line">    mov [rsi],rax</span><br></pre></td></tr></table></figure>



<h1 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with the stack, the memory region that dynamically expands</span><br><span class="line">and shrinks. You will be required to read and write to the stack, which may require you to use</span><br><span class="line">the pop and push instructions. You may also need to use the stack pointer register (rsp) to know</span><br><span class="line">where the stack is pointing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In these levels we are going to introduce the stack.</span><br><span class="line"></span><br><span class="line">The stack is a region of memory that can store values for later.</span><br><span class="line"></span><br><span class="line">To store a value on the stack we use the push instruction, and to retrieve a value we use pop.</span><br><span class="line"></span><br><span class="line">The stack is a last in first out (LIFO) memory structure, and this means</span><br><span class="line">the last value pushed in the first value popped.</span><br><span class="line"></span><br><span class="line">Imagine unloading plates from the dishwasher let&#x27;s say there are 1 red, 1 green, and 1 blue.</span><br><span class="line">First we place the red one in the cabinet, then the green on top of the red, then the blue.</span><br><span class="line"></span><br><span class="line">Our stack of plates would look like:</span><br><span class="line">  Top ----&gt; Blue</span><br><span class="line">            Green</span><br><span class="line">  Bottom -&gt; Red</span><br><span class="line"></span><br><span class="line">Now, if we wanted a plate to make a sandwich we would retrieve the top plate from the stack</span><br><span class="line">which would be the blue one that was last into the cabinet, ergo the first one out.</span><br><span class="line"></span><br><span class="line">On x86, the pop instruction will take the value from the top of the stack and put it into a register.</span><br><span class="line"></span><br><span class="line">Similarly, the push instruction will take the value in a register and push it onto the top of the stack.</span><br><span class="line"></span><br><span class="line">Using these instructions, take the top value of the stack, subtract rdi from it, then put it back.</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0xaef0</span><br><span class="line">  (stack) [0x7fffff1ffff8] = 0x23c9d32d</span><br></pre></td></tr></table></figure>

<p>对栈进行基本操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    pop rax;</span><br><span class="line">    sub rax,rdi;</span><br><span class="line">    push rax;</span><br></pre></td></tr></table></figure>



<h1 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with the stack, the memory region that dynamically expands</span><br><span class="line">and shrinks. You will be required to read and write to the stack, which may require you to use</span><br><span class="line">the pop and push instructions. You may also need to use the stack pointer register (rsp) to know</span><br><span class="line">where the stack is pointing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In this level we are going to explore the last in first out (LIFO) property of the stack.</span><br><span class="line"></span><br><span class="line">Using only following instructions:</span><br><span class="line">  push, pop</span><br><span class="line"></span><br><span class="line">Swap values in rdi and rsi.</span><br><span class="line">i.e.</span><br><span class="line">If to start rdi = 2 and rsi = 5</span><br><span class="line">Then to end rdi = 5 and rsi = 2</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  rdi = 0x2bdae14</span><br><span class="line">  rsi = 0x1820507e</span><br></pre></td></tr></table></figure>

<p>本关探索LIFO，仅使用po，push的情况下交换rdi和rsi的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    push rdi;</span><br><span class="line">    push rsi;</span><br><span class="line">    pop rdi;</span><br><span class="line">    pop rsi;</span><br></pre></td></tr></table></figure>



<h1 id="level21"><a href="#level21" class="headerlink" title="level21"></a>level21</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In the previous levels you used push and pop to store and load data from the stack.</span><br><span class="line"></span><br><span class="line">However you can also access the stack directly using the stack pointer.</span><br><span class="line"></span><br><span class="line">On x86, the stack pointer is stored in the special register, rsp.</span><br><span class="line">rsp always stores the memory address of the top of the stack,</span><br><span class="line">i.e. the memory address of the last value pushed.</span><br><span class="line"></span><br><span class="line">Similar to the memory levels, we can use [rsp] to access the value at the memory address in rsp.</span><br><span class="line"></span><br><span class="line">Without using pop, please calculate the average of 4 consecutive quad words stored on the stack.</span><br><span class="line"></span><br><span class="line">Push the average on the stack.</span><br><span class="line"></span><br><span class="line">Hint:</span><br><span class="line">  RSP+0x?? Quad Word A</span><br><span class="line">  RSP+0x?? Quad Word B</span><br><span class="line">  RSP+0x?? Quad Word C</span><br><span class="line">  RSP      Quad Word D</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  (stack) [0x7fffff200000:0x7fffff1fffe0] = [&#x27;0x26044e9d&#x27;, &#x27;0x195ec9b6&#x27;, &#x27;0x11ac1d55&#x27;, &#x27;0x1eff98ab&#x27;] (list of things)</span><br></pre></td></tr></table></figure>

<p>关卡要求使用rsp来获取栈上数据，并计算其平均值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov rax, [rsp]       </span><br><span class="line">   mov rbx, [rsp+0x8]    </span><br><span class="line">   mov rcx, [rsp+0x10]   </span><br><span class="line">   mov rdx, [rsp+0x18]   </span><br><span class="line"></span><br><span class="line">   add rax, rbx          </span><br><span class="line">   add rax, rcx          </span><br><span class="line">   add rax, rdx          </span><br><span class="line"></span><br><span class="line">   shr rax, 2            </span><br><span class="line"></span><br><span class="line">   push rax              </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="level22"><a href="#level22" class="headerlink" title="level22"></a>level22</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In this level, you will work with jumps.</span><br><span class="line"></span><br><span class="line">There are two types of jumps:</span><br><span class="line">  Unconditional jumps</span><br><span class="line">  Conditional jumps</span><br><span class="line"></span><br><span class="line">Unconditional jumps always trigger and are not based on the results of earlier instructions.</span><br><span class="line"></span><br><span class="line">As you know, memory locations can store data and instructions.</span><br><span class="line"></span><br><span class="line">Your code will be stored at 0x400039 (this will change each run).</span><br><span class="line"></span><br><span class="line">For all jumps, there are three types:</span><br><span class="line">  Relative jumps: jump + or - the next instruction.</span><br><span class="line">  Absolute jumps: jump to a specific address.</span><br><span class="line">  Indirect jumps: jump to the memory address specified in a register.</span><br><span class="line"></span><br><span class="line">In x86, absolute jumps (jump to a specific address) are accomplished by first putting the target address in a register reg, then doing jmp reg.</span><br><span class="line"></span><br><span class="line">In this level we will ask you to do an absolute jump.</span><br><span class="line"></span><br><span class="line">Perform the following:</span><br><span class="line">  Jump to the absolute address 0x403000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x400039</span><br></pre></td></tr></table></figure>

<p>关卡要求进行绝对跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov rax,0x403000</span><br><span class="line">   jmp rax</span><br></pre></td></tr></table></figure>



<h1 id="level23"><a href="#level23" class="headerlink" title="level23"></a>level23</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In this level we will ask you to do a relative jump.</span><br><span class="line"></span><br><span class="line">You will need to fill space in your code with something to make this relative jump possible.</span><br><span class="line"></span><br><span class="line">We suggest using the `nop` instruction. It&#x27;s 1 byte long and very predictable.</span><br><span class="line"></span><br><span class="line">In fact, the as assembler that we&#x27;re using has a handy .rept directive that you can use to</span><br><span class="line">repeat assembly instructions some number of times:</span><br><span class="line">  https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html</span><br><span class="line"></span><br><span class="line">Useful instructions for this level:</span><br><span class="line">  jmp (reg1 | addr | offset) ; nop</span><br><span class="line"></span><br><span class="line">Hint: for the relative jump, lookup how to use `labels` in x86.</span><br><span class="line"></span><br><span class="line">Using the above knowledge, perform the following:</span><br><span class="line">  Make the first instruction in your code a jmp</span><br><span class="line">  Make that jmp a relative jump to 0x51 bytes from the current position</span><br><span class="line">  At the code location where the relative jump will redirect control flow set rax to 0x1</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x40009a</span><br></pre></td></tr></table></figure>



<p>关卡要求相对跳转，提示使用nop和.rept</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   jmp loop</span><br><span class="line">   .rept 0x51</span><br><span class="line">   nop</span><br><span class="line">   .endr</span><br><span class="line">   loop:</span><br><span class="line">   mov rax,0x1</span><br></pre></td></tr></table></figure>

<h1 id="level24"><a href="#level24" class="headerlink" title="level24"></a>level24</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, we will combine the two prior levels and perform the following:</span><br><span class="line">  Create a two jump trampoline:</span><br><span class="line">    Make the first instruction in your code a jmp</span><br><span class="line">    Make that jmp a relative jump to 0x51 bytes from its current position</span><br><span class="line">    At 0x51 write the following code:</span><br><span class="line">      Place the top value on the stack into register rdi</span><br><span class="line">      jmp to the absolute address 0x403000</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  Loading your given code at: 0x400076</span><br><span class="line">  (stack) [0x7fffff1ffff8] = 0x1e</span><br></pre></td></tr></table></figure>

<p>关卡要求使用控制流操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   jmp loop</span><br><span class="line">   .rept 0x51</span><br><span class="line">   nop</span><br><span class="line">   .endr</span><br><span class="line">   loop:</span><br><span class="line">   mov rdi,[rsp]</span><br><span class="line">   mov rsi,0x403000</span><br><span class="line">   jmp rsi</span><br></pre></td></tr></table></figure>

<h1 id="level25"><a href="#level25" class="headerlink" title="level25"></a>level25</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line">We will be testing your code multiple times in this level with dynamic values! This means we will</span><br><span class="line">be running your code in a variety of random ways to verify that the logic is robust enough to</span><br><span class="line">survive normal use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We will now introduce you to conditional jumps--one of the most valuable instructions in x86.</span><br><span class="line">In higher level programming languages, an if-else structure exists to do things like:</span><br><span class="line">  if x is even:</span><br><span class="line">    is_even = 1</span><br><span class="line">  else:</span><br><span class="line">   is_even = 0</span><br><span class="line"></span><br><span class="line">This should look familiar, since it is implementable in only bit-logic, which you&#x27;ve done in a prior level.</span><br><span class="line"></span><br><span class="line">In these structures, we can control the program&#x27;s control flow based on dynamic values provided to the program.</span><br><span class="line"></span><br><span class="line">Implementing the above logic with jmps can be done like so:</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">; assume rdi = x, rax is output</span><br><span class="line">; rdx = rdi mod 2</span><br><span class="line">mov rax, rdi</span><br><span class="line">mov rsi, 2</span><br><span class="line">div rsi</span><br><span class="line">; remainder is 0 if even</span><br><span class="line">cmp rdx, 0</span><br><span class="line">; jump to not_even code is its not 0</span><br><span class="line">jne not_even</span><br><span class="line">; fall through to even code</span><br><span class="line">mov rbx, 1</span><br><span class="line">jmp done</span><br><span class="line">; jump to this only when not_even</span><br><span class="line">not_even:</span><br><span class="line">mov rbx, 0</span><br><span class="line">done:</span><br><span class="line">mov rax, rbx</span><br><span class="line">; more instructions here</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">Often though, you want more than just a single &#x27;if-else&#x27;.</span><br><span class="line"></span><br><span class="line">Sometimes you want two if checks, followed by an else.</span><br><span class="line"></span><br><span class="line">To do this, you need to make sure that you have control flow that &#x27;falls-through&#x27; to the next `if` after it fails.</span><br><span class="line"></span><br><span class="line">All must jump to the same `done` after execution to avoid the else.</span><br><span class="line"></span><br><span class="line">There are many jump types in x86, it will help to learn how they can be used.</span><br><span class="line"></span><br><span class="line">Nearly all of them rely on something called the ZF, the Zero Flag.</span><br><span class="line"></span><br><span class="line">The ZF is set to 1 when a cmp is equal. 0 otherwise.</span><br><span class="line"></span><br><span class="line">Using the above knowledge, implement the following:</span><br><span class="line">  if [x] is 0x7f454c46:</span><br><span class="line">    y = [x+4] + [x+8] + [x+12]</span><br><span class="line">  else if [x] is 0x00005A4D:</span><br><span class="line">    y = [x+4] - [x+8] - [x+12]</span><br><span class="line">  else:</span><br><span class="line">    y = [x+4] * [x+8] * [x+12]</span><br><span class="line"></span><br><span class="line">where:</span><br><span class="line">  x = rdi, y = rax.</span><br><span class="line"></span><br><span class="line">Assume each dereferenced value is a signed dword.</span><br><span class="line">This means the values can start as a negative value at each memory position.</span><br><span class="line"></span><br><span class="line">A valid solution will use the following at least once:</span><br><span class="line">  jmp (any variant), cmp</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;4 random dwords]&#125;</span><br><span class="line">  rdi = 0x404000</span><br></pre></td></tr></table></figure>



<p>关卡提示使用条件跳转，并讲解了ZF（零标志）</p>
<p>要求实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [x] is 0x7f454c46:</span><br><span class="line">y = [x+4] + [x+8] + [x+12]</span><br><span class="line">else if [x] is 0x00005A4D:</span><br><span class="line">y = [x+4] - [x+8] - [x+12]</span><br><span class="line">else:</span><br><span class="line">y = [x+4] * [x+8] * [x+12]</span><br><span class="line">其中：</span><br><span class="line">x = rdi，y = rax。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   mov eax,[rdi+4]</span><br><span class="line">   mov ebx,[rdi+8]</span><br><span class="line">   mov ecx,[rdi+12]</span><br><span class="line">   mov edx,[rdi]</span><br><span class="line"></span><br><span class="line">   cmp edx ,0x7f454c46</span><br><span class="line">   jne label1</span><br><span class="line">   add eax,ebx</span><br><span class="line">   add eax,ecx</span><br><span class="line">   jmp done</span><br><span class="line"></span><br><span class="line">   label1:</span><br><span class="line"> </span><br><span class="line">   cmp edx,0x00005A4D</span><br><span class="line">   jne label2</span><br><span class="line">   sub eax,ebx</span><br><span class="line">   sub eax,ecx</span><br><span class="line">   jmp done</span><br><span class="line"></span><br><span class="line">   label2:</span><br><span class="line">   imul eax,ebx</span><br><span class="line">   imul eax,ecx</span><br><span class="line"></span><br><span class="line">   done:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>



<h1 id="level26"><a href="#level26" class="headerlink" title="level26"></a>level26</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">In this level you will be working with control flow manipulation. This involves using instructions</span><br><span class="line">to both indirectly and directly control the special register `rip`, the instruction pointer.</span><br><span class="line">You will use instructions such as: jmp, call, cmp, and their alternatives to implement the requested behavior.</span><br><span class="line"></span><br><span class="line">We will be testing your code multiple times in this level with dynamic values! This means we will</span><br><span class="line">be running your code in a variety of random ways to verify that the logic is robust enough to</span><br><span class="line">survive normal use.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The last jump type is the indirect jump, which is often used for switch statements in the real world.</span><br><span class="line"></span><br><span class="line">Switch statements are a special case of if-statements that use only numbers to determine where the control flow will go.</span><br><span class="line"></span><br><span class="line">Here is an example:</span><br><span class="line">  switch(number):</span><br><span class="line">    0: jmp do_thing_0</span><br><span class="line">    1: jmp do_thing_1</span><br><span class="line">    2: jmp do_thing_2</span><br><span class="line">    default: jmp do_default_thing</span><br><span class="line"></span><br><span class="line">The switch in this example is working on `number`, which can either be 0, 1, or 2.</span><br><span class="line"></span><br><span class="line">In the case that `number` is not one of those numbers, the default triggers.</span><br><span class="line"></span><br><span class="line">You can consider this a reduced else-if type structure.</span><br><span class="line"></span><br><span class="line">In x86, you are already used to using numbers, so it should be no suprise that you can make if statements based on something being an exact number.</span><br><span class="line"></span><br><span class="line">In addition, if you know the range of the numbers, a switch statement works very well.</span><br><span class="line"></span><br><span class="line">Take for instance the existence of a jump table.</span><br><span class="line"></span><br><span class="line">A jump table is a contiguous section of memory that holds addresses of places to jump.</span><br><span class="line"></span><br><span class="line">In the above example, the jump table could look like:</span><br><span class="line">  [0x1337] = address of do_thing_0</span><br><span class="line">  [0x1337+0x8] = address of do_thing_1</span><br><span class="line">  [0x1337+0x10] = address of do_thing_2</span><br><span class="line">  [0x1337+0x18] = address of do_default_thing</span><br><span class="line"></span><br><span class="line">Using the jump table, we can greatly reduce the amount of cmps we use.</span><br><span class="line"></span><br><span class="line">Now all we need to check is if `number` is greater than 2.</span><br><span class="line"></span><br><span class="line">If it is, always do:</span><br><span class="line">  jmp [0x1337+0x18]</span><br><span class="line">Otherwise:</span><br><span class="line">  jmp [jump_table_address + number * 8]</span><br><span class="line"></span><br><span class="line">Using the above knowledge, implement the following logic:</span><br><span class="line">  if rdi is 0:</span><br><span class="line">    jmp 0x403034</span><br><span class="line">  else if rdi is 1:</span><br><span class="line">    jmp 0x403100</span><br><span class="line">  else if rdi is 2:</span><br><span class="line">    jmp 0x4031de</span><br><span class="line">  else if rdi is 3:</span><br><span class="line">    jmp 0x40326c</span><br><span class="line">  else:</span><br><span class="line">    jmp 0x403360</span><br><span class="line"></span><br><span class="line">Please do the above with the following constraints:</span><br><span class="line">  Assume rdi will NOT be negative</span><br><span class="line">  Use no more than 1 cmp instruction</span><br><span class="line">  Use no more than 3 jumps (of any variant)</span><br><span class="line">  We will provide you with the number to &#x27;switch&#x27; on in rdi.</span><br><span class="line">  We will provide you with a jump table base address in rsi.</span><br><span class="line"></span><br><span class="line">Here is an example table:</span><br><span class="line">  [0x404096] = 0x403034 (addrs will change)</span><br><span class="line">  [0x40409e] = 0x403100</span><br><span class="line">  [0x4040a6] = 0x4031de</span><br><span class="line">  [0x4040ae] = 0x40326c</span><br><span class="line">  [0x4040b6] = 0x403360</span><br></pre></td></tr></table></figure>

<p>关卡要求使用跳转表实现类似switch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   cmp rdi,4</span><br><span class="line">   jae deafult</span><br><span class="line">   jmp [rsi + rdi * 8]</span><br><span class="line">   jmp end</span><br><span class="line">   deafult:</span><br><span class="line">   jmp [rsi+4*8]</span><br><span class="line">   end:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>

<p>使用两个标签，end和deafult，根据rdi不同的值跳转到不同的地址</p>
<h1 id="level27"><a href="#level27" class="headerlink" title="level27"></a>level27</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In a previous level you computed the average of 4 integer quad words, which</span><br><span class="line">was a fixed amount of things to compute, but how do you work with sizes you get when</span><br><span class="line">the program is running?</span><br><span class="line"></span><br><span class="line">In most programming languages a structure exists called the</span><br><span class="line">for-loop, which allows you to do a set of instructions for a bounded amount of times.</span><br><span class="line">The bounded amount can be either known before or during the programs run, during meaning</span><br><span class="line">the value is given to you dynamically.</span><br><span class="line"></span><br><span class="line">As an example, a for-loop can be used to compute the sum of the numbers 1 to n:</span><br><span class="line">  sum = 0</span><br><span class="line">  i = 1</span><br><span class="line">  while i &lt;= n:</span><br><span class="line">    sum += i</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">Please compute the average of n consecutive quad words, where:</span><br><span class="line">  rdi = memory address of the 1st quad word</span><br><span class="line">  rsi = n (amount to loop for)</span><br><span class="line">  rax = average computed</span><br><span class="line"></span><br><span class="line">We will now set the following in preparation for your code:</span><br><span class="line">  [0x4040a0:0x404398] = &#123;n qwords]&#125;</span><br><span class="line">  rdi = 0x4040a0</span><br><span class="line">  rsi = 95</span><br></pre></td></tr></table></figure>

<p>本关要实现循环，计算n个值的平均数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor rax,rax </span><br><span class="line">   mov rbx,0</span><br><span class="line">   </span><br><span class="line">   loop:</span><br><span class="line">   cmp rsi,rbx</span><br><span class="line">   jz cac</span><br><span class="line">   add rax,[rdi+8*rbx]</span><br><span class="line">   inc rbx</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   cac:</span><br><span class="line">   div rax,rsi</span><br></pre></td></tr></table></figure>

<p>首先设置rbx为循环次数，当rbx小于rsi时继续循环，将值不断加到rax中，最终跳出循环后除以rsi</p>
<h1 id="level28"><a href="#level28" class="headerlink" title="level28"></a>level28</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">In previous levels you discovered the for-loop to iterate for a *number* of times, both dynamically and</span><br><span class="line">statically known, but what happens when you want to iterate until you meet a condition?</span><br><span class="line"></span><br><span class="line">A second loop structure exists called the while-loop to fill this demand.</span><br><span class="line"></span><br><span class="line">In the while-loop you iterate until a condition is met.</span><br><span class="line"></span><br><span class="line">As an example, say we had a location in memory with adjacent numbers and we wanted</span><br><span class="line">to get the average of all the numbers until we find one bigger or equal to 0xff:</span><br><span class="line">  average = 0</span><br><span class="line">  i = 0</span><br><span class="line">  while x[i] &lt; 0xff:</span><br><span class="line">    average += x[i]</span><br><span class="line">    i += 1</span><br><span class="line">  average /= i</span><br><span class="line"></span><br><span class="line">Using the above knowledge, please perform the following:</span><br><span class="line">  Count the consecutive non-zero bytes in a contiguous region of memory, where:</span><br><span class="line">    rdi = memory address of the 1st byte</span><br><span class="line">    rax = number of consecutive non-zero bytes</span><br><span class="line"></span><br><span class="line">Additionally, if rdi = 0, then set rax = 0 (we will check)!</span><br><span class="line"></span><br><span class="line">An example test-case, let:</span><br><span class="line">  rdi = 0x1000</span><br><span class="line">  [0x1000] = 0x41</span><br><span class="line">  [0x1001] = 0x42</span><br><span class="line">  [0x1002] = 0x43</span><br><span class="line">  [0x1003] = 0x00</span><br><span class="line"></span><br><span class="line">then: rax = 3 should be set</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;10 random bytes&#125;,</span><br><span class="line">  rdi = 0x404000</span><br></pre></td></tr></table></figure>



<p>本关要求实现while循环，要求循环全部连续非零字节数</p>
<p>本关还有当rdi&#x3D;0时rax&#x3D;0的特殊检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor rax,rax </span><br><span class="line">   xor rbx,rbx</span><br><span class="line">   cmp rdi,0</span><br><span class="line">   jz end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   loop:</span><br><span class="line">   cmp rbx,[rdi]</span><br><span class="line">   jae end</span><br><span class="line">   inc rax</span><br><span class="line">   inc rdi</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   end:</span><br><span class="line">   nop</span><br></pre></td></tr></table></figure>

<h1 id="level29"><a href="#level29" class="headerlink" title="level29"></a>level29</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">In previous levels you implemented a while loop to count the number of</span><br><span class="line">consecutive non-zero bytes in a contiguous region of memory.</span><br><span class="line"></span><br><span class="line">In this level you will be provided with a contiguous region of memory again and will loop</span><br><span class="line">over each performing a conditional operation till a zero byte is reached.</span><br><span class="line">All of which will be contained in a function!</span><br><span class="line"></span><br><span class="line">A function is a callable segment of code that does not destroy control flow.</span><br><span class="line"></span><br><span class="line">Functions use the instructions &quot;call&quot; and &quot;ret&quot;.</span><br><span class="line"></span><br><span class="line">The &quot;call&quot; instruction pushes the memory address of the next instruction onto</span><br><span class="line">the stack and then jumps to the value stored in the first argument.</span><br><span class="line"></span><br><span class="line">Let&#x27;s use the following instructions as an example:</span><br><span class="line">  0x1021 mov rax, 0x400000</span><br><span class="line">  0x1028 call rax</span><br><span class="line">  0x102a mov [rsi], rax</span><br><span class="line"></span><br><span class="line">1. call pushes 0x102a, the address of the next instruction, onto the stack.</span><br><span class="line">2. call jumps to 0x400000, the value stored in rax.</span><br><span class="line"></span><br><span class="line">The &quot;ret&quot; instruction is the opposite of &quot;call&quot;.</span><br><span class="line"></span><br><span class="line">ret pops the top value off of the stack and jumps to it.</span><br><span class="line"></span><br><span class="line">Let&#x27;s use the following instructions and stack as an example:</span><br><span class="line"></span><br><span class="line">                              Stack ADDR  VALUE</span><br><span class="line">  0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef</span><br><span class="line">  0x1042 ret                  RSP + 0x0   0x0000102a</span><br><span class="line"></span><br><span class="line">Here, ret will jump to 0x102a</span><br><span class="line"></span><br><span class="line">Please implement the following logic:</span><br><span class="line">  str_lower(src_addr):</span><br><span class="line">    i = 0</span><br><span class="line">    if src_addr != 0:</span><br><span class="line">      while [src_addr] != 0x00:</span><br><span class="line">        if [src_addr] &lt;= 0x5a:</span><br><span class="line">          [src_addr] = foo([src_addr])</span><br><span class="line">          i += 1</span><br><span class="line">        src_addr += 1</span><br><span class="line">    return i</span><br><span class="line"></span><br><span class="line">foo is provided at 0x403000.</span><br><span class="line">foo takes a single argument as a value and returns a value.</span><br><span class="line"></span><br><span class="line">All functions (foo and str_lower) must follow the Linux amd64 calling convention (also known as System V AMD64 ABI):</span><br><span class="line">  https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</span><br><span class="line"></span><br><span class="line">Therefore, your function str_lower should look for src_addr in rdi and place the function return in rax.</span><br><span class="line"></span><br><span class="line">An important note is that src_addr is an address in memory (where the string is located) and [src_addr] refers to the byte that exists at src_addr.</span><br><span class="line"></span><br><span class="line">Therefore, the function foo accepts a byte as its first argument and returns a byte.</span><br><span class="line"></span><br><span class="line">We will now run multiple tests on your code, here is an example run:</span><br><span class="line">  (data) [0x404000] = &#123;10 random bytes&#125;,</span><br><span class="line">  rdi = 0x404000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本关要求实现一个函数，遵循linux amd64调用约定</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI</a></p>
<p>使用rbx作为src_addr，r10来当作i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">   xor r10,r10</span><br><span class="line">   cmp rdi,0</span><br><span class="line">   jz zero</span><br><span class="line"></span><br><span class="line">   loop:</span><br><span class="line">   mov rbx,rdi</span><br><span class="line">   mov rax,0x403000</span><br><span class="line">   xor rdi,rdi</span><br><span class="line">   mov dil,byte ptr [rbx]</span><br><span class="line">   cmp dil,0</span><br><span class="line">   je zero</span><br><span class="line">   cmp dil,0x5a</span><br><span class="line">   jg loop1</span><br><span class="line">   inc r10</span><br><span class="line">   call rax</span><br><span class="line">   mov byte ptr [rbx],al </span><br><span class="line">   </span><br><span class="line">   loop1:</span><br><span class="line">   mov rdi,rbx # 最后将rbx的结果返还给rdi</span><br><span class="line">   inc rdi</span><br><span class="line">   jmp loop</span><br><span class="line"></span><br><span class="line">   zero:</span><br><span class="line">   mov rax,r10</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h1 id="level30"><a href="#level30" class="headerlink" title="level30"></a>level30</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">In the previous level, you learned how to make your first function and how to call other functions.</span><br><span class="line"></span><br><span class="line">Now we will work with functions that have a function stack frame.</span><br><span class="line"></span><br><span class="line">A function stack frame is a set of pointers and values pushed onto the stack to save things for later use and allocate space on the stack for function variables.</span><br><span class="line"></span><br><span class="line">First, let&#x27;s talk about the special register rbp, the Stack Base Pointer.</span><br><span class="line"></span><br><span class="line">The rbp register is used to tell where our stack frame first started.</span><br><span class="line"></span><br><span class="line">As an example, say we want to construct some list (a contigous space of memory) that is only used in our function.</span><br><span class="line"></span><br><span class="line">The list is 5 elements long, and each element is a dword.</span><br><span class="line"></span><br><span class="line">A list of 5 elements would already take 5 registers, so instead, we can make space on the stack!</span><br><span class="line"></span><br><span class="line">The assembly would look like:</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">; setup the base of the stack as the current top</span><br><span class="line">mov rbp, rsp</span><br><span class="line">; move the stack 0x14 bytes (5 * 4) down</span><br><span class="line">; acts as an allocation</span><br><span class="line">sub rsp, 0x14</span><br><span class="line">; assign list[2] = 1337</span><br><span class="line">mov eax, 1337</span><br><span class="line">mov [rbp-0x8], eax</span><br><span class="line">; do more operations on the list ...</span><br><span class="line">; restore the allocated space</span><br><span class="line">mov rsp, rbp</span><br><span class="line">ret</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">Notice how rbp is always used to restore the stack to where it originally was.</span><br><span class="line"></span><br><span class="line">If we don&#x27;t restore the stack after use, we will eventually run out.</span><br><span class="line"></span><br><span class="line">In addition, notice how we subtracted from rsp, because the stack grows down.</span><br><span class="line"></span><br><span class="line">To make the stack have more space, we subtract the space we need.</span><br><span class="line"></span><br><span class="line">The ret and call still works the same.</span><br><span class="line"></span><br><span class="line">Once, again, please make function(s) that implements the following:</span><br><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br><span class="line"></span><br><span class="line">Assumptions:</span><br><span class="line">  There will never be more than 0xffff of any byte</span><br><span class="line">  The size will never be longer than 0xffff</span><br><span class="line">  The list will have at least one element</span><br><span class="line">Constraints:</span><br><span class="line">  You must put the &quot;counting list&quot; on the stack</span><br><span class="line">  You must restore the stack like in a normal function</span><br><span class="line">  You cannot modify the data at src_addr</span><br></pre></td></tr></table></figure>

<p>本关要求创建一个具有堆栈框架函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.section .text</span><br><span class="line">.global most_common_byte</span><br><span class="line"></span><br><span class="line">.intel_syntax noprefix</span><br><span class="line"></span><br><span class="line">most_common_byte:</span><br><span class="line">    mov rbp,rsp</span><br><span class="line">    sub rsp,0x100</span><br><span class="line">    xor r10,r10</span><br><span class="line">    </span><br><span class="line">    loop1:</span><br><span class="line">    cmp r10,rsi</span><br><span class="line">    jge a</span><br><span class="line">    mov dl,byte ptr [rdi+r10]</span><br><span class="line">    add byte ptr [rsp+rdx],1</span><br><span class="line">    inc r10</span><br><span class="line">    jmp loop1</span><br><span class="line"></span><br><span class="line">    a:</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rax,rax</span><br><span class="line">    jmp loop2</span><br><span class="line"></span><br><span class="line">    loop2:</span><br><span class="line">    cmp rbx,0xff</span><br><span class="line">    jg b</span><br><span class="line">    cmp [rsp+rbx],cl</span><br><span class="line">    jle c</span><br><span class="line">    mov cl,[rsp+rbx]</span><br><span class="line">    mov rax,rbx</span><br><span class="line">    </span><br><span class="line">    c:</span><br><span class="line">    inc rbx</span><br><span class="line">    jmp loop2</span><br><span class="line">    </span><br><span class="line">    b:</span><br><span class="line">    mov rsp,rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"># pwn</a>
              <a href="/tags/pwn-college/" rel="tag"># pwn-college</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/18/pwn-college-Program-Interaction-Fundamentals/" rel="prev" title="Program-Interaction-Fundamentals">
                  <i class="fa fa-angle-left"></i> Program-Interaction-Fundamentals
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/21/pwn-college-building-a-web-server/" rel="next" title="building-a-web-server">
                  building-a-web-server <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lianwu</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
